//------------------------------------------------------------------------------
// AllSyntax.h
// All generated syntax node data structures.
//
// File is under the MIT license; see LICENSE for details.
//------------------------------------------------------------------------------
#pragma once

#include "lexing/Token.h"
#include "util/BumpAllocator.h"
#include "SyntaxNode.h"

// This file contains all parse tree syntax nodes.
// It is auto-generated by the syntax_gen.py script under the tools/ directory.

namespace slang {

struct ExpressionSyntax : public SyntaxNode {

    ExpressionSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct DataTypeSyntax : public ExpressionSyntax {

    DataTypeSyntax(SyntaxKind kind) :
        ExpressionSyntax(kind)
    {
    }
};

// ----- ATTRIBUTES -----

struct EqualsValueClauseSyntax : public SyntaxNode {
    Token equals;
    ExpressionSyntax& expr;

    EqualsValueClauseSyntax(Token equals, ExpressionSyntax& expr) :
        SyntaxNode(SyntaxKind::EqualsValueClause), equals(equals), expr(expr)
    {
        childCount += 2;
    }

    EqualsValueClauseSyntax(const EqualsValueClauseSyntax&) = delete;
    EqualsValueClauseSyntax& operator=(const EqualsValueClauseSyntax&) = delete;

    static const EqualsValueClauseSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return equals;
            case 1: return &expr;
            default: return nullptr;
        }
    }
};

struct AttributeSpecSyntax : public SyntaxNode {
    Token name;
    EqualsValueClauseSyntax* value;

    AttributeSpecSyntax(Token name, EqualsValueClauseSyntax* value) :
        SyntaxNode(SyntaxKind::AttributeSpec), name(name), value(value)
    {
        childCount += 2;
    }

    AttributeSpecSyntax(const AttributeSpecSyntax&) = delete;
    AttributeSpecSyntax& operator=(const AttributeSpecSyntax&) = delete;

    static const AttributeSpecSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return name;
            case 1: return value;
            default: return nullptr;
        }
    }
};

struct AttributeInstanceSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<AttributeSpecSyntax> specs;
    Token closeParen;

    AttributeInstanceSyntax(Token openParen, SeparatedSyntaxList<AttributeSpecSyntax> specs, Token closeParen) :
        SyntaxNode(SyntaxKind::AttributeInstance), openParen(openParen), specs(specs), closeParen(closeParen)
    {
        childCount += 3;
    }

    AttributeInstanceSyntax(const AttributeInstanceSyntax&) = delete;
    AttributeInstanceSyntax& operator=(const AttributeInstanceSyntax&) = delete;

    static const AttributeInstanceSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &specs;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct NamedLabelSyntax : public SyntaxNode {
    Token name;
    Token colon;

    NamedLabelSyntax(Token name, Token colon) :
        SyntaxNode(SyntaxKind::NamedLabel), name(name), colon(colon)
    {
        childCount += 2;
    }

    NamedLabelSyntax(const NamedLabelSyntax&) = delete;
    NamedLabelSyntax& operator=(const NamedLabelSyntax&) = delete;

    static const NamedLabelSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return name;
            case 1: return colon;
            default: return nullptr;
        }
    }
};

struct StatementSyntax : public SyntaxNode {
    NamedLabelSyntax* label;
    SyntaxList<AttributeInstanceSyntax> attributes;

    StatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes) :
        SyntaxNode(kind), label(label), attributes(attributes)
    {
        childCount += 2;
    }

    StatementSyntax(const StatementSyntax&) = delete;
    StatementSyntax& operator=(const StatementSyntax&) = delete;

    static const StatementSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            default: return nullptr;
        }
    }
};

struct MemberSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;

    MemberSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes) :
        SyntaxNode(kind), attributes(attributes)
    {
        childCount += 1;
    }

    MemberSyntax(const MemberSyntax&) = delete;
    MemberSyntax& operator=(const MemberSyntax&) = delete;

    static const MemberSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override {
        switch (index) {
            case 0: return &attributes;
            default: return nullptr;
        }
    }
};

// ----- ARGUMENTS -----

struct ArgumentSyntax : public SyntaxNode {

    ArgumentSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct EmptyArgumentSyntax : public ArgumentSyntax {

    EmptyArgumentSyntax() :
        ArgumentSyntax(SyntaxKind::EmptyArgument)
    {
        childCount += 0;
    }

    EmptyArgumentSyntax(const EmptyArgumentSyntax&) = delete;
    EmptyArgumentSyntax& operator=(const EmptyArgumentSyntax&) = delete;

    static const EmptyArgumentSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        (void)index;
        return nullptr;
    }
};

struct OrderedArgumentSyntax : public ArgumentSyntax {
    ExpressionSyntax& expr;

    OrderedArgumentSyntax(ExpressionSyntax& expr) :
        ArgumentSyntax(SyntaxKind::OrderedArgument), expr(expr)
    {
        childCount += 1;
    }

    OrderedArgumentSyntax(const OrderedArgumentSyntax&) = delete;
    OrderedArgumentSyntax& operator=(const OrderedArgumentSyntax&) = delete;

    static const OrderedArgumentSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &expr;
            default: return nullptr;
        }
    }
};

struct NamedArgumentSyntax : public ArgumentSyntax {
    Token dot;
    Token name;
    Token openParen;
    ExpressionSyntax* expr;
    Token closeParen;

    NamedArgumentSyntax(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) :
        ArgumentSyntax(SyntaxKind::NamedArgument), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 5;
    }

    NamedArgumentSyntax(const NamedArgumentSyntax&) = delete;
    NamedArgumentSyntax& operator=(const NamedArgumentSyntax&) = delete;

    static const NamedArgumentSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return dot;
            case 1: return name;
            case 2: return openParen;
            case 3: return expr;
            case 4: return closeParen;
            default: return nullptr;
        }
    }
};

struct ArgumentListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<ArgumentSyntax> parameters;
    Token closeParen;

    ArgumentListSyntax(Token openParen, SeparatedSyntaxList<ArgumentSyntax> parameters, Token closeParen) :
        SyntaxNode(SyntaxKind::ArgumentList), openParen(openParen), parameters(parameters), closeParen(closeParen)
    {
        childCount += 3;
    }

    ArgumentListSyntax(const ArgumentListSyntax&) = delete;
    ArgumentListSyntax& operator=(const ArgumentListSyntax&) = delete;

    static const ArgumentListSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &parameters;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct ParameterValueAssignmentSyntax : public SyntaxNode {
    Token hash;
    ArgumentListSyntax& parameters;

    ParameterValueAssignmentSyntax(Token hash, ArgumentListSyntax& parameters) :
        SyntaxNode(SyntaxKind::ParameterValueAssignment), hash(hash), parameters(parameters)
    {
        childCount += 2;
    }

    ParameterValueAssignmentSyntax(const ParameterValueAssignmentSyntax&) = delete;
    ParameterValueAssignmentSyntax& operator=(const ParameterValueAssignmentSyntax&) = delete;

    static const ParameterValueAssignmentSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return hash;
            case 1: return &parameters;
            default: return nullptr;
        }
    }
};

// ----- PATTERNS -----

struct PatternSyntax : public SyntaxNode {

    PatternSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct VariablePatternSyntax : public PatternSyntax {
    Token dot;
    Token variableName;

    VariablePatternSyntax(Token dot, Token variableName) :
        PatternSyntax(SyntaxKind::VariablePattern), dot(dot), variableName(variableName)
    {
        childCount += 2;
    }

    VariablePatternSyntax(const VariablePatternSyntax&) = delete;
    VariablePatternSyntax& operator=(const VariablePatternSyntax&) = delete;

    static const VariablePatternSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return dot;
            case 1: return variableName;
            default: return nullptr;
        }
    }
};

struct WildcardPatternSyntax : public PatternSyntax {
    Token dotStar;

    WildcardPatternSyntax(Token dotStar) :
        PatternSyntax(SyntaxKind::WildcardPattern), dotStar(dotStar)
    {
        childCount += 1;
    }

    WildcardPatternSyntax(const WildcardPatternSyntax&) = delete;
    WildcardPatternSyntax& operator=(const WildcardPatternSyntax&) = delete;

    static const WildcardPatternSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return dotStar;
            default: return nullptr;
        }
    }
};

struct ExpressionPatternSyntax : public PatternSyntax {
    ExpressionSyntax& expr;

    ExpressionPatternSyntax(ExpressionSyntax& expr) :
        PatternSyntax(SyntaxKind::ExpressionPattern), expr(expr)
    {
        childCount += 1;
    }

    ExpressionPatternSyntax(const ExpressionPatternSyntax&) = delete;
    ExpressionPatternSyntax& operator=(const ExpressionPatternSyntax&) = delete;

    static const ExpressionPatternSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &expr;
            default: return nullptr;
        }
    }
};

struct TaggedPatternSyntax : public PatternSyntax {
    Token tagged;
    Token memberName;
    PatternSyntax* pattern;

    TaggedPatternSyntax(Token tagged, Token memberName, PatternSyntax* pattern) :
        PatternSyntax(SyntaxKind::TaggedPattern), tagged(tagged), memberName(memberName), pattern(pattern)
    {
        childCount += 3;
    }

    TaggedPatternSyntax(const TaggedPatternSyntax&) = delete;
    TaggedPatternSyntax& operator=(const TaggedPatternSyntax&) = delete;

    static const TaggedPatternSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return tagged;
            case 1: return memberName;
            case 2: return pattern;
            default: return nullptr;
        }
    }
};

struct StructurePatternMemberSyntax : public SyntaxNode {

    StructurePatternMemberSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct OrderedStructurePatternMemberSyntax : public StructurePatternMemberSyntax {
    PatternSyntax& pattern;

    OrderedStructurePatternMemberSyntax(PatternSyntax& pattern) :
        StructurePatternMemberSyntax(SyntaxKind::OrderedStructurePatternMember), pattern(pattern)
    {
        childCount += 1;
    }

    OrderedStructurePatternMemberSyntax(const OrderedStructurePatternMemberSyntax&) = delete;
    OrderedStructurePatternMemberSyntax& operator=(const OrderedStructurePatternMemberSyntax&) = delete;

    static const OrderedStructurePatternMemberSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &pattern;
            default: return nullptr;
        }
    }
};

struct NamedStructurePatternMemberSyntax : public StructurePatternMemberSyntax {
    Token name;
    Token colon;
    PatternSyntax& pattern;

    NamedStructurePatternMemberSyntax(Token name, Token colon, PatternSyntax& pattern) :
        StructurePatternMemberSyntax(SyntaxKind::NamedStructurePatternMember), name(name), colon(colon), pattern(pattern)
    {
        childCount += 3;
    }

    NamedStructurePatternMemberSyntax(const NamedStructurePatternMemberSyntax&) = delete;
    NamedStructurePatternMemberSyntax& operator=(const NamedStructurePatternMemberSyntax&) = delete;

    static const NamedStructurePatternMemberSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return name;
            case 1: return colon;
            case 2: return &pattern;
            default: return nullptr;
        }
    }
};

struct StructurePatternSyntax : public PatternSyntax {
    Token openBrace;
    SeparatedSyntaxList<StructurePatternMemberSyntax> members;
    Token closeBrace;

    StructurePatternSyntax(Token openBrace, SeparatedSyntaxList<StructurePatternMemberSyntax> members, Token closeBrace) :
        PatternSyntax(SyntaxKind::StructurePattern), openBrace(openBrace), members(members), closeBrace(closeBrace)
    {
        childCount += 3;
    }

    StructurePatternSyntax(const StructurePatternSyntax&) = delete;
    StructurePatternSyntax& operator=(const StructurePatternSyntax&) = delete;

    static const StructurePatternSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return &members;
            case 2: return closeBrace;
            default: return nullptr;
        }
    }
};

struct MatchesClauseSyntax : public SyntaxNode {
    Token matchesKeyword;
    PatternSyntax& pattern;

    MatchesClauseSyntax(Token matchesKeyword, PatternSyntax& pattern) :
        SyntaxNode(SyntaxKind::MatchesClause), matchesKeyword(matchesKeyword), pattern(pattern)
    {
        childCount += 2;
    }

    MatchesClauseSyntax(const MatchesClauseSyntax&) = delete;
    MatchesClauseSyntax& operator=(const MatchesClauseSyntax&) = delete;

    static const MatchesClauseSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return matchesKeyword;
            case 1: return &pattern;
            default: return nullptr;
        }
    }
};

struct ConditionalPatternSyntax : public SyntaxNode {
    ExpressionSyntax& expr;
    MatchesClauseSyntax* matchesClause;

    ConditionalPatternSyntax(ExpressionSyntax& expr, MatchesClauseSyntax* matchesClause) :
        SyntaxNode(SyntaxKind::ConditionalPattern), expr(expr), matchesClause(matchesClause)
    {
        childCount += 2;
    }

    ConditionalPatternSyntax(const ConditionalPatternSyntax&) = delete;
    ConditionalPatternSyntax& operator=(const ConditionalPatternSyntax&) = delete;

    static const ConditionalPatternSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &expr;
            case 1: return matchesClause;
            default: return nullptr;
        }
    }
};

struct ConditionalPredicateSyntax : public SyntaxNode {
    SeparatedSyntaxList<ConditionalPatternSyntax> conditions;

    ConditionalPredicateSyntax(SeparatedSyntaxList<ConditionalPatternSyntax> conditions) :
        SyntaxNode(SyntaxKind::ConditionalPredicate), conditions(conditions)
    {
        childCount += 1;
    }

    ConditionalPredicateSyntax(const ConditionalPredicateSyntax&) = delete;
    ConditionalPredicateSyntax& operator=(const ConditionalPredicateSyntax&) = delete;

    static const ConditionalPredicateSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &conditions;
            default: return nullptr;
        }
    }
};

struct AssignmentPatternSyntax : public SyntaxNode {

    AssignmentPatternSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct SimpleAssignmentPatternSyntax : public AssignmentPatternSyntax {
    Token openBrace;
    SeparatedSyntaxList<ExpressionSyntax> items;
    Token closeBrace;

    SimpleAssignmentPatternSyntax(Token openBrace, SeparatedSyntaxList<ExpressionSyntax> items, Token closeBrace) :
        AssignmentPatternSyntax(SyntaxKind::SimpleAssignmentPattern), openBrace(openBrace), items(items), closeBrace(closeBrace)
    {
        childCount += 3;
    }

    SimpleAssignmentPatternSyntax(const SimpleAssignmentPatternSyntax&) = delete;
    SimpleAssignmentPatternSyntax& operator=(const SimpleAssignmentPatternSyntax&) = delete;

    static const SimpleAssignmentPatternSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return &items;
            case 2: return closeBrace;
            default: return nullptr;
        }
    }
};

struct AssignmentPatternItemSyntax : public SyntaxNode {
    ExpressionSyntax& key;
    Token colon;
    ExpressionSyntax& expr;

    AssignmentPatternItemSyntax(ExpressionSyntax& key, Token colon, ExpressionSyntax& expr) :
        SyntaxNode(SyntaxKind::AssignmentPatternItem), key(key), colon(colon), expr(expr)
    {
        childCount += 3;
    }

    AssignmentPatternItemSyntax(const AssignmentPatternItemSyntax&) = delete;
    AssignmentPatternItemSyntax& operator=(const AssignmentPatternItemSyntax&) = delete;

    static const AssignmentPatternItemSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &key;
            case 1: return colon;
            case 2: return &expr;
            default: return nullptr;
        }
    }
};

struct StructuredAssignmentPatternSyntax : public AssignmentPatternSyntax {
    Token openBrace;
    SeparatedSyntaxList<AssignmentPatternItemSyntax> items;
    Token closeBrace;

    StructuredAssignmentPatternSyntax(Token openBrace, SeparatedSyntaxList<AssignmentPatternItemSyntax> items, Token closeBrace) :
        AssignmentPatternSyntax(SyntaxKind::StructuredAssignmentPattern), openBrace(openBrace), items(items), closeBrace(closeBrace)
    {
        childCount += 3;
    }

    StructuredAssignmentPatternSyntax(const StructuredAssignmentPatternSyntax&) = delete;
    StructuredAssignmentPatternSyntax& operator=(const StructuredAssignmentPatternSyntax&) = delete;

    static const StructuredAssignmentPatternSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return &items;
            case 2: return closeBrace;
            default: return nullptr;
        }
    }
};

struct ReplicatedAssignmentPatternSyntax : public AssignmentPatternSyntax {
    Token openBrace;
    ExpressionSyntax& countExpr;
    Token innerOpenBrace;
    SeparatedSyntaxList<ExpressionSyntax> items;
    Token innerCloseBrace;
    Token closeBrace;

    ReplicatedAssignmentPatternSyntax(Token openBrace, ExpressionSyntax& countExpr, Token innerOpenBrace, SeparatedSyntaxList<ExpressionSyntax> items, Token innerCloseBrace, Token closeBrace) :
        AssignmentPatternSyntax(SyntaxKind::ReplicatedAssignmentPattern), openBrace(openBrace), countExpr(countExpr), innerOpenBrace(innerOpenBrace), items(items), innerCloseBrace(innerCloseBrace), closeBrace(closeBrace)
    {
        childCount += 6;
    }

    ReplicatedAssignmentPatternSyntax(const ReplicatedAssignmentPatternSyntax&) = delete;
    ReplicatedAssignmentPatternSyntax& operator=(const ReplicatedAssignmentPatternSyntax&) = delete;

    static const ReplicatedAssignmentPatternSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return &countExpr;
            case 2: return innerOpenBrace;
            case 3: return &items;
            case 4: return innerCloseBrace;
            case 5: return closeBrace;
            default: return nullptr;
        }
    }
};

// ----- EXPRESSIONS -----

struct BadExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax& expr;

    BadExpressionSyntax(ExpressionSyntax& expr) :
        ExpressionSyntax(SyntaxKind::BadExpression), expr(expr)
    {
        childCount += 1;
    }

    BadExpressionSyntax(const BadExpressionSyntax&) = delete;
    BadExpressionSyntax& operator=(const BadExpressionSyntax&) = delete;

    static const BadExpressionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &expr;
            default: return nullptr;
        }
    }
};

struct PrimaryExpressionSyntax : public ExpressionSyntax {

    PrimaryExpressionSyntax(SyntaxKind kind) :
        ExpressionSyntax(kind)
    {
    }
};

struct PrefixUnaryExpressionSyntax : public ExpressionSyntax {
    Token operatorToken;
    SyntaxList<AttributeInstanceSyntax> attributes;
    ExpressionSyntax& operand;

    PrefixUnaryExpressionSyntax(SyntaxKind kind, Token operatorToken, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& operand) :
        ExpressionSyntax(kind), operatorToken(operatorToken), attributes(attributes), operand(operand)
    {
        childCount += 3;
    }

    PrefixUnaryExpressionSyntax(const PrefixUnaryExpressionSyntax&) = delete;
    PrefixUnaryExpressionSyntax& operator=(const PrefixUnaryExpressionSyntax&) = delete;

    static const PrefixUnaryExpressionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return operatorToken;
            case 1: return &attributes;
            case 2: return &operand;
            default: return nullptr;
        }
    }
};

struct PostfixUnaryExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax& operand;
    SyntaxList<AttributeInstanceSyntax> attributes;
    Token operatorToken;

    PostfixUnaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax& operand, SyntaxList<AttributeInstanceSyntax> attributes, Token operatorToken) :
        ExpressionSyntax(kind), operand(operand), attributes(attributes), operatorToken(operatorToken)
    {
        childCount += 3;
    }

    PostfixUnaryExpressionSyntax(const PostfixUnaryExpressionSyntax&) = delete;
    PostfixUnaryExpressionSyntax& operator=(const PostfixUnaryExpressionSyntax&) = delete;

    static const PostfixUnaryExpressionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &operand;
            case 1: return &attributes;
            case 2: return operatorToken;
            default: return nullptr;
        }
    }
};

struct BinaryExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax& left;
    Token operatorToken;
    SyntaxList<AttributeInstanceSyntax> attributes;
    ExpressionSyntax& right;

    BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax& left, Token operatorToken, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& right) :
        ExpressionSyntax(kind), left(left), operatorToken(operatorToken), attributes(attributes), right(right)
    {
        childCount += 4;
    }

    BinaryExpressionSyntax(const BinaryExpressionSyntax&) = delete;
    BinaryExpressionSyntax& operator=(const BinaryExpressionSyntax&) = delete;

    static const BinaryExpressionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &left;
            case 1: return operatorToken;
            case 2: return &attributes;
            case 3: return &right;
            default: return nullptr;
        }
    }
};

struct MinTypMaxExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax& min;
    Token colon1;
    ExpressionSyntax& typ;
    Token colon2;
    ExpressionSyntax& max;

    MinTypMaxExpressionSyntax(ExpressionSyntax& min, Token colon1, ExpressionSyntax& typ, Token colon2, ExpressionSyntax& max) :
        ExpressionSyntax(SyntaxKind::MinTypMaxExpression), min(min), colon1(colon1), typ(typ), colon2(colon2), max(max)
    {
        childCount += 5;
    }

    MinTypMaxExpressionSyntax(const MinTypMaxExpressionSyntax&) = delete;
    MinTypMaxExpressionSyntax& operator=(const MinTypMaxExpressionSyntax&) = delete;

    static const MinTypMaxExpressionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &min;
            case 1: return colon1;
            case 2: return &typ;
            case 3: return colon2;
            case 4: return &max;
            default: return nullptr;
        }
    }
};

struct TaggedUnionExpressionSyntax : public ExpressionSyntax {
    Token tagged;
    Token member;
    ExpressionSyntax* expr;

    TaggedUnionExpressionSyntax(Token tagged, Token member, ExpressionSyntax* expr) :
        ExpressionSyntax(SyntaxKind::TaggedUnionExpression), tagged(tagged), member(member), expr(expr)
    {
        childCount += 3;
    }

    TaggedUnionExpressionSyntax(const TaggedUnionExpressionSyntax&) = delete;
    TaggedUnionExpressionSyntax& operator=(const TaggedUnionExpressionSyntax&) = delete;

    static const TaggedUnionExpressionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return tagged;
            case 1: return member;
            case 2: return expr;
            default: return nullptr;
        }
    }
};

struct OpenRangeListSyntax : public SyntaxNode {
    Token openBrace;
    SeparatedSyntaxList<ExpressionSyntax> valueRanges;
    Token closeBrace;

    OpenRangeListSyntax(Token openBrace, SeparatedSyntaxList<ExpressionSyntax> valueRanges, Token closeBrace) :
        SyntaxNode(SyntaxKind::OpenRangeList), openBrace(openBrace), valueRanges(valueRanges), closeBrace(closeBrace)
    {
        childCount += 3;
    }

    OpenRangeListSyntax(const OpenRangeListSyntax&) = delete;
    OpenRangeListSyntax& operator=(const OpenRangeListSyntax&) = delete;

    static const OpenRangeListSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return &valueRanges;
            case 2: return closeBrace;
            default: return nullptr;
        }
    }
};

struct InsideExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax& expr;
    Token inside;
    OpenRangeListSyntax& ranges;

    InsideExpressionSyntax(ExpressionSyntax& expr, Token inside, OpenRangeListSyntax& ranges) :
        ExpressionSyntax(SyntaxKind::InsideExpression), expr(expr), inside(inside), ranges(ranges)
    {
        childCount += 3;
    }

    InsideExpressionSyntax(const InsideExpressionSyntax&) = delete;
    InsideExpressionSyntax& operator=(const InsideExpressionSyntax&) = delete;

    static const InsideExpressionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &expr;
            case 1: return inside;
            case 2: return &ranges;
            default: return nullptr;
        }
    }
};

struct ConditionalExpressionSyntax : public ExpressionSyntax {
    ConditionalPredicateSyntax& predicate;
    Token question;
    SyntaxList<AttributeInstanceSyntax> attributes;
    ExpressionSyntax& left;
    Token colon;
    ExpressionSyntax& right;

    ConditionalExpressionSyntax(ConditionalPredicateSyntax& predicate, Token question, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& left, Token colon, ExpressionSyntax& right) :
        ExpressionSyntax(SyntaxKind::ConditionalExpression), predicate(predicate), question(question), attributes(attributes), left(left), colon(colon), right(right)
    {
        childCount += 6;
    }

    ConditionalExpressionSyntax(const ConditionalExpressionSyntax&) = delete;
    ConditionalExpressionSyntax& operator=(const ConditionalExpressionSyntax&) = delete;

    static const ConditionalExpressionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &predicate;
            case 1: return question;
            case 2: return &attributes;
            case 3: return &left;
            case 4: return colon;
            case 5: return &right;
            default: return nullptr;
        }
    }
};

struct AssignmentPatternExpressionSyntax : public PrimaryExpressionSyntax {
    DataTypeSyntax* type;
    AssignmentPatternSyntax& pattern;

    AssignmentPatternExpressionSyntax(DataTypeSyntax* type, AssignmentPatternSyntax& pattern) :
        PrimaryExpressionSyntax(SyntaxKind::AssignmentPatternExpression), type(type), pattern(pattern)
    {
        childCount += 2;
    }

    AssignmentPatternExpressionSyntax(const AssignmentPatternExpressionSyntax&) = delete;
    AssignmentPatternExpressionSyntax& operator=(const AssignmentPatternExpressionSyntax&) = delete;

    static const AssignmentPatternExpressionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return type;
            case 1: return &pattern;
            default: return nullptr;
        }
    }
};

// ----- SELECTORS -----

struct SelectorSyntax : public SyntaxNode {

    SelectorSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct BitSelectSyntax : public SelectorSyntax {
    ExpressionSyntax& expr;

    BitSelectSyntax(ExpressionSyntax& expr) :
        SelectorSyntax(SyntaxKind::BitSelect), expr(expr)
    {
        childCount += 1;
    }

    BitSelectSyntax(const BitSelectSyntax&) = delete;
    BitSelectSyntax& operator=(const BitSelectSyntax&) = delete;

    static const BitSelectSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &expr;
            default: return nullptr;
        }
    }
};

struct RangeSelectSyntax : public SelectorSyntax {
    ExpressionSyntax& left;
    Token range;
    ExpressionSyntax& right;

    RangeSelectSyntax(SyntaxKind kind, ExpressionSyntax& left, Token range, ExpressionSyntax& right) :
        SelectorSyntax(kind), left(left), range(range), right(right)
    {
        childCount += 3;
    }

    RangeSelectSyntax(const RangeSelectSyntax&) = delete;
    RangeSelectSyntax& operator=(const RangeSelectSyntax&) = delete;

    static const RangeSelectSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &left;
            case 1: return range;
            case 2: return &right;
            default: return nullptr;
        }
    }
};

struct ElementSelectSyntax : public ExpressionSyntax {
    Token openBracket;
    SelectorSyntax* selector;
    Token closeBracket;

    ElementSelectSyntax(Token openBracket, SelectorSyntax* selector, Token closeBracket) :
        ExpressionSyntax(SyntaxKind::ElementSelect), openBracket(openBracket), selector(selector), closeBracket(closeBracket)
    {
        childCount += 3;
    }

    ElementSelectSyntax(const ElementSelectSyntax&) = delete;
    ElementSelectSyntax& operator=(const ElementSelectSyntax&) = delete;

    static const ElementSelectSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openBracket;
            case 1: return selector;
            case 2: return closeBracket;
            default: return nullptr;
        }
    }
};

// ----- NAMES -----

struct NameSyntax : public ExpressionSyntax {

    NameSyntax(SyntaxKind kind) :
        ExpressionSyntax(kind)
    {
    }
};

struct IdentifierNameSyntax : public NameSyntax {
    Token identifier;

    IdentifierNameSyntax(Token identifier) :
        NameSyntax(SyntaxKind::IdentifierName), identifier(identifier)
    {
        childCount += 1;
    }

    IdentifierNameSyntax(const IdentifierNameSyntax&) = delete;
    IdentifierNameSyntax& operator=(const IdentifierNameSyntax&) = delete;

    static const IdentifierNameSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return identifier;
            default: return nullptr;
        }
    }
};

struct IdentifierSelectNameSyntax : public NameSyntax {
    Token identifier;
    SyntaxList<ElementSelectSyntax> selectors;

    IdentifierSelectNameSyntax(Token identifier, SyntaxList<ElementSelectSyntax> selectors) :
        NameSyntax(SyntaxKind::IdentifierSelectName), identifier(identifier), selectors(selectors)
    {
        childCount += 2;
    }

    IdentifierSelectNameSyntax(const IdentifierSelectNameSyntax&) = delete;
    IdentifierSelectNameSyntax& operator=(const IdentifierSelectNameSyntax&) = delete;

    static const IdentifierSelectNameSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return identifier;
            case 1: return &selectors;
            default: return nullptr;
        }
    }
};

struct EmptyIdentifierNameSyntax : public NameSyntax {

    EmptyIdentifierNameSyntax() :
        NameSyntax(SyntaxKind::EmptyIdentifierName)
    {
        childCount += 0;
    }

    EmptyIdentifierNameSyntax(const EmptyIdentifierNameSyntax&) = delete;
    EmptyIdentifierNameSyntax& operator=(const EmptyIdentifierNameSyntax&) = delete;

    static const EmptyIdentifierNameSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        (void)index;
        return nullptr;
    }
};

struct KeywordNameSyntax : public NameSyntax {
    Token keyword;

    KeywordNameSyntax(SyntaxKind kind, Token keyword) :
        NameSyntax(kind), keyword(keyword)
    {
        childCount += 1;
    }

    KeywordNameSyntax(const KeywordNameSyntax&) = delete;
    KeywordNameSyntax& operator=(const KeywordNameSyntax&) = delete;

    static const KeywordNameSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return keyword;
            default: return nullptr;
        }
    }
};

struct ClassNameSyntax : public NameSyntax {
    Token identifier;
    ParameterValueAssignmentSyntax& parameters;

    ClassNameSyntax(Token identifier, ParameterValueAssignmentSyntax& parameters) :
        NameSyntax(SyntaxKind::ClassName), identifier(identifier), parameters(parameters)
    {
        childCount += 2;
    }

    ClassNameSyntax(const ClassNameSyntax&) = delete;
    ClassNameSyntax& operator=(const ClassNameSyntax&) = delete;

    static const ClassNameSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return identifier;
            case 1: return &parameters;
            default: return nullptr;
        }
    }
};

struct ScopedNameSyntax : public NameSyntax {
    NameSyntax& left;
    Token separator;
    NameSyntax& right;

    ScopedNameSyntax(NameSyntax& left, Token separator, NameSyntax& right) :
        NameSyntax(SyntaxKind::ScopedName), left(left), separator(separator), right(right)
    {
        childCount += 3;
    }

    ScopedNameSyntax(const ScopedNameSyntax&) = delete;
    ScopedNameSyntax& operator=(const ScopedNameSyntax&) = delete;

    static const ScopedNameSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &left;
            case 1: return separator;
            case 2: return &right;
            default: return nullptr;
        }
    }
};

struct ClassScopeSyntax : public NameSyntax {
    NameSyntax& left;
    Token separator;

    ClassScopeSyntax(NameSyntax& left, Token separator) :
        NameSyntax(SyntaxKind::ClassScope), left(left), separator(separator)
    {
        childCount += 2;
    }

    ClassScopeSyntax(const ClassScopeSyntax&) = delete;
    ClassScopeSyntax& operator=(const ClassScopeSyntax&) = delete;

    static const ClassScopeSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &left;
            case 1: return separator;
            default: return nullptr;
        }
    }
};

// ----- PRIMARY EXPRESSIONS -----

struct LiteralExpressionSyntax : public PrimaryExpressionSyntax {
    Token literal;

    LiteralExpressionSyntax(SyntaxKind kind, Token literal) :
        PrimaryExpressionSyntax(kind), literal(literal)
    {
        childCount += 1;
    }

    LiteralExpressionSyntax(const LiteralExpressionSyntax&) = delete;
    LiteralExpressionSyntax& operator=(const LiteralExpressionSyntax&) = delete;

    static const LiteralExpressionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return literal;
            default: return nullptr;
        }
    }
};

struct IntegerVectorExpressionSyntax : public PrimaryExpressionSyntax {
    Token size;
    Token base;
    Token value;

    IntegerVectorExpressionSyntax(Token size, Token base, Token value) :
        PrimaryExpressionSyntax(SyntaxKind::IntegerVectorExpression), size(size), base(base), value(value)
    {
        childCount += 3;
    }

    IntegerVectorExpressionSyntax(const IntegerVectorExpressionSyntax&) = delete;
    IntegerVectorExpressionSyntax& operator=(const IntegerVectorExpressionSyntax&) = delete;

    static const IntegerVectorExpressionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return size;
            case 1: return base;
            case 2: return value;
            default: return nullptr;
        }
    }
};

struct EmptyQueueExpressionSyntax : public PrimaryExpressionSyntax {
    Token openBrace;
    Token closeBrace;

    EmptyQueueExpressionSyntax(Token openBrace, Token closeBrace) :
        PrimaryExpressionSyntax(SyntaxKind::EmptyQueueExpression), openBrace(openBrace), closeBrace(closeBrace)
    {
        childCount += 2;
    }

    EmptyQueueExpressionSyntax(const EmptyQueueExpressionSyntax&) = delete;
    EmptyQueueExpressionSyntax& operator=(const EmptyQueueExpressionSyntax&) = delete;

    static const EmptyQueueExpressionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return closeBrace;
            default: return nullptr;
        }
    }
};

struct ConcatenationExpressionSyntax : public PrimaryExpressionSyntax {
    Token openBrace;
    SeparatedSyntaxList<ExpressionSyntax> expressions;
    Token closeBrace;

    ConcatenationExpressionSyntax(Token openBrace, SeparatedSyntaxList<ExpressionSyntax> expressions, Token closeBrace) :
        PrimaryExpressionSyntax(SyntaxKind::ConcatenationExpression), openBrace(openBrace), expressions(expressions), closeBrace(closeBrace)
    {
        childCount += 3;
    }

    ConcatenationExpressionSyntax(const ConcatenationExpressionSyntax&) = delete;
    ConcatenationExpressionSyntax& operator=(const ConcatenationExpressionSyntax&) = delete;

    static const ConcatenationExpressionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return &expressions;
            case 2: return closeBrace;
            default: return nullptr;
        }
    }
};

struct MultipleConcatenationExpressionSyntax : public PrimaryExpressionSyntax {
    Token openBrace;
    ExpressionSyntax& expression;
    ConcatenationExpressionSyntax& concatenation;
    Token closeBrace;

    MultipleConcatenationExpressionSyntax(Token openBrace, ExpressionSyntax& expression, ConcatenationExpressionSyntax& concatenation, Token closeBrace) :
        PrimaryExpressionSyntax(SyntaxKind::MultipleConcatenationExpression), openBrace(openBrace), expression(expression), concatenation(concatenation), closeBrace(closeBrace)
    {
        childCount += 4;
    }

    MultipleConcatenationExpressionSyntax(const MultipleConcatenationExpressionSyntax&) = delete;
    MultipleConcatenationExpressionSyntax& operator=(const MultipleConcatenationExpressionSyntax&) = delete;

    static const MultipleConcatenationExpressionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return &expression;
            case 2: return &concatenation;
            case 3: return closeBrace;
            default: return nullptr;
        }
    }
};

struct StreamExpressionWithRange : public SyntaxNode {
    Token withKeyword;
    ElementSelectSyntax& range;

    StreamExpressionWithRange(Token withKeyword, ElementSelectSyntax& range) :
        SyntaxNode(SyntaxKind::StreamExpressionWithRange), withKeyword(withKeyword), range(range)
    {
        childCount += 2;
    }

    StreamExpressionWithRange(const StreamExpressionWithRange&) = delete;
    StreamExpressionWithRange& operator=(const StreamExpressionWithRange&) = delete;

    static const StreamExpressionWithRange Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return withKeyword;
            case 1: return &range;
            default: return nullptr;
        }
    }
};

struct StreamExpressionSyntax : public SyntaxNode {
    ExpressionSyntax& expression;
    StreamExpressionWithRange* withRange;

    StreamExpressionSyntax(ExpressionSyntax& expression, StreamExpressionWithRange* withRange) :
        SyntaxNode(SyntaxKind::StreamExpression), expression(expression), withRange(withRange)
    {
        childCount += 2;
    }

    StreamExpressionSyntax(const StreamExpressionSyntax&) = delete;
    StreamExpressionSyntax& operator=(const StreamExpressionSyntax&) = delete;

    static const StreamExpressionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &expression;
            case 1: return withRange;
            default: return nullptr;
        }
    }
};

struct StreamingConcatenationExpressionSyntax : public PrimaryExpressionSyntax {
    Token openBrace;
    Token operatorToken;
    ExpressionSyntax* sliceSize;
    Token innerOpenBrace;
    SeparatedSyntaxList<StreamExpressionSyntax> expressions;
    Token innerCloseBrace;
    Token closeBrace;

    StreamingConcatenationExpressionSyntax(Token openBrace, Token operatorToken, ExpressionSyntax* sliceSize, Token innerOpenBrace, SeparatedSyntaxList<StreamExpressionSyntax> expressions, Token innerCloseBrace, Token closeBrace) :
        PrimaryExpressionSyntax(SyntaxKind::StreamingConcatenationExpression), openBrace(openBrace), operatorToken(operatorToken), sliceSize(sliceSize), innerOpenBrace(innerOpenBrace), expressions(expressions), innerCloseBrace(innerCloseBrace), closeBrace(closeBrace)
    {
        childCount += 7;
    }

    StreamingConcatenationExpressionSyntax(const StreamingConcatenationExpressionSyntax&) = delete;
    StreamingConcatenationExpressionSyntax& operator=(const StreamingConcatenationExpressionSyntax&) = delete;

    static const StreamingConcatenationExpressionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return operatorToken;
            case 2: return sliceSize;
            case 3: return innerOpenBrace;
            case 4: return &expressions;
            case 5: return innerCloseBrace;
            case 6: return closeBrace;
            default: return nullptr;
        }
    }
};

struct ParenthesizedExpressionSyntax : public PrimaryExpressionSyntax {
    Token openParen;
    ExpressionSyntax& expression;
    Token closeParen;

    ParenthesizedExpressionSyntax(Token openParen, ExpressionSyntax& expression, Token closeParen) :
        PrimaryExpressionSyntax(SyntaxKind::ParenthesizedExpression), openParen(openParen), expression(expression), closeParen(closeParen)
    {
        childCount += 3;
    }

    ParenthesizedExpressionSyntax(const ParenthesizedExpressionSyntax&) = delete;
    ParenthesizedExpressionSyntax& operator=(const ParenthesizedExpressionSyntax&) = delete;

    static const ParenthesizedExpressionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &expression;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct NewClassExpressionSyntax : public ExpressionSyntax {
    ClassScopeSyntax& classScope;
    Token newKeyword;
    ArgumentListSyntax* arguments;

    NewClassExpressionSyntax(ClassScopeSyntax& classScope, Token newKeyword, ArgumentListSyntax* arguments) :
        ExpressionSyntax(SyntaxKind::NewClassExpression), classScope(classScope), newKeyword(newKeyword), arguments(arguments)
    {
        childCount += 3;
    }

    NewClassExpressionSyntax(const NewClassExpressionSyntax&) = delete;
    NewClassExpressionSyntax& operator=(const NewClassExpressionSyntax&) = delete;

    static const NewClassExpressionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &classScope;
            case 1: return newKeyword;
            case 2: return arguments;
            default: return nullptr;
        }
    }
};

struct NewArrayExpressionSyntax : public ExpressionSyntax {
    Token newKeyword;
    Token openBracket;
    ExpressionSyntax& sizeExpr;
    Token closeBracket;
    ParenthesizedExpressionSyntax* initializer;

    NewArrayExpressionSyntax(Token newKeyword, Token openBracket, ExpressionSyntax& sizeExpr, Token closeBracket, ParenthesizedExpressionSyntax* initializer) :
        ExpressionSyntax(SyntaxKind::NewArrayExpression), newKeyword(newKeyword), openBracket(openBracket), sizeExpr(sizeExpr), closeBracket(closeBracket), initializer(initializer)
    {
        childCount += 5;
    }

    NewArrayExpressionSyntax(const NewArrayExpressionSyntax&) = delete;
    NewArrayExpressionSyntax& operator=(const NewArrayExpressionSyntax&) = delete;

    static const NewArrayExpressionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return newKeyword;
            case 1: return openBracket;
            case 2: return &sizeExpr;
            case 3: return closeBracket;
            case 4: return initializer;
            default: return nullptr;
        }
    }
};

struct NewExpressionSyntax : public ExpressionSyntax {
    Token newKeyword;
    ExpressionSyntax& expr;

    NewExpressionSyntax(Token newKeyword, ExpressionSyntax& expr) :
        ExpressionSyntax(SyntaxKind::NewExpression), newKeyword(newKeyword), expr(expr)
    {
        childCount += 2;
    }

    NewExpressionSyntax(const NewExpressionSyntax&) = delete;
    NewExpressionSyntax& operator=(const NewExpressionSyntax&) = delete;

    static const NewExpressionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return newKeyword;
            case 1: return &expr;
            default: return nullptr;
        }
    }
};

// ----- POSTFIX EXPRESSIONS -----

struct ElementSelectExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax& left;
    ElementSelectSyntax& select;

    ElementSelectExpressionSyntax(ExpressionSyntax& left, ElementSelectSyntax& select) :
        ExpressionSyntax(SyntaxKind::ElementSelectExpression), left(left), select(select)
    {
        childCount += 2;
    }

    ElementSelectExpressionSyntax(const ElementSelectExpressionSyntax&) = delete;
    ElementSelectExpressionSyntax& operator=(const ElementSelectExpressionSyntax&) = delete;

    static const ElementSelectExpressionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &left;
            case 1: return &select;
            default: return nullptr;
        }
    }
};

struct MemberAccessExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax& left;
    Token dot;
    Token name;

    MemberAccessExpressionSyntax(ExpressionSyntax& left, Token dot, Token name) :
        ExpressionSyntax(SyntaxKind::MemberAccessExpression), left(left), dot(dot), name(name)
    {
        childCount += 3;
    }

    MemberAccessExpressionSyntax(const MemberAccessExpressionSyntax&) = delete;
    MemberAccessExpressionSyntax& operator=(const MemberAccessExpressionSyntax&) = delete;

    static const MemberAccessExpressionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &left;
            case 1: return dot;
            case 2: return name;
            default: return nullptr;
        }
    }
};

struct InvocationExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax& left;
    SyntaxList<AttributeInstanceSyntax> attributes;
    ArgumentListSyntax* arguments;

    InvocationExpressionSyntax(ExpressionSyntax& left, SyntaxList<AttributeInstanceSyntax> attributes, ArgumentListSyntax* arguments) :
        ExpressionSyntax(SyntaxKind::InvocationExpression), left(left), attributes(attributes), arguments(arguments)
    {
        childCount += 3;
    }

    InvocationExpressionSyntax(const InvocationExpressionSyntax&) = delete;
    InvocationExpressionSyntax& operator=(const InvocationExpressionSyntax&) = delete;

    static const InvocationExpressionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &left;
            case 1: return &attributes;
            case 2: return arguments;
            default: return nullptr;
        }
    }
};

struct CastExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax& left;
    Token apostrophe;
    ParenthesizedExpressionSyntax& right;

    CastExpressionSyntax(ExpressionSyntax& left, Token apostrophe, ParenthesizedExpressionSyntax& right) :
        ExpressionSyntax(SyntaxKind::CastExpression), left(left), apostrophe(apostrophe), right(right)
    {
        childCount += 3;
    }

    CastExpressionSyntax(const CastExpressionSyntax&) = delete;
    CastExpressionSyntax& operator=(const CastExpressionSyntax&) = delete;

    static const CastExpressionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &left;
            case 1: return apostrophe;
            case 2: return &right;
            default: return nullptr;
        }
    }
};

struct SignedCastExpressionSyntax : public ExpressionSyntax {
    Token signing;
    Token apostrophe;
    ParenthesizedExpressionSyntax& inner;

    SignedCastExpressionSyntax(Token signing, Token apostrophe, ParenthesizedExpressionSyntax& inner) :
        ExpressionSyntax(SyntaxKind::SignedCastExpression), signing(signing), apostrophe(apostrophe), inner(inner)
    {
        childCount += 3;
    }

    SignedCastExpressionSyntax(const SignedCastExpressionSyntax&) = delete;
    SignedCastExpressionSyntax& operator=(const SignedCastExpressionSyntax&) = delete;

    static const SignedCastExpressionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return signing;
            case 1: return apostrophe;
            case 2: return &inner;
            default: return nullptr;
        }
    }
};

// ----- TIMING CONTROL -----

struct TimingControlSyntax : public SyntaxNode {

    TimingControlSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct DelaySyntax : public TimingControlSyntax {
    Token hash;
    ExpressionSyntax& delayValue;

    DelaySyntax(SyntaxKind kind, Token hash, ExpressionSyntax& delayValue) :
        TimingControlSyntax(kind), hash(hash), delayValue(delayValue)
    {
        childCount += 2;
    }

    DelaySyntax(const DelaySyntax&) = delete;
    DelaySyntax& operator=(const DelaySyntax&) = delete;

    static const DelaySyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return hash;
            case 1: return &delayValue;
            default: return nullptr;
        }
    }
};

struct EventControlSyntax : public TimingControlSyntax {
    Token at;
    NameSyntax& eventName;

    EventControlSyntax(Token at, NameSyntax& eventName) :
        TimingControlSyntax(SyntaxKind::EventControl), at(at), eventName(eventName)
    {
        childCount += 2;
    }

    EventControlSyntax(const EventControlSyntax&) = delete;
    EventControlSyntax& operator=(const EventControlSyntax&) = delete;

    static const EventControlSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return at;
            case 1: return &eventName;
            default: return nullptr;
        }
    }
};

struct EventExpressionSyntax : public SyntaxNode {

    EventExpressionSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct SignalEventExpressionSyntax : public EventExpressionSyntax {
    Token edge;
    ExpressionSyntax& expr;

    SignalEventExpressionSyntax(Token edge, ExpressionSyntax& expr) :
        EventExpressionSyntax(SyntaxKind::SignalEventExpression), edge(edge), expr(expr)
    {
        childCount += 2;
    }

    SignalEventExpressionSyntax(const SignalEventExpressionSyntax&) = delete;
    SignalEventExpressionSyntax& operator=(const SignalEventExpressionSyntax&) = delete;

    static const SignalEventExpressionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return edge;
            case 1: return &expr;
            default: return nullptr;
        }
    }
};

struct BinaryEventExpressionSyntax : public EventExpressionSyntax {
    EventExpressionSyntax& left;
    Token operatorToken;
    EventExpressionSyntax& right;

    BinaryEventExpressionSyntax(EventExpressionSyntax& left, Token operatorToken, EventExpressionSyntax& right) :
        EventExpressionSyntax(SyntaxKind::BinaryEventExpression), left(left), operatorToken(operatorToken), right(right)
    {
        childCount += 3;
    }

    BinaryEventExpressionSyntax(const BinaryEventExpressionSyntax&) = delete;
    BinaryEventExpressionSyntax& operator=(const BinaryEventExpressionSyntax&) = delete;

    static const BinaryEventExpressionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &left;
            case 1: return operatorToken;
            case 2: return &right;
            default: return nullptr;
        }
    }
};

struct ParenthesizedEventExpressionSyntax : public EventExpressionSyntax {
    Token openParen;
    EventExpressionSyntax& expr;
    Token closeParen;

    ParenthesizedEventExpressionSyntax(Token openParen, EventExpressionSyntax& expr, Token closeParen) :
        EventExpressionSyntax(SyntaxKind::ParenthesizedEventExpression), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 3;
    }

    ParenthesizedEventExpressionSyntax(const ParenthesizedEventExpressionSyntax&) = delete;
    ParenthesizedEventExpressionSyntax& operator=(const ParenthesizedEventExpressionSyntax&) = delete;

    static const ParenthesizedEventExpressionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &expr;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct ImplicitEventControlSyntax : public TimingControlSyntax {
    Token atStar;

    ImplicitEventControlSyntax(Token atStar) :
        TimingControlSyntax(SyntaxKind::ImplicitEventControl), atStar(atStar)
    {
        childCount += 1;
    }

    ImplicitEventControlSyntax(const ImplicitEventControlSyntax&) = delete;
    ImplicitEventControlSyntax& operator=(const ImplicitEventControlSyntax&) = delete;

    static const ImplicitEventControlSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return atStar;
            default: return nullptr;
        }
    }
};

struct ParenImplicitEventControlSyntax : public TimingControlSyntax {
    Token at;
    Token openParenStarCloseParen;

    ParenImplicitEventControlSyntax(Token at, Token openParenStarCloseParen) :
        TimingControlSyntax(SyntaxKind::ParenImplicitEventControl), at(at), openParenStarCloseParen(openParenStarCloseParen)
    {
        childCount += 2;
    }

    ParenImplicitEventControlSyntax(const ParenImplicitEventControlSyntax&) = delete;
    ParenImplicitEventControlSyntax& operator=(const ParenImplicitEventControlSyntax&) = delete;

    static const ParenImplicitEventControlSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return at;
            case 1: return openParenStarCloseParen;
            default: return nullptr;
        }
    }
};

struct EventControlWithExpressionSyntax : public TimingControlSyntax {
    Token at;
    EventExpressionSyntax& expr;

    EventControlWithExpressionSyntax(Token at, EventExpressionSyntax& expr) :
        TimingControlSyntax(SyntaxKind::EventControlWithExpression), at(at), expr(expr)
    {
        childCount += 2;
    }

    EventControlWithExpressionSyntax(const EventControlWithExpressionSyntax&) = delete;
    EventControlWithExpressionSyntax& operator=(const EventControlWithExpressionSyntax&) = delete;

    static const EventControlWithExpressionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return at;
            case 1: return &expr;
            default: return nullptr;
        }
    }
};

struct RepeatedEventControlSyntax : public TimingControlSyntax {
    Token repeat;
    Token openParen;
    ExpressionSyntax& expr;
    Token closeParen;
    TimingControlSyntax* eventControl;

    RepeatedEventControlSyntax(Token repeat, Token openParen, ExpressionSyntax& expr, Token closeParen, TimingControlSyntax* eventControl) :
        TimingControlSyntax(SyntaxKind::RepeatedEventControl), repeat(repeat), openParen(openParen), expr(expr), closeParen(closeParen), eventControl(eventControl)
    {
        childCount += 5;
    }

    RepeatedEventControlSyntax(const RepeatedEventControlSyntax&) = delete;
    RepeatedEventControlSyntax& operator=(const RepeatedEventControlSyntax&) = delete;

    static const RepeatedEventControlSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return repeat;
            case 1: return openParen;
            case 2: return &expr;
            case 3: return closeParen;
            case 4: return eventControl;
            default: return nullptr;
        }
    }
};

struct TimingControlExpressionSyntax : public ExpressionSyntax {
    TimingControlSyntax& timing;
    ExpressionSyntax& expr;

    TimingControlExpressionSyntax(TimingControlSyntax& timing, ExpressionSyntax& expr) :
        ExpressionSyntax(SyntaxKind::TimingControlExpression), timing(timing), expr(expr)
    {
        childCount += 2;
    }

    TimingControlExpressionSyntax(const TimingControlExpressionSyntax&) = delete;
    TimingControlExpressionSyntax& operator=(const TimingControlExpressionSyntax&) = delete;

    static const TimingControlExpressionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &timing;
            case 1: return &expr;
            default: return nullptr;
        }
    }
};

struct TimingControlExpressionConcatenationSyntax : public ExpressionSyntax {
    ExpressionSyntax& left;
    TimingControlSyntax& timing;
    ExpressionSyntax& right;

    TimingControlExpressionConcatenationSyntax(ExpressionSyntax& left, TimingControlSyntax& timing, ExpressionSyntax& right) :
        ExpressionSyntax(SyntaxKind::TimingControlExpressionConcatenation), left(left), timing(timing), right(right)
    {
        childCount += 3;
    }

    TimingControlExpressionConcatenationSyntax(const TimingControlExpressionConcatenationSyntax&) = delete;
    TimingControlExpressionConcatenationSyntax& operator=(const TimingControlExpressionConcatenationSyntax&) = delete;

    static const TimingControlExpressionConcatenationSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &left;
            case 1: return &timing;
            case 2: return &right;
            default: return nullptr;
        }
    }
};

struct ShortcutCycleDelayRangeSyntax : public TimingControlSyntax {
    Token doubleHash;
    Token openBracket;
    Token op;
    Token closeBracket;

    ShortcutCycleDelayRangeSyntax(Token doubleHash, Token openBracket, Token op, Token closeBracket) :
        TimingControlSyntax(SyntaxKind::ShortcutCycleDelayRange), doubleHash(doubleHash), openBracket(openBracket), op(op), closeBracket(closeBracket)
    {
        childCount += 4;
    }

    ShortcutCycleDelayRangeSyntax(const ShortcutCycleDelayRangeSyntax&) = delete;
    ShortcutCycleDelayRangeSyntax& operator=(const ShortcutCycleDelayRangeSyntax&) = delete;

    static const ShortcutCycleDelayRangeSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return doubleHash;
            case 1: return openBracket;
            case 2: return op;
            case 3: return closeBracket;
            default: return nullptr;
        }
    }
};

// ----- DECLARATIONS -----

struct DimensionSpecifierSyntax : public SyntaxNode {

    DimensionSpecifierSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct RangeDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
    SelectorSyntax& selector;

    RangeDimensionSpecifierSyntax(SelectorSyntax& selector) :
        DimensionSpecifierSyntax(SyntaxKind::RangeDimensionSpecifier), selector(selector)
    {
        childCount += 1;
    }

    RangeDimensionSpecifierSyntax(const RangeDimensionSpecifierSyntax&) = delete;
    RangeDimensionSpecifierSyntax& operator=(const RangeDimensionSpecifierSyntax&) = delete;

    static const RangeDimensionSpecifierSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &selector;
            default: return nullptr;
        }
    }
};

struct DataTypeDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
    DataTypeSyntax& type;

    DataTypeDimensionSpecifierSyntax(DataTypeSyntax& type) :
        DimensionSpecifierSyntax(SyntaxKind::DataTypeDimensionSpecifier), type(type)
    {
        childCount += 1;
    }

    DataTypeDimensionSpecifierSyntax(const DataTypeDimensionSpecifierSyntax&) = delete;
    DataTypeDimensionSpecifierSyntax& operator=(const DataTypeDimensionSpecifierSyntax&) = delete;

    static const DataTypeDimensionSpecifierSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &type;
            default: return nullptr;
        }
    }
};

struct WildcardDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
    Token star;

    WildcardDimensionSpecifierSyntax(Token star) :
        DimensionSpecifierSyntax(SyntaxKind::WildcardDimensionSpecifier), star(star)
    {
        childCount += 1;
    }

    WildcardDimensionSpecifierSyntax(const WildcardDimensionSpecifierSyntax&) = delete;
    WildcardDimensionSpecifierSyntax& operator=(const WildcardDimensionSpecifierSyntax&) = delete;

    static const WildcardDimensionSpecifierSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return star;
            default: return nullptr;
        }
    }
};

struct ColonExpressionClauseSyntax : public SyntaxNode {
    Token colon;
    ExpressionSyntax& expr;

    ColonExpressionClauseSyntax(Token colon, ExpressionSyntax& expr) :
        SyntaxNode(SyntaxKind::ColonExpressionClause), colon(colon), expr(expr)
    {
        childCount += 2;
    }

    ColonExpressionClauseSyntax(const ColonExpressionClauseSyntax&) = delete;
    ColonExpressionClauseSyntax& operator=(const ColonExpressionClauseSyntax&) = delete;

    static const ColonExpressionClauseSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return colon;
            case 1: return &expr;
            default: return nullptr;
        }
    }
};

struct QueueDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
    Token dollar;
    ColonExpressionClauseSyntax* maxSizeClause;

    QueueDimensionSpecifierSyntax(Token dollar, ColonExpressionClauseSyntax* maxSizeClause) :
        DimensionSpecifierSyntax(SyntaxKind::QueueDimensionSpecifier), dollar(dollar), maxSizeClause(maxSizeClause)
    {
        childCount += 2;
    }

    QueueDimensionSpecifierSyntax(const QueueDimensionSpecifierSyntax&) = delete;
    QueueDimensionSpecifierSyntax& operator=(const QueueDimensionSpecifierSyntax&) = delete;

    static const QueueDimensionSpecifierSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return dollar;
            case 1: return maxSizeClause;
            default: return nullptr;
        }
    }
};

struct VariableDimensionSyntax : public SyntaxNode {
    Token openBracket;
    DimensionSpecifierSyntax* specifier;
    Token closeBracket;

    VariableDimensionSyntax(Token openBracket, DimensionSpecifierSyntax* specifier, Token closeBracket) :
        SyntaxNode(SyntaxKind::VariableDimension), openBracket(openBracket), specifier(specifier), closeBracket(closeBracket)
    {
        childCount += 3;
    }

    VariableDimensionSyntax(const VariableDimensionSyntax&) = delete;
    VariableDimensionSyntax& operator=(const VariableDimensionSyntax&) = delete;

    static const VariableDimensionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openBracket;
            case 1: return specifier;
            case 2: return closeBracket;
            default: return nullptr;
        }
    }
};

struct VariableDeclaratorSyntax : public SyntaxNode {
    Token name;
    SyntaxList<VariableDimensionSyntax> dimensions;
    EqualsValueClauseSyntax* initializer;

    VariableDeclaratorSyntax(Token name, SyntaxList<VariableDimensionSyntax> dimensions, EqualsValueClauseSyntax* initializer) :
        SyntaxNode(SyntaxKind::VariableDeclarator), name(name), dimensions(dimensions), initializer(initializer)
    {
        childCount += 3;
    }

    VariableDeclaratorSyntax(const VariableDeclaratorSyntax&) = delete;
    VariableDeclaratorSyntax& operator=(const VariableDeclaratorSyntax&) = delete;

    static const VariableDeclaratorSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return name;
            case 1: return &dimensions;
            case 2: return initializer;
            default: return nullptr;
        }
    }
};

struct DataDeclarationSyntax : public MemberSyntax {
    TokenList modifiers;
    DataTypeSyntax& type;
    SeparatedSyntaxList<VariableDeclaratorSyntax> declarators;
    Token semi;

    DataDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList modifiers, DataTypeSyntax& type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token semi) :
        MemberSyntax(SyntaxKind::DataDeclaration, attributes), modifiers(modifiers), type(type), declarators(declarators), semi(semi)
    {
        childCount += 4;
    }

    DataDeclarationSyntax(const DataDeclarationSyntax&) = delete;
    DataDeclarationSyntax& operator=(const DataDeclarationSyntax&) = delete;

    static const DataDeclarationSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &modifiers;
            case 2: return &type;
            case 3: return &declarators;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct TypedefDeclarationSyntax : public MemberSyntax {
    Token typedefKeyword;
    DataTypeSyntax& type;
    Token name;
    SyntaxList<VariableDimensionSyntax> dimensions;
    Token semi;

    TypedefDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token typedefKeyword, DataTypeSyntax& type, Token name, SyntaxList<VariableDimensionSyntax> dimensions, Token semi) :
        MemberSyntax(SyntaxKind::TypedefDeclaration, attributes), typedefKeyword(typedefKeyword), type(type), name(name), dimensions(dimensions), semi(semi)
    {
        childCount += 5;
    }

    TypedefDeclarationSyntax(const TypedefDeclarationSyntax&) = delete;
    TypedefDeclarationSyntax& operator=(const TypedefDeclarationSyntax&) = delete;

    static const TypedefDeclarationSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return typedefKeyword;
            case 2: return &type;
            case 3: return name;
            case 4: return &dimensions;
            case 5: return semi;
            default: return nullptr;
        }
    }
};

struct TypedefKeywordDeclarationSyntax : public MemberSyntax {
    Token typedefKeyword;
    Token keyword;
    Token name;
    Token semi;

    TypedefKeywordDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token typedefKeyword, Token keyword, Token name, Token semi) :
        MemberSyntax(SyntaxKind::TypedefKeywordDeclaration, attributes), typedefKeyword(typedefKeyword), keyword(keyword), name(name), semi(semi)
    {
        childCount += 4;
    }

    TypedefKeywordDeclarationSyntax(const TypedefKeywordDeclarationSyntax&) = delete;
    TypedefKeywordDeclarationSyntax& operator=(const TypedefKeywordDeclarationSyntax&) = delete;

    static const TypedefKeywordDeclarationSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return typedefKeyword;
            case 2: return keyword;
            case 3: return name;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct TypedefInterfaceClassDeclarationSyntax : public MemberSyntax {
    Token typedefKeyword;
    Token interfaceKeyword;
    Token classKeyword;
    Token name;
    Token semi;

    TypedefInterfaceClassDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token typedefKeyword, Token interfaceKeyword, Token classKeyword, Token name, Token semi) :
        MemberSyntax(SyntaxKind::TypedefInterfaceClassDeclaration, attributes), typedefKeyword(typedefKeyword), interfaceKeyword(interfaceKeyword), classKeyword(classKeyword), name(name), semi(semi)
    {
        childCount += 5;
    }

    TypedefInterfaceClassDeclarationSyntax(const TypedefInterfaceClassDeclarationSyntax&) = delete;
    TypedefInterfaceClassDeclarationSyntax& operator=(const TypedefInterfaceClassDeclarationSyntax&) = delete;

    static const TypedefInterfaceClassDeclarationSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return typedefKeyword;
            case 2: return interfaceKeyword;
            case 3: return classKeyword;
            case 4: return name;
            case 5: return semi;
            default: return nullptr;
        }
    }
};

struct NetStrengthSyntax : public SyntaxNode {

    NetStrengthSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct ChargeStrengthSyntax : public NetStrengthSyntax {
    Token openParen;
    Token strength;
    Token closeParen;

    ChargeStrengthSyntax(Token openParen, Token strength, Token closeParen) :
        NetStrengthSyntax(SyntaxKind::ChargeStrength), openParen(openParen), strength(strength), closeParen(closeParen)
    {
        childCount += 3;
    }

    ChargeStrengthSyntax(const ChargeStrengthSyntax&) = delete;
    ChargeStrengthSyntax& operator=(const ChargeStrengthSyntax&) = delete;

    static const ChargeStrengthSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openParen;
            case 1: return strength;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct DriveStrengthSyntax : public NetStrengthSyntax {
    Token openParen;
    Token strength0;
    Token comma;
    Token strength1;
    Token closeParen;

    DriveStrengthSyntax(Token openParen, Token strength0, Token comma, Token strength1, Token closeParen) :
        NetStrengthSyntax(SyntaxKind::DriveStrength), openParen(openParen), strength0(strength0), comma(comma), strength1(strength1), closeParen(closeParen)
    {
        childCount += 5;
    }

    DriveStrengthSyntax(const DriveStrengthSyntax&) = delete;
    DriveStrengthSyntax& operator=(const DriveStrengthSyntax&) = delete;

    static const DriveStrengthSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openParen;
            case 1: return strength0;
            case 2: return comma;
            case 3: return strength1;
            case 4: return closeParen;
            default: return nullptr;
        }
    }
};

struct NetDeclarationSyntax : public MemberSyntax {
    Token netType;
    NetStrengthSyntax* strength;
    Token expansionHint;
    DataTypeSyntax& type;
    SeparatedSyntaxList<VariableDeclaratorSyntax> declarators;
    Token semi;

    NetDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token netType, NetStrengthSyntax* strength, Token expansionHint, DataTypeSyntax& type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token semi) :
        MemberSyntax(SyntaxKind::NetDeclaration, attributes), netType(netType), strength(strength), expansionHint(expansionHint), type(type), declarators(declarators), semi(semi)
    {
        childCount += 6;
    }

    NetDeclarationSyntax(const NetDeclarationSyntax&) = delete;
    NetDeclarationSyntax& operator=(const NetDeclarationSyntax&) = delete;

    static const NetDeclarationSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return netType;
            case 2: return strength;
            case 3: return expansionHint;
            case 4: return &type;
            case 5: return &declarators;
            case 6: return semi;
            default: return nullptr;
        }
    }
};

struct PackageImportItemSyntax : public SyntaxNode {
    Token package;
    Token doubleColon;
    Token item;

    PackageImportItemSyntax(Token package, Token doubleColon, Token item) :
        SyntaxNode(SyntaxKind::PackageImportItem), package(package), doubleColon(doubleColon), item(item)
    {
        childCount += 3;
    }

    PackageImportItemSyntax(const PackageImportItemSyntax&) = delete;
    PackageImportItemSyntax& operator=(const PackageImportItemSyntax&) = delete;

    static const PackageImportItemSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return package;
            case 1: return doubleColon;
            case 2: return item;
            default: return nullptr;
        }
    }
};

struct PackageImportDeclarationSyntax : public MemberSyntax {
    Token keyword;
    SeparatedSyntaxList<PackageImportItemSyntax> items;
    Token semi;

    PackageImportDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, SeparatedSyntaxList<PackageImportItemSyntax> items, Token semi) :
        MemberSyntax(SyntaxKind::PackageImportDeclaration, attributes), keyword(keyword), items(items), semi(semi)
    {
        childCount += 3;
    }

    PackageImportDeclarationSyntax(const PackageImportDeclarationSyntax&) = delete;
    PackageImportDeclarationSyntax& operator=(const PackageImportDeclarationSyntax&) = delete;

    static const PackageImportDeclarationSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return &items;
            case 3: return semi;
            default: return nullptr;
        }
    }
};

struct ParameterDeclarationSyntax : public SyntaxNode {
    Token keyword;
    DataTypeSyntax& type;
    SeparatedSyntaxList<VariableDeclaratorSyntax> declarators;

    ParameterDeclarationSyntax(Token keyword, DataTypeSyntax& type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators) :
        SyntaxNode(SyntaxKind::ParameterDeclaration), keyword(keyword), type(type), declarators(declarators)
    {
        childCount += 3;
    }

    ParameterDeclarationSyntax(const ParameterDeclarationSyntax&) = delete;
    ParameterDeclarationSyntax& operator=(const ParameterDeclarationSyntax&) = delete;

    static const ParameterDeclarationSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return keyword;
            case 1: return &type;
            case 2: return &declarators;
            default: return nullptr;
        }
    }
};

struct ParameterDeclarationStatementSyntax : public MemberSyntax {
    ParameterDeclarationSyntax& parameter;
    Token semi;

    ParameterDeclarationStatementSyntax(SyntaxList<AttributeInstanceSyntax> attributes, ParameterDeclarationSyntax& parameter, Token semi) :
        MemberSyntax(SyntaxKind::ParameterDeclarationStatement, attributes), parameter(parameter), semi(semi)
    {
        childCount += 2;
    }

    ParameterDeclarationStatementSyntax(const ParameterDeclarationStatementSyntax&) = delete;
    ParameterDeclarationStatementSyntax& operator=(const ParameterDeclarationStatementSyntax&) = delete;

    static const ParameterDeclarationStatementSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &parameter;
            case 2: return semi;
            default: return nullptr;
        }
    }
};

struct PortHeaderSyntax : public SyntaxNode {

    PortHeaderSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct PortDeclarationSyntax : public MemberSyntax {
    PortHeaderSyntax& header;
    SeparatedSyntaxList<VariableDeclaratorSyntax> declarators;
    Token semi;

    PortDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, PortHeaderSyntax& header, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token semi) :
        MemberSyntax(SyntaxKind::PortDeclaration, attributes), header(header), declarators(declarators), semi(semi)
    {
        childCount += 3;
    }

    PortDeclarationSyntax(const PortDeclarationSyntax&) = delete;
    PortDeclarationSyntax& operator=(const PortDeclarationSyntax&) = delete;

    static const PortDeclarationSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &header;
            case 2: return &declarators;
            case 3: return semi;
            default: return nullptr;
        }
    }
};

struct GenvarDeclarationSyntax : public MemberSyntax {
    Token keyword;
    SeparatedSyntaxList<IdentifierNameSyntax> identifiers;
    Token semi;

    GenvarDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, SeparatedSyntaxList<IdentifierNameSyntax> identifiers, Token semi) :
        MemberSyntax(SyntaxKind::GenvarDeclaration, attributes), keyword(keyword), identifiers(identifiers), semi(semi)
    {
        childCount += 3;
    }

    GenvarDeclarationSyntax(const GenvarDeclarationSyntax&) = delete;
    GenvarDeclarationSyntax& operator=(const GenvarDeclarationSyntax&) = delete;

    static const GenvarDeclarationSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return &identifiers;
            case 3: return semi;
            default: return nullptr;
        }
    }
};

// ----- TYPES -----

struct IntegerTypeSyntax : public DataTypeSyntax {
    Token keyword;
    Token signing;
    SyntaxList<VariableDimensionSyntax> dimensions;

    IntegerTypeSyntax(SyntaxKind kind, Token keyword, Token signing, SyntaxList<VariableDimensionSyntax> dimensions) :
        DataTypeSyntax(kind), keyword(keyword), signing(signing), dimensions(dimensions)
    {
        childCount += 3;
    }

    IntegerTypeSyntax(const IntegerTypeSyntax&) = delete;
    IntegerTypeSyntax& operator=(const IntegerTypeSyntax&) = delete;

    static const IntegerTypeSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return keyword;
            case 1: return signing;
            case 2: return &dimensions;
            default: return nullptr;
        }
    }
};

struct KeywordTypeSyntax : public DataTypeSyntax {
    Token keyword;

    KeywordTypeSyntax(SyntaxKind kind, Token keyword) :
        DataTypeSyntax(kind), keyword(keyword)
    {
        childCount += 1;
    }

    KeywordTypeSyntax(const KeywordTypeSyntax&) = delete;
    KeywordTypeSyntax& operator=(const KeywordTypeSyntax&) = delete;

    static const KeywordTypeSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return keyword;
            default: return nullptr;
        }
    }
};

struct NamedTypeSyntax : public DataTypeSyntax {
    NameSyntax& name;

    NamedTypeSyntax(NameSyntax& name) :
        DataTypeSyntax(SyntaxKind::NamedType), name(name)
    {
        childCount += 1;
    }

    NamedTypeSyntax(const NamedTypeSyntax&) = delete;
    NamedTypeSyntax& operator=(const NamedTypeSyntax&) = delete;

    static const NamedTypeSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &name;
            default: return nullptr;
        }
    }
};

struct StructUnionMemberSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;
    Token randomQualifier;
    DataTypeSyntax& type;
    SeparatedSyntaxList<VariableDeclaratorSyntax> declarators;
    Token semi;

    StructUnionMemberSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token randomQualifier, DataTypeSyntax& type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token semi) :
        SyntaxNode(SyntaxKind::StructUnionMember), attributes(attributes), randomQualifier(randomQualifier), type(type), declarators(declarators), semi(semi)
    {
        childCount += 5;
    }

    StructUnionMemberSyntax(const StructUnionMemberSyntax&) = delete;
    StructUnionMemberSyntax& operator=(const StructUnionMemberSyntax&) = delete;

    static const StructUnionMemberSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return randomQualifier;
            case 2: return &type;
            case 3: return &declarators;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct StructUnionTypeSyntax : public DataTypeSyntax {
    Token keyword;
    Token tagged;
    Token packed;
    Token signing;
    Token openBrace;
    SyntaxList<StructUnionMemberSyntax> members;
    Token closeBrace;
    SyntaxList<VariableDimensionSyntax> dimensions;

    StructUnionTypeSyntax(SyntaxKind kind, Token keyword, Token tagged, Token packed, Token signing, Token openBrace, SyntaxList<StructUnionMemberSyntax> members, Token closeBrace, SyntaxList<VariableDimensionSyntax> dimensions) :
        DataTypeSyntax(kind), keyword(keyword), tagged(tagged), packed(packed), signing(signing), openBrace(openBrace), members(members), closeBrace(closeBrace), dimensions(dimensions)
    {
        childCount += 8;
    }

    StructUnionTypeSyntax(const StructUnionTypeSyntax&) = delete;
    StructUnionTypeSyntax& operator=(const StructUnionTypeSyntax&) = delete;

    static const StructUnionTypeSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return keyword;
            case 1: return tagged;
            case 2: return packed;
            case 3: return signing;
            case 4: return openBrace;
            case 5: return &members;
            case 6: return closeBrace;
            case 7: return &dimensions;
            default: return nullptr;
        }
    }
};

struct EnumTypeSyntax : public DataTypeSyntax {
    Token keyword;
    DataTypeSyntax* baseType;
    Token openBrace;
    SeparatedSyntaxList<VariableDeclaratorSyntax> members;
    Token closeBrace;
    SyntaxList<VariableDimensionSyntax> dimensions;

    EnumTypeSyntax(Token keyword, DataTypeSyntax* baseType, Token openBrace, SeparatedSyntaxList<VariableDeclaratorSyntax> members, Token closeBrace, SyntaxList<VariableDimensionSyntax> dimensions) :
        DataTypeSyntax(SyntaxKind::EnumType), keyword(keyword), baseType(baseType), openBrace(openBrace), members(members), closeBrace(closeBrace), dimensions(dimensions)
    {
        childCount += 6;
    }

    EnumTypeSyntax(const EnumTypeSyntax&) = delete;
    EnumTypeSyntax& operator=(const EnumTypeSyntax&) = delete;

    static const EnumTypeSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return keyword;
            case 1: return baseType;
            case 2: return openBrace;
            case 3: return &members;
            case 4: return closeBrace;
            case 5: return &dimensions;
            default: return nullptr;
        }
    }
};

struct TypeReferenceSyntax : public DataTypeSyntax {
    Token typeKeyword;
    Token openParen;
    ExpressionSyntax& expr;
    Token closeParen;

    TypeReferenceSyntax(Token typeKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen) :
        DataTypeSyntax(SyntaxKind::TypeReference), typeKeyword(typeKeyword), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 4;
    }

    TypeReferenceSyntax(const TypeReferenceSyntax&) = delete;
    TypeReferenceSyntax& operator=(const TypeReferenceSyntax&) = delete;

    static const TypeReferenceSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return typeKeyword;
            case 1: return openParen;
            case 2: return &expr;
            case 3: return closeParen;
            default: return nullptr;
        }
    }
};

struct DotMemberClauseSyntax : public SyntaxNode {
    Token dot;
    Token member;

    DotMemberClauseSyntax(Token dot, Token member) :
        SyntaxNode(SyntaxKind::DotMemberClause), dot(dot), member(member)
    {
        childCount += 2;
    }

    DotMemberClauseSyntax(const DotMemberClauseSyntax&) = delete;
    DotMemberClauseSyntax& operator=(const DotMemberClauseSyntax&) = delete;

    static const DotMemberClauseSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return dot;
            case 1: return member;
            default: return nullptr;
        }
    }
};

struct VirtualInterfaceTypeSyntax : public DataTypeSyntax {
    Token virtualKeyword;
    Token interfaceKeyword;
    Token name;
    ParameterValueAssignmentSyntax* parameters;
    DotMemberClauseSyntax* modport;

    VirtualInterfaceTypeSyntax(Token virtualKeyword, Token interfaceKeyword, Token name, ParameterValueAssignmentSyntax* parameters, DotMemberClauseSyntax* modport) :
        DataTypeSyntax(SyntaxKind::VirtualInterfaceType), virtualKeyword(virtualKeyword), interfaceKeyword(interfaceKeyword), name(name), parameters(parameters), modport(modport)
    {
        childCount += 5;
    }

    VirtualInterfaceTypeSyntax(const VirtualInterfaceTypeSyntax&) = delete;
    VirtualInterfaceTypeSyntax& operator=(const VirtualInterfaceTypeSyntax&) = delete;

    static const VirtualInterfaceTypeSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return virtualKeyword;
            case 1: return interfaceKeyword;
            case 2: return name;
            case 3: return parameters;
            case 4: return modport;
            default: return nullptr;
        }
    }
};

struct ImplicitTypeSyntax : public DataTypeSyntax {
    Token signing;
    SyntaxList<VariableDimensionSyntax> dimensions;

    ImplicitTypeSyntax(Token signing, SyntaxList<VariableDimensionSyntax> dimensions) :
        DataTypeSyntax(SyntaxKind::ImplicitType), signing(signing), dimensions(dimensions)
    {
        childCount += 2;
    }

    ImplicitTypeSyntax(const ImplicitTypeSyntax&) = delete;
    ImplicitTypeSyntax& operator=(const ImplicitTypeSyntax&) = delete;

    static const ImplicitTypeSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return signing;
            case 1: return &dimensions;
            default: return nullptr;
        }
    }
};

struct VarDataTypeSyntax : public DataTypeSyntax {
    Token var;
    DataTypeSyntax& type;

    VarDataTypeSyntax(Token var, DataTypeSyntax& type) :
        DataTypeSyntax(SyntaxKind::VarDataType), var(var), type(type)
    {
        childCount += 2;
    }

    VarDataTypeSyntax(const VarDataTypeSyntax&) = delete;
    VarDataTypeSyntax& operator=(const VarDataTypeSyntax&) = delete;

    static const VarDataTypeSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return var;
            case 1: return &type;
            default: return nullptr;
        }
    }
};

// ----- ASSERTIONS -----

struct DeferredAssertionSyntax : public SyntaxNode {
    Token hash;
    Token zero;
    Token finalKeyword;

    DeferredAssertionSyntax(Token hash, Token zero, Token finalKeyword) :
        SyntaxNode(SyntaxKind::DeferredAssertion), hash(hash), zero(zero), finalKeyword(finalKeyword)
    {
        childCount += 3;
    }

    DeferredAssertionSyntax(const DeferredAssertionSyntax&) = delete;
    DeferredAssertionSyntax& operator=(const DeferredAssertionSyntax&) = delete;

    static const DeferredAssertionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return hash;
            case 1: return zero;
            case 2: return finalKeyword;
            default: return nullptr;
        }
    }
};

struct ElseClauseSyntax : public SyntaxNode {
    Token elseKeyword;
    SyntaxNode& clause;

    ElseClauseSyntax(Token elseKeyword, SyntaxNode& clause) :
        SyntaxNode(SyntaxKind::ElseClause), elseKeyword(elseKeyword), clause(clause)
    {
        childCount += 2;
    }

    ElseClauseSyntax(const ElseClauseSyntax&) = delete;
    ElseClauseSyntax& operator=(const ElseClauseSyntax&) = delete;

    static const ElseClauseSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return elseKeyword;
            case 1: return &clause;
            default: return nullptr;
        }
    }
};

struct ActionBlockSyntax : public SyntaxNode {
    StatementSyntax* statement;
    ElseClauseSyntax* elseClause;

    ActionBlockSyntax(StatementSyntax* statement, ElseClauseSyntax* elseClause) :
        SyntaxNode(SyntaxKind::ActionBlock), statement(statement), elseClause(elseClause)
    {
        childCount += 2;
    }

    ActionBlockSyntax(const ActionBlockSyntax&) = delete;
    ActionBlockSyntax& operator=(const ActionBlockSyntax&) = delete;

    static const ActionBlockSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return statement;
            case 1: return elseClause;
            default: return nullptr;
        }
    }
};

struct ImmediateAssertionStatementSyntax : public StatementSyntax {
    Token keyword;
    DeferredAssertionSyntax* delay;
    ParenthesizedExpressionSyntax& expr;
    ActionBlockSyntax& action;

    ImmediateAssertionStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, DeferredAssertionSyntax* delay, ParenthesizedExpressionSyntax& expr, ActionBlockSyntax& action) :
        StatementSyntax(kind, label, attributes), keyword(keyword), delay(delay), expr(expr), action(action)
    {
        childCount += 4;
    }

    ImmediateAssertionStatementSyntax(const ImmediateAssertionStatementSyntax&) = delete;
    ImmediateAssertionStatementSyntax& operator=(const ImmediateAssertionStatementSyntax&) = delete;

    static const ImmediateAssertionStatementSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return keyword;
            case 3: return delay;
            case 4: return &expr;
            case 5: return &action;
            default: return nullptr;
        }
    }
};

struct DisableIffSyntax : public SyntaxNode {
    Token disable;
    Token iff;
    Token openParen;
    ExpressionSyntax& expr;
    Token closeParen;

    DisableIffSyntax(Token disable, Token iff, Token openParen, ExpressionSyntax& expr, Token closeParen) :
        SyntaxNode(SyntaxKind::DisableIff), disable(disable), iff(iff), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 5;
    }

    DisableIffSyntax(const DisableIffSyntax&) = delete;
    DisableIffSyntax& operator=(const DisableIffSyntax&) = delete;

    static const DisableIffSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return disable;
            case 1: return iff;
            case 2: return openParen;
            case 3: return &expr;
            case 4: return closeParen;
            default: return nullptr;
        }
    }
};

struct PropertySpecSyntax : public SyntaxNode {
    TimingControlSyntax* clocking;
    DisableIffSyntax* disable;
    ExpressionSyntax& expr;

    PropertySpecSyntax(TimingControlSyntax* clocking, DisableIffSyntax* disable, ExpressionSyntax& expr) :
        SyntaxNode(SyntaxKind::PropertySpec), clocking(clocking), disable(disable), expr(expr)
    {
        childCount += 3;
    }

    PropertySpecSyntax(const PropertySpecSyntax&) = delete;
    PropertySpecSyntax& operator=(const PropertySpecSyntax&) = delete;

    static const PropertySpecSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return clocking;
            case 1: return disable;
            case 2: return &expr;
            default: return nullptr;
        }
    }
};

struct ConcurrentAssertionStatementSyntax : public StatementSyntax {
    Token keyword;
    Token propertyOrSequence;
    Token openParen;
    PropertySpecSyntax& propertySpec;
    Token closeParen;
    ActionBlockSyntax& action;

    ConcurrentAssertionStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token propertyOrSequence, Token openParen, PropertySpecSyntax& propertySpec, Token closeParen, ActionBlockSyntax& action) :
        StatementSyntax(kind, label, attributes), keyword(keyword), propertyOrSequence(propertyOrSequence), openParen(openParen), propertySpec(propertySpec), closeParen(closeParen), action(action)
    {
        childCount += 6;
    }

    ConcurrentAssertionStatementSyntax(const ConcurrentAssertionStatementSyntax&) = delete;
    ConcurrentAssertionStatementSyntax& operator=(const ConcurrentAssertionStatementSyntax&) = delete;

    static const ConcurrentAssertionStatementSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return keyword;
            case 3: return propertyOrSequence;
            case 4: return openParen;
            case 5: return &propertySpec;
            case 6: return closeParen;
            case 7: return &action;
            default: return nullptr;
        }
    }
};

struct ConcurrentAssertionMemberSyntax : public MemberSyntax {
    ConcurrentAssertionStatementSyntax& statement;

    ConcurrentAssertionMemberSyntax(SyntaxList<AttributeInstanceSyntax> attributes, ConcurrentAssertionStatementSyntax& statement) :
        MemberSyntax(SyntaxKind::ConcurrentAssertionMember, attributes), statement(statement)
    {
        childCount += 1;
    }

    ConcurrentAssertionMemberSyntax(const ConcurrentAssertionMemberSyntax&) = delete;
    ConcurrentAssertionMemberSyntax& operator=(const ConcurrentAssertionMemberSyntax&) = delete;

    static const ConcurrentAssertionMemberSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &statement;
            default: return nullptr;
        }
    }
};

struct ImmediateAssertionMemberSyntax : public MemberSyntax {
    ImmediateAssertionStatementSyntax& statement;

    ImmediateAssertionMemberSyntax(SyntaxList<AttributeInstanceSyntax> attributes, ImmediateAssertionStatementSyntax& statement) :
        MemberSyntax(SyntaxKind::ImmediateAssertionMember, attributes), statement(statement)
    {
        childCount += 1;
    }

    ImmediateAssertionMemberSyntax(const ImmediateAssertionMemberSyntax&) = delete;
    ImmediateAssertionMemberSyntax& operator=(const ImmediateAssertionMemberSyntax&) = delete;

    static const ImmediateAssertionMemberSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &statement;
            default: return nullptr;
        }
    }
};

// ----- STATEMENTS -----

struct EmptyStatementSyntax : public StatementSyntax {
    Token semicolon;

    EmptyStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token semicolon) :
        StatementSyntax(SyntaxKind::EmptyStatement, label, attributes), semicolon(semicolon)
    {
        childCount += 1;
    }

    EmptyStatementSyntax(const EmptyStatementSyntax&) = delete;
    EmptyStatementSyntax& operator=(const EmptyStatementSyntax&) = delete;

    static const EmptyStatementSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return semicolon;
            default: return nullptr;
        }
    }
};

struct ConditionalStatementSyntax : public StatementSyntax {
    Token uniqueOrPriority;
    Token ifKeyword;
    Token openParen;
    ConditionalPredicateSyntax& predicate;
    Token closeParen;
    StatementSyntax& statement;
    ElseClauseSyntax* elseClause;

    ConditionalStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token uniqueOrPriority, Token ifKeyword, Token openParen, ConditionalPredicateSyntax& predicate, Token closeParen, StatementSyntax& statement, ElseClauseSyntax* elseClause) :
        StatementSyntax(SyntaxKind::ConditionalStatement, label, attributes), uniqueOrPriority(uniqueOrPriority), ifKeyword(ifKeyword), openParen(openParen), predicate(predicate), closeParen(closeParen), statement(statement), elseClause(elseClause)
    {
        childCount += 7;
    }

    ConditionalStatementSyntax(const ConditionalStatementSyntax&) = delete;
    ConditionalStatementSyntax& operator=(const ConditionalStatementSyntax&) = delete;

    static const ConditionalStatementSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return uniqueOrPriority;
            case 3: return ifKeyword;
            case 4: return openParen;
            case 5: return &predicate;
            case 6: return closeParen;
            case 7: return &statement;
            case 8: return elseClause;
            default: return nullptr;
        }
    }
};

struct CaseItemSyntax : public SyntaxNode {

    CaseItemSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct DefaultCaseItemSyntax : public CaseItemSyntax {
    Token defaultKeyword;
    Token colon;
    SyntaxNode& clause;

    DefaultCaseItemSyntax(Token defaultKeyword, Token colon, SyntaxNode& clause) :
        CaseItemSyntax(SyntaxKind::DefaultCaseItem), defaultKeyword(defaultKeyword), colon(colon), clause(clause)
    {
        childCount += 3;
    }

    DefaultCaseItemSyntax(const DefaultCaseItemSyntax&) = delete;
    DefaultCaseItemSyntax& operator=(const DefaultCaseItemSyntax&) = delete;

    static const DefaultCaseItemSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return defaultKeyword;
            case 1: return colon;
            case 2: return &clause;
            default: return nullptr;
        }
    }
};

struct PatternCaseItemSyntax : public CaseItemSyntax {
    PatternSyntax& pattern;
    Token tripleAnd;
    ExpressionSyntax* expr;
    Token colon;
    StatementSyntax& statement;

    PatternCaseItemSyntax(PatternSyntax& pattern, Token tripleAnd, ExpressionSyntax* expr, Token colon, StatementSyntax& statement) :
        CaseItemSyntax(SyntaxKind::PatternCaseItem), pattern(pattern), tripleAnd(tripleAnd), expr(expr), colon(colon), statement(statement)
    {
        childCount += 5;
    }

    PatternCaseItemSyntax(const PatternCaseItemSyntax&) = delete;
    PatternCaseItemSyntax& operator=(const PatternCaseItemSyntax&) = delete;

    static const PatternCaseItemSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &pattern;
            case 1: return tripleAnd;
            case 2: return expr;
            case 3: return colon;
            case 4: return &statement;
            default: return nullptr;
        }
    }
};

struct StandardCaseItemSyntax : public CaseItemSyntax {
    SeparatedSyntaxList<ExpressionSyntax> expressions;
    Token colon;
    SyntaxNode& clause;

    StandardCaseItemSyntax(SeparatedSyntaxList<ExpressionSyntax> expressions, Token colon, SyntaxNode& clause) :
        CaseItemSyntax(SyntaxKind::StandardCaseItem), expressions(expressions), colon(colon), clause(clause)
    {
        childCount += 3;
    }

    StandardCaseItemSyntax(const StandardCaseItemSyntax&) = delete;
    StandardCaseItemSyntax& operator=(const StandardCaseItemSyntax&) = delete;

    static const StandardCaseItemSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &expressions;
            case 1: return colon;
            case 2: return &clause;
            default: return nullptr;
        }
    }
};

struct CaseStatementSyntax : public StatementSyntax {
    Token uniqueOrPriority;
    Token caseKeyword;
    Token openParen;
    ExpressionSyntax& expr;
    Token closeParen;
    Token matchesOrInside;
    SyntaxList<CaseItemSyntax> items;
    Token endcase;

    CaseStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token uniqueOrPriority, Token caseKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen, Token matchesOrInside, SyntaxList<CaseItemSyntax> items, Token endcase) :
        StatementSyntax(SyntaxKind::CaseStatement, label, attributes), uniqueOrPriority(uniqueOrPriority), caseKeyword(caseKeyword), openParen(openParen), expr(expr), closeParen(closeParen), matchesOrInside(matchesOrInside), items(items), endcase(endcase)
    {
        childCount += 8;
    }

    CaseStatementSyntax(const CaseStatementSyntax&) = delete;
    CaseStatementSyntax& operator=(const CaseStatementSyntax&) = delete;

    static const CaseStatementSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return uniqueOrPriority;
            case 3: return caseKeyword;
            case 4: return openParen;
            case 5: return &expr;
            case 6: return closeParen;
            case 7: return matchesOrInside;
            case 8: return &items;
            case 9: return endcase;
            default: return nullptr;
        }
    }
};

struct ForeverStatementSyntax : public StatementSyntax {
    Token foreverKeyword;
    StatementSyntax& statement;

    ForeverStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token foreverKeyword, StatementSyntax& statement) :
        StatementSyntax(SyntaxKind::ForeverStatement, label, attributes), foreverKeyword(foreverKeyword), statement(statement)
    {
        childCount += 2;
    }

    ForeverStatementSyntax(const ForeverStatementSyntax&) = delete;
    ForeverStatementSyntax& operator=(const ForeverStatementSyntax&) = delete;

    static const ForeverStatementSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return foreverKeyword;
            case 3: return &statement;
            default: return nullptr;
        }
    }
};

struct LoopStatementSyntax : public StatementSyntax {
    Token repeatOrWhile;
    Token openParen;
    ExpressionSyntax& expr;
    Token closeParen;
    StatementSyntax& statement;

    LoopStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token repeatOrWhile, Token openParen, ExpressionSyntax& expr, Token closeParen, StatementSyntax& statement) :
        StatementSyntax(SyntaxKind::LoopStatement, label, attributes), repeatOrWhile(repeatOrWhile), openParen(openParen), expr(expr), closeParen(closeParen), statement(statement)
    {
        childCount += 5;
    }

    LoopStatementSyntax(const LoopStatementSyntax&) = delete;
    LoopStatementSyntax& operator=(const LoopStatementSyntax&) = delete;

    static const LoopStatementSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return repeatOrWhile;
            case 3: return openParen;
            case 4: return &expr;
            case 5: return closeParen;
            case 6: return &statement;
            default: return nullptr;
        }
    }
};

struct DoWhileStatementSyntax : public StatementSyntax {
    Token doKeyword;
    StatementSyntax& statement;
    Token whileKeyword;
    Token openParen;
    ExpressionSyntax& expr;
    Token closeParen;
    Token semi;

    DoWhileStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token doKeyword, StatementSyntax& statement, Token whileKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen, Token semi) :
        StatementSyntax(SyntaxKind::DoWhileStatement, label, attributes), doKeyword(doKeyword), statement(statement), whileKeyword(whileKeyword), openParen(openParen), expr(expr), closeParen(closeParen), semi(semi)
    {
        childCount += 7;
    }

    DoWhileStatementSyntax(const DoWhileStatementSyntax&) = delete;
    DoWhileStatementSyntax& operator=(const DoWhileStatementSyntax&) = delete;

    static const DoWhileStatementSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return doKeyword;
            case 3: return &statement;
            case 4: return whileKeyword;
            case 5: return openParen;
            case 6: return &expr;
            case 7: return closeParen;
            case 8: return semi;
            default: return nullptr;
        }
    }
};

struct ForVariableDeclarationSyntax : public SyntaxNode {
    Token varKeyword;
    DataTypeSyntax& type;
    VariableDeclaratorSyntax& declarator;

    ForVariableDeclarationSyntax(Token varKeyword, DataTypeSyntax& type, VariableDeclaratorSyntax& declarator) :
        SyntaxNode(SyntaxKind::ForVariableDeclaration), varKeyword(varKeyword), type(type), declarator(declarator)
    {
        childCount += 3;
    }

    ForVariableDeclarationSyntax(const ForVariableDeclarationSyntax&) = delete;
    ForVariableDeclarationSyntax& operator=(const ForVariableDeclarationSyntax&) = delete;

    static const ForVariableDeclarationSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return varKeyword;
            case 1: return &type;
            case 2: return &declarator;
            default: return nullptr;
        }
    }
};

struct ForLoopStatementSyntax : public StatementSyntax {
    Token forKeyword;
    Token openParen;
    SeparatedSyntaxList<SyntaxNode> initializers;
    Token semi1;
    ExpressionSyntax& stopExpr;
    Token semi2;
    SeparatedSyntaxList<ExpressionSyntax> steps;
    Token closeParen;
    StatementSyntax& statement;

    ForLoopStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token forKeyword, Token openParen, SeparatedSyntaxList<SyntaxNode> initializers, Token semi1, ExpressionSyntax& stopExpr, Token semi2, SeparatedSyntaxList<ExpressionSyntax> steps, Token closeParen, StatementSyntax& statement) :
        StatementSyntax(SyntaxKind::ForLoopStatement, label, attributes), forKeyword(forKeyword), openParen(openParen), initializers(initializers), semi1(semi1), stopExpr(stopExpr), semi2(semi2), steps(steps), closeParen(closeParen), statement(statement)
    {
        childCount += 9;
    }

    ForLoopStatementSyntax(const ForLoopStatementSyntax&) = delete;
    ForLoopStatementSyntax& operator=(const ForLoopStatementSyntax&) = delete;

    static const ForLoopStatementSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return forKeyword;
            case 3: return openParen;
            case 4: return &initializers;
            case 5: return semi1;
            case 6: return &stopExpr;
            case 7: return semi2;
            case 8: return &steps;
            case 9: return closeParen;
            case 10: return &statement;
            default: return nullptr;
        }
    }
};

struct ForeachLoopListSyntax : public SyntaxNode {
    Token openParen;
    NameSyntax& arrayName;
    Token openBracket;
    SeparatedSyntaxList<NameSyntax> loopVariables;
    Token closeBracket;
    Token closeParen;

    ForeachLoopListSyntax(Token openParen, NameSyntax& arrayName, Token openBracket, SeparatedSyntaxList<NameSyntax> loopVariables, Token closeBracket, Token closeParen) :
        SyntaxNode(SyntaxKind::ForeachLoopList), openParen(openParen), arrayName(arrayName), openBracket(openBracket), loopVariables(loopVariables), closeBracket(closeBracket), closeParen(closeParen)
    {
        childCount += 6;
    }

    ForeachLoopListSyntax(const ForeachLoopListSyntax&) = delete;
    ForeachLoopListSyntax& operator=(const ForeachLoopListSyntax&) = delete;

    static const ForeachLoopListSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &arrayName;
            case 2: return openBracket;
            case 3: return &loopVariables;
            case 4: return closeBracket;
            case 5: return closeParen;
            default: return nullptr;
        }
    }
};

struct ForeachLoopStatementSyntax : public StatementSyntax {
    Token keyword;
    ForeachLoopListSyntax& loopList;
    StatementSyntax& statement;

    ForeachLoopStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, ForeachLoopListSyntax& loopList, StatementSyntax& statement) :
        StatementSyntax(SyntaxKind::ForeachLoopStatement, label, attributes), keyword(keyword), loopList(loopList), statement(statement)
    {
        childCount += 3;
    }

    ForeachLoopStatementSyntax(const ForeachLoopStatementSyntax&) = delete;
    ForeachLoopStatementSyntax& operator=(const ForeachLoopStatementSyntax&) = delete;

    static const ForeachLoopStatementSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return keyword;
            case 3: return &loopList;
            case 4: return &statement;
            default: return nullptr;
        }
    }
};

struct ReturnStatementSyntax : public StatementSyntax {
    Token returnKeyword;
    ExpressionSyntax* returnValue;
    Token semi;

    ReturnStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token returnKeyword, ExpressionSyntax* returnValue, Token semi) :
        StatementSyntax(SyntaxKind::ReturnStatement, label, attributes), returnKeyword(returnKeyword), returnValue(returnValue), semi(semi)
    {
        childCount += 3;
    }

    ReturnStatementSyntax(const ReturnStatementSyntax&) = delete;
    ReturnStatementSyntax& operator=(const ReturnStatementSyntax&) = delete;

    static const ReturnStatementSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return returnKeyword;
            case 3: return returnValue;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct JumpStatementSyntax : public StatementSyntax {
    Token breakOrContinue;
    Token semi;

    JumpStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token breakOrContinue, Token semi) :
        StatementSyntax(SyntaxKind::JumpStatement, label, attributes), breakOrContinue(breakOrContinue), semi(semi)
    {
        childCount += 2;
    }

    JumpStatementSyntax(const JumpStatementSyntax&) = delete;
    JumpStatementSyntax& operator=(const JumpStatementSyntax&) = delete;

    static const JumpStatementSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return breakOrContinue;
            case 3: return semi;
            default: return nullptr;
        }
    }
};

struct TimingControlStatementSyntax : public StatementSyntax {
    TimingControlSyntax& timingControl;
    StatementSyntax& statement;

    TimingControlStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, TimingControlSyntax& timingControl, StatementSyntax& statement) :
        StatementSyntax(SyntaxKind::TimingControlStatement, label, attributes), timingControl(timingControl), statement(statement)
    {
        childCount += 2;
    }

    TimingControlStatementSyntax(const TimingControlStatementSyntax&) = delete;
    TimingControlStatementSyntax& operator=(const TimingControlStatementSyntax&) = delete;

    static const TimingControlStatementSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return &timingControl;
            case 3: return &statement;
            default: return nullptr;
        }
    }
};

struct ExpressionStatementSyntax : public StatementSyntax {
    ExpressionSyntax& expr;
    Token semi;

    ExpressionStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& expr, Token semi) :
        StatementSyntax(SyntaxKind::ExpressionStatement, label, attributes), expr(expr), semi(semi)
    {
        childCount += 2;
    }

    ExpressionStatementSyntax(const ExpressionStatementSyntax&) = delete;
    ExpressionStatementSyntax& operator=(const ExpressionStatementSyntax&) = delete;

    static const ExpressionStatementSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return &expr;
            case 3: return semi;
            default: return nullptr;
        }
    }
};

struct ProceduralAssignStatementSyntax : public StatementSyntax {
    Token keyword;
    ExpressionSyntax& lvalue;
    Token equals;
    ExpressionSyntax& value;
    Token semi;

    ProceduralAssignStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, ExpressionSyntax& lvalue, Token equals, ExpressionSyntax& value, Token semi) :
        StatementSyntax(kind, label, attributes), keyword(keyword), lvalue(lvalue), equals(equals), value(value), semi(semi)
    {
        childCount += 5;
    }

    ProceduralAssignStatementSyntax(const ProceduralAssignStatementSyntax&) = delete;
    ProceduralAssignStatementSyntax& operator=(const ProceduralAssignStatementSyntax&) = delete;

    static const ProceduralAssignStatementSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return keyword;
            case 3: return &lvalue;
            case 4: return equals;
            case 5: return &value;
            case 6: return semi;
            default: return nullptr;
        }
    }
};

struct ProceduralDeassignStatementSyntax : public StatementSyntax {
    Token keyword;
    ExpressionSyntax& variable;
    Token semi;

    ProceduralDeassignStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, ExpressionSyntax& variable, Token semi) :
        StatementSyntax(kind, label, attributes), keyword(keyword), variable(variable), semi(semi)
    {
        childCount += 3;
    }

    ProceduralDeassignStatementSyntax(const ProceduralDeassignStatementSyntax&) = delete;
    ProceduralDeassignStatementSyntax& operator=(const ProceduralDeassignStatementSyntax&) = delete;

    static const ProceduralDeassignStatementSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return keyword;
            case 3: return &variable;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct DisableStatementSyntax : public StatementSyntax {
    Token disable;
    NameSyntax& name;
    Token semi;

    DisableStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token disable, NameSyntax& name, Token semi) :
        StatementSyntax(SyntaxKind::DisableStatement, label, attributes), disable(disable), name(name), semi(semi)
    {
        childCount += 3;
    }

    DisableStatementSyntax(const DisableStatementSyntax&) = delete;
    DisableStatementSyntax& operator=(const DisableStatementSyntax&) = delete;

    static const DisableStatementSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return disable;
            case 3: return &name;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct DisableForkStatementSyntax : public StatementSyntax {
    Token disable;
    Token fork;
    Token semi;

    DisableForkStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token disable, Token fork, Token semi) :
        StatementSyntax(SyntaxKind::DisableForkStatement, label, attributes), disable(disable), fork(fork), semi(semi)
    {
        childCount += 3;
    }

    DisableForkStatementSyntax(const DisableForkStatementSyntax&) = delete;
    DisableForkStatementSyntax& operator=(const DisableForkStatementSyntax&) = delete;

    static const DisableForkStatementSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return disable;
            case 3: return fork;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct NamedBlockClauseSyntax : public SyntaxNode {
    Token colon;
    Token name;

    NamedBlockClauseSyntax(Token colon, Token name) :
        SyntaxNode(SyntaxKind::NamedBlockClause), colon(colon), name(name)
    {
        childCount += 2;
    }

    NamedBlockClauseSyntax(const NamedBlockClauseSyntax&) = delete;
    NamedBlockClauseSyntax& operator=(const NamedBlockClauseSyntax&) = delete;

    static const NamedBlockClauseSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return colon;
            case 1: return name;
            default: return nullptr;
        }
    }
};

struct BlockStatementSyntax : public StatementSyntax {
    Token begin;
    NamedBlockClauseSyntax* blockName;
    SyntaxList<SyntaxNode> items;
    Token end;
    NamedBlockClauseSyntax* endBlockName;

    BlockStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token begin, NamedBlockClauseSyntax* blockName, SyntaxList<SyntaxNode> items, Token end, NamedBlockClauseSyntax* endBlockName) :
        StatementSyntax(kind, label, attributes), begin(begin), blockName(blockName), items(items), end(end), endBlockName(endBlockName)
    {
        childCount += 5;
    }

    BlockStatementSyntax(const BlockStatementSyntax&) = delete;
    BlockStatementSyntax& operator=(const BlockStatementSyntax&) = delete;

    static const BlockStatementSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return begin;
            case 3: return blockName;
            case 4: return &items;
            case 5: return end;
            case 6: return endBlockName;
            default: return nullptr;
        }
    }
};

struct WaitStatementSyntax : public StatementSyntax {
    Token wait;
    Token openParen;
    ExpressionSyntax& expr;
    Token closeParen;
    StatementSyntax& statement;

    WaitStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token wait, Token openParen, ExpressionSyntax& expr, Token closeParen, StatementSyntax& statement) :
        StatementSyntax(SyntaxKind::WaitStatement, label, attributes), wait(wait), openParen(openParen), expr(expr), closeParen(closeParen), statement(statement)
    {
        childCount += 5;
    }

    WaitStatementSyntax(const WaitStatementSyntax&) = delete;
    WaitStatementSyntax& operator=(const WaitStatementSyntax&) = delete;

    static const WaitStatementSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return wait;
            case 3: return openParen;
            case 4: return &expr;
            case 5: return closeParen;
            case 6: return &statement;
            default: return nullptr;
        }
    }
};

struct WaitForkStatementSyntax : public StatementSyntax {
    Token wait;
    Token fork;
    Token semi;

    WaitForkStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token wait, Token fork, Token semi) :
        StatementSyntax(SyntaxKind::WaitForkStatement, label, attributes), wait(wait), fork(fork), semi(semi)
    {
        childCount += 3;
    }

    WaitForkStatementSyntax(const WaitForkStatementSyntax&) = delete;
    WaitForkStatementSyntax& operator=(const WaitForkStatementSyntax&) = delete;

    static const WaitForkStatementSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return wait;
            case 3: return fork;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct WaitOrderStatementSyntax : public StatementSyntax {
    Token wait_order;
    Token openParen;
    SeparatedSyntaxList<NameSyntax> names;
    Token closeParen;
    ActionBlockSyntax& action;

    WaitOrderStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token wait_order, Token openParen, SeparatedSyntaxList<NameSyntax> names, Token closeParen, ActionBlockSyntax& action) :
        StatementSyntax(SyntaxKind::WaitOrderStatement, label, attributes), wait_order(wait_order), openParen(openParen), names(names), closeParen(closeParen), action(action)
    {
        childCount += 5;
    }

    WaitOrderStatementSyntax(const WaitOrderStatementSyntax&) = delete;
    WaitOrderStatementSyntax& operator=(const WaitOrderStatementSyntax&) = delete;

    static const WaitOrderStatementSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return wait_order;
            case 3: return openParen;
            case 4: return &names;
            case 5: return closeParen;
            case 6: return &action;
            default: return nullptr;
        }
    }
};

struct RandCaseItemSyntax : public SyntaxNode {
    ExpressionSyntax& expr;
    Token colon;
    StatementSyntax& statement;

    RandCaseItemSyntax(ExpressionSyntax& expr, Token colon, StatementSyntax& statement) :
        SyntaxNode(SyntaxKind::RandCaseItem), expr(expr), colon(colon), statement(statement)
    {
        childCount += 3;
    }

    RandCaseItemSyntax(const RandCaseItemSyntax&) = delete;
    RandCaseItemSyntax& operator=(const RandCaseItemSyntax&) = delete;

    static const RandCaseItemSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &expr;
            case 1: return colon;
            case 2: return &statement;
            default: return nullptr;
        }
    }
};

struct RandCaseStatementSyntax : public StatementSyntax {
    Token randCase;
    SyntaxList<RandCaseItemSyntax> items;
    Token endCase;

    RandCaseStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token randCase, SyntaxList<RandCaseItemSyntax> items, Token endCase) :
        StatementSyntax(SyntaxKind::RandCaseStatement, label, attributes), randCase(randCase), items(items), endCase(endCase)
    {
        childCount += 3;
    }

    RandCaseStatementSyntax(const RandCaseStatementSyntax&) = delete;
    RandCaseStatementSyntax& operator=(const RandCaseStatementSyntax&) = delete;

    static const RandCaseStatementSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return randCase;
            case 3: return &items;
            case 4: return endCase;
            default: return nullptr;
        }
    }
};

struct EventTriggerStatementSyntax : public StatementSyntax {
    Token trigger;
    TimingControlSyntax* timing;
    NameSyntax& name;

    EventTriggerStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token trigger, TimingControlSyntax* timing, NameSyntax& name) :
        StatementSyntax(kind, label, attributes), trigger(trigger), timing(timing), name(name)
    {
        childCount += 3;
    }

    EventTriggerStatementSyntax(const EventTriggerStatementSyntax&) = delete;
    EventTriggerStatementSyntax& operator=(const EventTriggerStatementSyntax&) = delete;

    static const EventTriggerStatementSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return trigger;
            case 3: return timing;
            case 4: return &name;
            default: return nullptr;
        }
    }
};

// ----- MODULES -----

struct PortListSyntax : public SyntaxNode {

    PortListSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct NonAnsiPortSyntax : public SyntaxNode {

    NonAnsiPortSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct ImplicitNonAnsiPortSyntax : public NonAnsiPortSyntax {
    ExpressionSyntax& expr;

    ImplicitNonAnsiPortSyntax(ExpressionSyntax& expr) :
        NonAnsiPortSyntax(SyntaxKind::ImplicitNonAnsiPort), expr(expr)
    {
        childCount += 1;
    }

    ImplicitNonAnsiPortSyntax(const ImplicitNonAnsiPortSyntax&) = delete;
    ImplicitNonAnsiPortSyntax& operator=(const ImplicitNonAnsiPortSyntax&) = delete;

    static const ImplicitNonAnsiPortSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &expr;
            default: return nullptr;
        }
    }
};

struct ExplicitNonAnsiPortSyntax : public NonAnsiPortSyntax {
    Token dot;
    Token name;
    Token openParen;
    ExpressionSyntax* expr;
    Token closeParen;

    ExplicitNonAnsiPortSyntax(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) :
        NonAnsiPortSyntax(SyntaxKind::ExplicitNonAnsiPort), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 5;
    }

    ExplicitNonAnsiPortSyntax(const ExplicitNonAnsiPortSyntax&) = delete;
    ExplicitNonAnsiPortSyntax& operator=(const ExplicitNonAnsiPortSyntax&) = delete;

    static const ExplicitNonAnsiPortSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return dot;
            case 1: return name;
            case 2: return openParen;
            case 3: return expr;
            case 4: return closeParen;
            default: return nullptr;
        }
    }
};

struct NonAnsiPortListSyntax : public PortListSyntax {
    Token openParen;
    SeparatedSyntaxList<NonAnsiPortSyntax> ports;
    Token closeParen;

    NonAnsiPortListSyntax(Token openParen, SeparatedSyntaxList<NonAnsiPortSyntax> ports, Token closeParen) :
        PortListSyntax(SyntaxKind::NonAnsiPortList), openParen(openParen), ports(ports), closeParen(closeParen)
    {
        childCount += 3;
    }

    NonAnsiPortListSyntax(const NonAnsiPortListSyntax&) = delete;
    NonAnsiPortListSyntax& operator=(const NonAnsiPortListSyntax&) = delete;

    static const NonAnsiPortListSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &ports;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct AnsiPortSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;

    AnsiPortSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes) :
        SyntaxNode(kind), attributes(attributes)
    {
        childCount += 1;
    }

    AnsiPortSyntax(const AnsiPortSyntax&) = delete;
    AnsiPortSyntax& operator=(const AnsiPortSyntax&) = delete;

    static const AnsiPortSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override {
        switch (index) {
            case 0: return &attributes;
            default: return nullptr;
        }
    }
};

struct InterfacePortHeaderSyntax : public PortHeaderSyntax {
    Token nameOrKeyword;
    DotMemberClauseSyntax* modport;

    InterfacePortHeaderSyntax(Token nameOrKeyword, DotMemberClauseSyntax* modport) :
        PortHeaderSyntax(SyntaxKind::InterfacePortHeader), nameOrKeyword(nameOrKeyword), modport(modport)
    {
        childCount += 2;
    }

    InterfacePortHeaderSyntax(const InterfacePortHeaderSyntax&) = delete;
    InterfacePortHeaderSyntax& operator=(const InterfacePortHeaderSyntax&) = delete;

    static const InterfacePortHeaderSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return nameOrKeyword;
            case 1: return modport;
            default: return nullptr;
        }
    }
};

struct VariablePortHeaderSyntax : public PortHeaderSyntax {
    Token direction;
    Token varKeyword;
    DataTypeSyntax* type;

    VariablePortHeaderSyntax(Token direction, Token varKeyword, DataTypeSyntax* type) :
        PortHeaderSyntax(SyntaxKind::VariablePortHeader), direction(direction), varKeyword(varKeyword), type(type)
    {
        childCount += 3;
    }

    VariablePortHeaderSyntax(const VariablePortHeaderSyntax&) = delete;
    VariablePortHeaderSyntax& operator=(const VariablePortHeaderSyntax&) = delete;

    static const VariablePortHeaderSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return direction;
            case 1: return varKeyword;
            case 2: return type;
            default: return nullptr;
        }
    }
};

struct InterconnectPortHeaderSyntax : public PortHeaderSyntax {
    Token direction;
    Token interconnect;
    DataTypeSyntax* type;

    InterconnectPortHeaderSyntax(Token direction, Token interconnect, DataTypeSyntax* type) :
        PortHeaderSyntax(SyntaxKind::InterconnectPortHeader), direction(direction), interconnect(interconnect), type(type)
    {
        childCount += 3;
    }

    InterconnectPortHeaderSyntax(const InterconnectPortHeaderSyntax&) = delete;
    InterconnectPortHeaderSyntax& operator=(const InterconnectPortHeaderSyntax&) = delete;

    static const InterconnectPortHeaderSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return direction;
            case 1: return interconnect;
            case 2: return type;
            default: return nullptr;
        }
    }
};

struct NetPortHeaderSyntax : public PortHeaderSyntax {
    Token direction;
    Token netType;
    DataTypeSyntax& dataType;

    NetPortHeaderSyntax(Token direction, Token netType, DataTypeSyntax& dataType) :
        PortHeaderSyntax(SyntaxKind::NetPortHeader), direction(direction), netType(netType), dataType(dataType)
    {
        childCount += 3;
    }

    NetPortHeaderSyntax(const NetPortHeaderSyntax&) = delete;
    NetPortHeaderSyntax& operator=(const NetPortHeaderSyntax&) = delete;

    static const NetPortHeaderSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return direction;
            case 1: return netType;
            case 2: return &dataType;
            default: return nullptr;
        }
    }
};

struct ImplicitAnsiPortSyntax : public AnsiPortSyntax {
    PortHeaderSyntax& header;
    VariableDeclaratorSyntax& declarator;

    ImplicitAnsiPortSyntax(SyntaxList<AttributeInstanceSyntax> attributes, PortHeaderSyntax& header, VariableDeclaratorSyntax& declarator) :
        AnsiPortSyntax(SyntaxKind::ImplicitAnsiPort, attributes), header(header), declarator(declarator)
    {
        childCount += 2;
    }

    ImplicitAnsiPortSyntax(const ImplicitAnsiPortSyntax&) = delete;
    ImplicitAnsiPortSyntax& operator=(const ImplicitAnsiPortSyntax&) = delete;

    static const ImplicitAnsiPortSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &header;
            case 2: return &declarator;
            default: return nullptr;
        }
    }
};

struct ExplicitAnsiPortSyntax : public AnsiPortSyntax {
    Token direction;
    Token dot;
    Token name;
    Token openParen;
    ExpressionSyntax* expr;
    Token closeParen;

    ExplicitAnsiPortSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token direction, Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) :
        AnsiPortSyntax(SyntaxKind::ExplicitAnsiPort, attributes), direction(direction), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 6;
    }

    ExplicitAnsiPortSyntax(const ExplicitAnsiPortSyntax&) = delete;
    ExplicitAnsiPortSyntax& operator=(const ExplicitAnsiPortSyntax&) = delete;

    static const ExplicitAnsiPortSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return direction;
            case 2: return dot;
            case 3: return name;
            case 4: return openParen;
            case 5: return expr;
            case 6: return closeParen;
            default: return nullptr;
        }
    }
};

struct AnsiPortListSyntax : public PortListSyntax {
    Token openParen;
    SeparatedSyntaxList<MemberSyntax> ports;
    Token closeParen;

    AnsiPortListSyntax(Token openParen, SeparatedSyntaxList<MemberSyntax> ports, Token closeParen) :
        PortListSyntax(SyntaxKind::AnsiPortList), openParen(openParen), ports(ports), closeParen(closeParen)
    {
        childCount += 3;
    }

    AnsiPortListSyntax(const AnsiPortListSyntax&) = delete;
    AnsiPortListSyntax& operator=(const AnsiPortListSyntax&) = delete;

    static const AnsiPortListSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &ports;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct WildcardPortListSyntax : public PortListSyntax {
    Token openParen;
    Token dotStar;
    Token closeParen;

    WildcardPortListSyntax(Token openParen, Token dotStar, Token closeParen) :
        PortListSyntax(SyntaxKind::WildcardPortList), openParen(openParen), dotStar(dotStar), closeParen(closeParen)
    {
        childCount += 3;
    }

    WildcardPortListSyntax(const WildcardPortListSyntax&) = delete;
    WildcardPortListSyntax& operator=(const WildcardPortListSyntax&) = delete;

    static const WildcardPortListSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openParen;
            case 1: return dotStar;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct ParameterPortListSyntax : public SyntaxNode {
    Token hash;
    Token openParen;
    SeparatedSyntaxList<ParameterDeclarationSyntax> declarations;
    Token closeParen;

    ParameterPortListSyntax(Token hash, Token openParen, SeparatedSyntaxList<ParameterDeclarationSyntax> declarations, Token closeParen) :
        SyntaxNode(SyntaxKind::ParameterPortList), hash(hash), openParen(openParen), declarations(declarations), closeParen(closeParen)
    {
        childCount += 4;
    }

    ParameterPortListSyntax(const ParameterPortListSyntax&) = delete;
    ParameterPortListSyntax& operator=(const ParameterPortListSyntax&) = delete;

    static const ParameterPortListSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return hash;
            case 1: return openParen;
            case 2: return &declarations;
            case 3: return closeParen;
            default: return nullptr;
        }
    }
};

struct ModuleHeaderSyntax : public SyntaxNode {
    Token moduleKeyword;
    Token lifetime;
    Token name;
    SyntaxList<PackageImportDeclarationSyntax> imports;
    ParameterPortListSyntax* parameters;
    PortListSyntax* ports;
    Token semi;

    ModuleHeaderSyntax(SyntaxKind kind, Token moduleKeyword, Token lifetime, Token name, SyntaxList<PackageImportDeclarationSyntax> imports, ParameterPortListSyntax* parameters, PortListSyntax* ports, Token semi) :
        SyntaxNode(kind), moduleKeyword(moduleKeyword), lifetime(lifetime), name(name), imports(imports), parameters(parameters), ports(ports), semi(semi)
    {
        childCount += 7;
    }

    ModuleHeaderSyntax(const ModuleHeaderSyntax&) = delete;
    ModuleHeaderSyntax& operator=(const ModuleHeaderSyntax&) = delete;

    static const ModuleHeaderSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return moduleKeyword;
            case 1: return lifetime;
            case 2: return name;
            case 3: return &imports;
            case 4: return parameters;
            case 5: return ports;
            case 6: return semi;
            default: return nullptr;
        }
    }
};

struct ModuleDeclarationSyntax : public MemberSyntax {
    ModuleHeaderSyntax& header;
    SyntaxList<MemberSyntax> members;
    Token endmodule;
    NamedBlockClauseSyntax* blockName;

    ModuleDeclarationSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes, ModuleHeaderSyntax& header, SyntaxList<MemberSyntax> members, Token endmodule, NamedBlockClauseSyntax* blockName) :
        MemberSyntax(kind, attributes), header(header), members(members), endmodule(endmodule), blockName(blockName)
    {
        childCount += 4;
    }

    ModuleDeclarationSyntax(const ModuleDeclarationSyntax&) = delete;
    ModuleDeclarationSyntax& operator=(const ModuleDeclarationSyntax&) = delete;

    static const ModuleDeclarationSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &header;
            case 2: return &members;
            case 3: return endmodule;
            case 4: return blockName;
            default: return nullptr;
        }
    }
};

struct ExternModuleSyntax : public SyntaxNode {
    Token externKeyword;
    ModuleHeaderSyntax& header;

    ExternModuleSyntax(Token externKeyword, ModuleHeaderSyntax& header) :
        SyntaxNode(SyntaxKind::ExternModule), externKeyword(externKeyword), header(header)
    {
        childCount += 2;
    }

    ExternModuleSyntax(const ExternModuleSyntax&) = delete;
    ExternModuleSyntax& operator=(const ExternModuleSyntax&) = delete;

    static const ExternModuleSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return externKeyword;
            case 1: return &header;
            default: return nullptr;
        }
    }
};

// ----- MEMBERS -----

struct EmptyMemberSyntax : public MemberSyntax {
    TokenList qualifiers;
    Token semi;

    EmptyMemberSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, Token semi) :
        MemberSyntax(SyntaxKind::EmptyMember, attributes), qualifiers(qualifiers), semi(semi)
    {
        childCount += 2;
    }

    EmptyMemberSyntax(const EmptyMemberSyntax&) = delete;
    EmptyMemberSyntax& operator=(const EmptyMemberSyntax&) = delete;

    static const EmptyMemberSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &qualifiers;
            case 2: return semi;
            default: return nullptr;
        }
    }
};

struct ProceduralBlockSyntax : public MemberSyntax {
    Token keyword;
    StatementSyntax& statement;

    ProceduralBlockSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, StatementSyntax& statement) :
        MemberSyntax(kind, attributes), keyword(keyword), statement(statement)
    {
        childCount += 2;
    }

    ProceduralBlockSyntax(const ProceduralBlockSyntax&) = delete;
    ProceduralBlockSyntax& operator=(const ProceduralBlockSyntax&) = delete;

    static const ProceduralBlockSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return &statement;
            default: return nullptr;
        }
    }
};

struct GenerateRegionSyntax : public MemberSyntax {
    Token keyword;
    SyntaxList<MemberSyntax> members;
    Token endgenerate;

    GenerateRegionSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, SyntaxList<MemberSyntax> members, Token endgenerate) :
        MemberSyntax(SyntaxKind::GenerateRegion, attributes), keyword(keyword), members(members), endgenerate(endgenerate)
    {
        childCount += 3;
    }

    GenerateRegionSyntax(const GenerateRegionSyntax&) = delete;
    GenerateRegionSyntax& operator=(const GenerateRegionSyntax&) = delete;

    static const GenerateRegionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return &members;
            case 3: return endgenerate;
            default: return nullptr;
        }
    }
};

struct LoopGenerateSyntax : public MemberSyntax {
    Token keyword;
    Token openParen;
    Token genvar;
    Token identifier;
    Token equals;
    ExpressionSyntax& initialExpr;
    Token semi1;
    ExpressionSyntax& stopExpr;
    Token semi2;
    ExpressionSyntax& iterationExpr;
    Token closeParen;
    MemberSyntax& block;

    LoopGenerateSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token openParen, Token genvar, Token identifier, Token equals, ExpressionSyntax& initialExpr, Token semi1, ExpressionSyntax& stopExpr, Token semi2, ExpressionSyntax& iterationExpr, Token closeParen, MemberSyntax& block) :
        MemberSyntax(SyntaxKind::LoopGenerate, attributes), keyword(keyword), openParen(openParen), genvar(genvar), identifier(identifier), equals(equals), initialExpr(initialExpr), semi1(semi1), stopExpr(stopExpr), semi2(semi2), iterationExpr(iterationExpr), closeParen(closeParen), block(block)
    {
        childCount += 12;
    }

    LoopGenerateSyntax(const LoopGenerateSyntax&) = delete;
    LoopGenerateSyntax& operator=(const LoopGenerateSyntax&) = delete;

    static const LoopGenerateSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return openParen;
            case 3: return genvar;
            case 4: return identifier;
            case 5: return equals;
            case 6: return &initialExpr;
            case 7: return semi1;
            case 8: return &stopExpr;
            case 9: return semi2;
            case 10: return &iterationExpr;
            case 11: return closeParen;
            case 12: return &block;
            default: return nullptr;
        }
    }
};

struct IfGenerateSyntax : public MemberSyntax {
    Token keyword;
    Token openParen;
    ExpressionSyntax& condition;
    Token closeParen;
    MemberSyntax& block;
    ElseClauseSyntax* elseClause;

    IfGenerateSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, MemberSyntax& block, ElseClauseSyntax* elseClause) :
        MemberSyntax(SyntaxKind::IfGenerate, attributes), keyword(keyword), openParen(openParen), condition(condition), closeParen(closeParen), block(block), elseClause(elseClause)
    {
        childCount += 6;
    }

    IfGenerateSyntax(const IfGenerateSyntax&) = delete;
    IfGenerateSyntax& operator=(const IfGenerateSyntax&) = delete;

    static const IfGenerateSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return openParen;
            case 3: return &condition;
            case 4: return closeParen;
            case 5: return &block;
            case 6: return elseClause;
            default: return nullptr;
        }
    }
};

struct CaseGenerateSyntax : public MemberSyntax {
    Token keyword;
    Token openParen;
    ExpressionSyntax& condition;
    Token closeParen;
    SyntaxList<CaseItemSyntax> items;
    Token endCase;

    CaseGenerateSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, SyntaxList<CaseItemSyntax> items, Token endCase) :
        MemberSyntax(SyntaxKind::CaseGenerate, attributes), keyword(keyword), openParen(openParen), condition(condition), closeParen(closeParen), items(items), endCase(endCase)
    {
        childCount += 6;
    }

    CaseGenerateSyntax(const CaseGenerateSyntax&) = delete;
    CaseGenerateSyntax& operator=(const CaseGenerateSyntax&) = delete;

    static const CaseGenerateSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return openParen;
            case 3: return &condition;
            case 4: return closeParen;
            case 5: return &items;
            case 6: return endCase;
            default: return nullptr;
        }
    }
};

struct GenerateBlockSyntax : public MemberSyntax {
    NamedLabelSyntax* label;
    Token begin;
    NamedBlockClauseSyntax* beginName;
    SyntaxList<MemberSyntax> members;
    Token end;
    NamedBlockClauseSyntax* endName;

    GenerateBlockSyntax(SyntaxList<AttributeInstanceSyntax> attributes, NamedLabelSyntax* label, Token begin, NamedBlockClauseSyntax* beginName, SyntaxList<MemberSyntax> members, Token end, NamedBlockClauseSyntax* endName) :
        MemberSyntax(SyntaxKind::GenerateBlock, attributes), label(label), begin(begin), beginName(beginName), members(members), end(end), endName(endName)
    {
        childCount += 6;
    }

    GenerateBlockSyntax(const GenerateBlockSyntax&) = delete;
    GenerateBlockSyntax& operator=(const GenerateBlockSyntax&) = delete;

    static const GenerateBlockSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return label;
            case 2: return begin;
            case 3: return beginName;
            case 4: return &members;
            case 5: return end;
            case 6: return endName;
            default: return nullptr;
        }
    }
};

struct DividerClauseSyntax : public SyntaxNode {
    Token divide;
    Token value;

    DividerClauseSyntax(Token divide, Token value) :
        SyntaxNode(SyntaxKind::DividerClause), divide(divide), value(value)
    {
        childCount += 2;
    }

    DividerClauseSyntax(const DividerClauseSyntax&) = delete;
    DividerClauseSyntax& operator=(const DividerClauseSyntax&) = delete;

    static const DividerClauseSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return divide;
            case 1: return value;
            default: return nullptr;
        }
    }
};

struct TimeUnitsDeclarationSyntax : public MemberSyntax {
    Token keyword;
    Token time;
    DividerClauseSyntax* divider;
    Token semi;

    TimeUnitsDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token time, DividerClauseSyntax* divider, Token semi) :
        MemberSyntax(SyntaxKind::TimeUnitsDeclaration, attributes), keyword(keyword), time(time), divider(divider), semi(semi)
    {
        childCount += 4;
    }

    TimeUnitsDeclarationSyntax(const TimeUnitsDeclarationSyntax&) = delete;
    TimeUnitsDeclarationSyntax& operator=(const TimeUnitsDeclarationSyntax&) = delete;

    static const TimeUnitsDeclarationSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return time;
            case 3: return divider;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct PortConnectionSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;

    PortConnectionSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes) :
        SyntaxNode(kind), attributes(attributes)
    {
        childCount += 1;
    }

    PortConnectionSyntax(const PortConnectionSyntax&) = delete;
    PortConnectionSyntax& operator=(const PortConnectionSyntax&) = delete;

    static const PortConnectionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override {
        switch (index) {
            case 0: return &attributes;
            default: return nullptr;
        }
    }
};

struct OrderedPortConnectionSyntax : public PortConnectionSyntax {
    ExpressionSyntax& expr;

    OrderedPortConnectionSyntax(SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& expr) :
        PortConnectionSyntax(SyntaxKind::OrderedPortConnection, attributes), expr(expr)
    {
        childCount += 1;
    }

    OrderedPortConnectionSyntax(const OrderedPortConnectionSyntax&) = delete;
    OrderedPortConnectionSyntax& operator=(const OrderedPortConnectionSyntax&) = delete;

    static const OrderedPortConnectionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &expr;
            default: return nullptr;
        }
    }
};

struct NamedPortConnectionSyntax : public PortConnectionSyntax {
    Token dot;
    Token name;
    Token openParen;
    ExpressionSyntax* expr;
    Token closeParen;

    NamedPortConnectionSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) :
        PortConnectionSyntax(SyntaxKind::NamedPortConnection, attributes), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 5;
    }

    NamedPortConnectionSyntax(const NamedPortConnectionSyntax&) = delete;
    NamedPortConnectionSyntax& operator=(const NamedPortConnectionSyntax&) = delete;

    static const NamedPortConnectionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return dot;
            case 2: return name;
            case 3: return openParen;
            case 4: return expr;
            case 5: return closeParen;
            default: return nullptr;
        }
    }
};

struct WildcardPortConnectionSyntax : public PortConnectionSyntax {
    Token dotStar;

    WildcardPortConnectionSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token dotStar) :
        PortConnectionSyntax(SyntaxKind::WildcardPortConnection, attributes), dotStar(dotStar)
    {
        childCount += 1;
    }

    WildcardPortConnectionSyntax(const WildcardPortConnectionSyntax&) = delete;
    WildcardPortConnectionSyntax& operator=(const WildcardPortConnectionSyntax&) = delete;

    static const WildcardPortConnectionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return dotStar;
            default: return nullptr;
        }
    }
};

struct HierarchicalInstanceSyntax : public SyntaxNode {
    Token name;
    SyntaxList<VariableDimensionSyntax> dimensions;
    Token openParen;
    SeparatedSyntaxList<PortConnectionSyntax> connections;
    Token closeParen;

    HierarchicalInstanceSyntax(Token name, SyntaxList<VariableDimensionSyntax> dimensions, Token openParen, SeparatedSyntaxList<PortConnectionSyntax> connections, Token closeParen) :
        SyntaxNode(SyntaxKind::HierarchicalInstance), name(name), dimensions(dimensions), openParen(openParen), connections(connections), closeParen(closeParen)
    {
        childCount += 5;
    }

    HierarchicalInstanceSyntax(const HierarchicalInstanceSyntax&) = delete;
    HierarchicalInstanceSyntax& operator=(const HierarchicalInstanceSyntax&) = delete;

    static const HierarchicalInstanceSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return name;
            case 1: return &dimensions;
            case 2: return openParen;
            case 3: return &connections;
            case 4: return closeParen;
            default: return nullptr;
        }
    }
};

struct HierarchyInstantiationSyntax : public MemberSyntax {
    Token type;
    ParameterValueAssignmentSyntax* parameters;
    SeparatedSyntaxList<HierarchicalInstanceSyntax> instances;
    Token semi;

    HierarchyInstantiationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token type, ParameterValueAssignmentSyntax* parameters, SeparatedSyntaxList<HierarchicalInstanceSyntax> instances, Token semi) :
        MemberSyntax(SyntaxKind::HierarchyInstantiation, attributes), type(type), parameters(parameters), instances(instances), semi(semi)
    {
        childCount += 4;
    }

    HierarchyInstantiationSyntax(const HierarchyInstantiationSyntax&) = delete;
    HierarchyInstantiationSyntax& operator=(const HierarchyInstantiationSyntax&) = delete;

    static const HierarchyInstantiationSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return type;
            case 2: return parameters;
            case 3: return &instances;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct FunctionPortSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;
    Token constKeyword;
    Token direction;
    Token varKeyword;
    DataTypeSyntax* dataType;
    VariableDeclaratorSyntax& declarator;

    FunctionPortSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token constKeyword, Token direction, Token varKeyword, DataTypeSyntax* dataType, VariableDeclaratorSyntax& declarator) :
        SyntaxNode(SyntaxKind::FunctionPort), attributes(attributes), constKeyword(constKeyword), direction(direction), varKeyword(varKeyword), dataType(dataType), declarator(declarator)
    {
        childCount += 6;
    }

    FunctionPortSyntax(const FunctionPortSyntax&) = delete;
    FunctionPortSyntax& operator=(const FunctionPortSyntax&) = delete;

    static const FunctionPortSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return constKeyword;
            case 2: return direction;
            case 3: return varKeyword;
            case 4: return dataType;
            case 5: return &declarator;
            default: return nullptr;
        }
    }
};

struct FunctionPortListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<FunctionPortSyntax> ports;
    Token closeParen;

    FunctionPortListSyntax(Token openParen, SeparatedSyntaxList<FunctionPortSyntax> ports, Token closeParen) :
        SyntaxNode(SyntaxKind::FunctionPortList), openParen(openParen), ports(ports), closeParen(closeParen)
    {
        childCount += 3;
    }

    FunctionPortListSyntax(const FunctionPortListSyntax&) = delete;
    FunctionPortListSyntax& operator=(const FunctionPortListSyntax&) = delete;

    static const FunctionPortListSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &ports;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct FunctionPrototypeSyntax : public SyntaxNode {
    Token keyword;
    Token lifetime;
    DataTypeSyntax* returnType;
    NameSyntax& name;
    FunctionPortListSyntax* portList;
    Token semi;

    FunctionPrototypeSyntax(Token keyword, Token lifetime, DataTypeSyntax* returnType, NameSyntax& name, FunctionPortListSyntax* portList, Token semi) :
        SyntaxNode(SyntaxKind::FunctionPrototype), keyword(keyword), lifetime(lifetime), returnType(returnType), name(name), portList(portList), semi(semi)
    {
        childCount += 6;
    }

    FunctionPrototypeSyntax(const FunctionPrototypeSyntax&) = delete;
    FunctionPrototypeSyntax& operator=(const FunctionPrototypeSyntax&) = delete;

    static const FunctionPrototypeSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return keyword;
            case 1: return lifetime;
            case 2: return returnType;
            case 3: return &name;
            case 4: return portList;
            case 5: return semi;
            default: return nullptr;
        }
    }
};

struct FunctionDeclarationSyntax : public MemberSyntax {
    FunctionPrototypeSyntax& prototype;
    SyntaxList<SyntaxNode> items;
    Token end;
    NamedBlockClauseSyntax* endBlockName;

    FunctionDeclarationSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes, FunctionPrototypeSyntax& prototype, SyntaxList<SyntaxNode> items, Token end, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(kind, attributes), prototype(prototype), items(items), end(end), endBlockName(endBlockName)
    {
        childCount += 4;
    }

    FunctionDeclarationSyntax(const FunctionDeclarationSyntax&) = delete;
    FunctionDeclarationSyntax& operator=(const FunctionDeclarationSyntax&) = delete;

    static const FunctionDeclarationSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &prototype;
            case 2: return &items;
            case 3: return end;
            case 4: return endBlockName;
            default: return nullptr;
        }
    }
};

struct AssertionItemPortSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;
    Token local;
    Token direction;
    DataTypeSyntax& type;
    VariableDeclaratorSyntax& declarator;

    AssertionItemPortSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token local, Token direction, DataTypeSyntax& type, VariableDeclaratorSyntax& declarator) :
        SyntaxNode(SyntaxKind::AssertionItemPort), attributes(attributes), local(local), direction(direction), type(type), declarator(declarator)
    {
        childCount += 5;
    }

    AssertionItemPortSyntax(const AssertionItemPortSyntax&) = delete;
    AssertionItemPortSyntax& operator=(const AssertionItemPortSyntax&) = delete;

    static const AssertionItemPortSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return local;
            case 2: return direction;
            case 3: return &type;
            case 4: return &declarator;
            default: return nullptr;
        }
    }
};

struct AssertionItemPortListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<AssertionItemPortSyntax> ports;
    Token closeParen;

    AssertionItemPortListSyntax(Token openParen, SeparatedSyntaxList<AssertionItemPortSyntax> ports, Token closeParen) :
        SyntaxNode(SyntaxKind::AssertionItemPortList), openParen(openParen), ports(ports), closeParen(closeParen)
    {
        childCount += 3;
    }

    AssertionItemPortListSyntax(const AssertionItemPortListSyntax&) = delete;
    AssertionItemPortListSyntax& operator=(const AssertionItemPortListSyntax&) = delete;

    static const AssertionItemPortListSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &ports;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct LetDeclarationSyntax : public MemberSyntax {
    Token let;
    Token identifier;
    AssertionItemPortListSyntax* portList;
    EqualsValueClauseSyntax& initializer;
    Token semi;

    LetDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token let, Token identifier, AssertionItemPortListSyntax* portList, EqualsValueClauseSyntax& initializer, Token semi) :
        MemberSyntax(SyntaxKind::LetDeclaration, attributes), let(let), identifier(identifier), portList(portList), initializer(initializer), semi(semi)
    {
        childCount += 5;
    }

    LetDeclarationSyntax(const LetDeclarationSyntax&) = delete;
    LetDeclarationSyntax& operator=(const LetDeclarationSyntax&) = delete;

    static const LetDeclarationSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return let;
            case 2: return identifier;
            case 3: return portList;
            case 4: return &initializer;
            case 5: return semi;
            default: return nullptr;
        }
    }
};

struct PropertySequenceDeclarationSyntax : public MemberSyntax {
    Token start;
    Token name;
    AssertionItemPortListSyntax* portList;
    Token semi;
    SyntaxList<DataDeclarationSyntax> assertionVariables;
    PropertySpecSyntax* propertySpec;
    ExpressionSyntax* seqExpr;
    Token optionalSemi;
    Token end;
    NamedBlockClauseSyntax* endBlockName;

    PropertySequenceDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token start, Token name, AssertionItemPortListSyntax* portList, Token semi, SyntaxList<DataDeclarationSyntax> assertionVariables, PropertySpecSyntax* propertySpec, ExpressionSyntax* seqExpr, Token optionalSemi, Token end, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(SyntaxKind::PropertySequenceDeclaration, attributes), start(start), name(name), portList(portList), semi(semi), assertionVariables(assertionVariables), propertySpec(propertySpec), seqExpr(seqExpr), optionalSemi(optionalSemi), end(end), endBlockName(endBlockName)
    {
        childCount += 10;
    }

    PropertySequenceDeclarationSyntax(const PropertySequenceDeclarationSyntax&) = delete;
    PropertySequenceDeclarationSyntax& operator=(const PropertySequenceDeclarationSyntax&) = delete;

    static const PropertySequenceDeclarationSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return start;
            case 2: return name;
            case 3: return portList;
            case 4: return semi;
            case 5: return &assertionVariables;
            case 6: return propertySpec;
            case 7: return seqExpr;
            case 8: return optionalSemi;
            case 9: return end;
            case 10: return endBlockName;
            default: return nullptr;
        }
    }
};

struct ExtendsClauseSyntax : public SyntaxNode {
    Token keyword;
    NameSyntax& baseName;
    ArgumentListSyntax* arguments;

    ExtendsClauseSyntax(Token keyword, NameSyntax& baseName, ArgumentListSyntax* arguments) :
        SyntaxNode(SyntaxKind::ExtendsClause), keyword(keyword), baseName(baseName), arguments(arguments)
    {
        childCount += 3;
    }

    ExtendsClauseSyntax(const ExtendsClauseSyntax&) = delete;
    ExtendsClauseSyntax& operator=(const ExtendsClauseSyntax&) = delete;

    static const ExtendsClauseSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return keyword;
            case 1: return &baseName;
            case 2: return arguments;
            default: return nullptr;
        }
    }
};

struct ImplementsClauseSyntax : public SyntaxNode {
    Token keyword;
    SeparatedSyntaxList<NameSyntax> interfaces;

    ImplementsClauseSyntax(Token keyword, SeparatedSyntaxList<NameSyntax> interfaces) :
        SyntaxNode(SyntaxKind::ImplementsClause), keyword(keyword), interfaces(interfaces)
    {
        childCount += 2;
    }

    ImplementsClauseSyntax(const ImplementsClauseSyntax&) = delete;
    ImplementsClauseSyntax& operator=(const ImplementsClauseSyntax&) = delete;

    static const ImplementsClauseSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return keyword;
            case 1: return &interfaces;
            default: return nullptr;
        }
    }
};

struct ClassDeclarationSyntax : public MemberSyntax {
    Token virtualOrInterface;
    Token classKeyword;
    Token lifetime;
    Token name;
    ParameterPortListSyntax* parameters;
    ExtendsClauseSyntax* extendsClause;
    ImplementsClauseSyntax* implementsClause;
    Token semi;
    SyntaxList<MemberSyntax> items;
    Token endClass;
    NamedBlockClauseSyntax* endBlockName;

    ClassDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token virtualOrInterface, Token classKeyword, Token lifetime, Token name, ParameterPortListSyntax* parameters, ExtendsClauseSyntax* extendsClause, ImplementsClauseSyntax* implementsClause, Token semi, SyntaxList<MemberSyntax> items, Token endClass, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(SyntaxKind::ClassDeclaration, attributes), virtualOrInterface(virtualOrInterface), classKeyword(classKeyword), lifetime(lifetime), name(name), parameters(parameters), extendsClause(extendsClause), implementsClause(implementsClause), semi(semi), items(items), endClass(endClass), endBlockName(endBlockName)
    {
        childCount += 11;
    }

    ClassDeclarationSyntax(const ClassDeclarationSyntax&) = delete;
    ClassDeclarationSyntax& operator=(const ClassDeclarationSyntax&) = delete;

    static const ClassDeclarationSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return virtualOrInterface;
            case 2: return classKeyword;
            case 3: return lifetime;
            case 4: return name;
            case 5: return parameters;
            case 6: return extendsClause;
            case 7: return implementsClause;
            case 8: return semi;
            case 9: return &items;
            case 10: return endClass;
            case 11: return endBlockName;
            default: return nullptr;
        }
    }
};

struct ClassPropertyDeclarationSyntax : public MemberSyntax {
    TokenList qualifiers;
    MemberSyntax& declaration;

    ClassPropertyDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, MemberSyntax& declaration) :
        MemberSyntax(SyntaxKind::ClassPropertyDeclaration, attributes), qualifiers(qualifiers), declaration(declaration)
    {
        childCount += 2;
    }

    ClassPropertyDeclarationSyntax(const ClassPropertyDeclarationSyntax&) = delete;
    ClassPropertyDeclarationSyntax& operator=(const ClassPropertyDeclarationSyntax&) = delete;

    static const ClassPropertyDeclarationSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &qualifiers;
            case 2: return &declaration;
            default: return nullptr;
        }
    }
};

struct ClassMethodDeclarationSyntax : public MemberSyntax {
    TokenList qualifiers;
    FunctionDeclarationSyntax& declaration;

    ClassMethodDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, FunctionDeclarationSyntax& declaration) :
        MemberSyntax(SyntaxKind::ClassMethodDeclaration, attributes), qualifiers(qualifiers), declaration(declaration)
    {
        childCount += 2;
    }

    ClassMethodDeclarationSyntax(const ClassMethodDeclarationSyntax&) = delete;
    ClassMethodDeclarationSyntax& operator=(const ClassMethodDeclarationSyntax&) = delete;

    static const ClassMethodDeclarationSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &qualifiers;
            case 2: return &declaration;
            default: return nullptr;
        }
    }
};

struct ClassMethodPrototypeSyntax : public MemberSyntax {
    TokenList qualifiers;
    FunctionPrototypeSyntax& prototype;

    ClassMethodPrototypeSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, FunctionPrototypeSyntax& prototype) :
        MemberSyntax(SyntaxKind::ClassMethodPrototype, attributes), qualifiers(qualifiers), prototype(prototype)
    {
        childCount += 2;
    }

    ClassMethodPrototypeSyntax(const ClassMethodPrototypeSyntax&) = delete;
    ClassMethodPrototypeSyntax& operator=(const ClassMethodPrototypeSyntax&) = delete;

    static const ClassMethodPrototypeSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &qualifiers;
            case 2: return &prototype;
            default: return nullptr;
        }
    }
};

struct ContinuousAssignSyntax : public MemberSyntax {
    Token assign;
    SeparatedSyntaxList<ExpressionSyntax> assignments;
    Token semi;

    ContinuousAssignSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token assign, SeparatedSyntaxList<ExpressionSyntax> assignments, Token semi) :
        MemberSyntax(SyntaxKind::ContinuousAssign, attributes), assign(assign), assignments(assignments), semi(semi)
    {
        childCount += 3;
    }

    ContinuousAssignSyntax(const ContinuousAssignSyntax&) = delete;
    ContinuousAssignSyntax& operator=(const ContinuousAssignSyntax&) = delete;

    static const ContinuousAssignSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return assign;
            case 2: return &assignments;
            case 3: return semi;
            default: return nullptr;
        }
    }
};

struct DefParamAssignmentSyntax : public SyntaxNode {
    NameSyntax& name;
    EqualsValueClauseSyntax* setter;

    DefParamAssignmentSyntax(NameSyntax& name, EqualsValueClauseSyntax* setter) :
        SyntaxNode(SyntaxKind::DefParamAssignment), name(name), setter(setter)
    {
        childCount += 2;
    }

    DefParamAssignmentSyntax(const DefParamAssignmentSyntax&) = delete;
    DefParamAssignmentSyntax& operator=(const DefParamAssignmentSyntax&) = delete;

    static const DefParamAssignmentSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &name;
            case 1: return setter;
            default: return nullptr;
        }
    }
};

struct DefParamSyntax : public MemberSyntax {
    Token defparam;
    SeparatedSyntaxList<DefParamAssignmentSyntax> assignments;
    Token semi;

    DefParamSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token defparam, SeparatedSyntaxList<DefParamAssignmentSyntax> assignments, Token semi) :
        MemberSyntax(SyntaxKind::DefParam, attributes), defparam(defparam), assignments(assignments), semi(semi)
    {
        childCount += 3;
    }

    DefParamSyntax(const DefParamSyntax&) = delete;
    DefParamSyntax& operator=(const DefParamSyntax&) = delete;

    static const DefParamSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return defparam;
            case 2: return &assignments;
            case 3: return semi;
            default: return nullptr;
        }
    }
};

struct ModportItemSyntax : public SyntaxNode {
    Token name;
    AnsiPortListSyntax& ports;

    ModportItemSyntax(Token name, AnsiPortListSyntax& ports) :
        SyntaxNode(SyntaxKind::ModportItem), name(name), ports(ports)
    {
        childCount += 2;
    }

    ModportItemSyntax(const ModportItemSyntax&) = delete;
    ModportItemSyntax& operator=(const ModportItemSyntax&) = delete;

    static const ModportItemSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return name;
            case 1: return &ports;
            default: return nullptr;
        }
    }
};

struct ModportDeclarationSyntax : public MemberSyntax {
    Token keyword;
    SeparatedSyntaxList<ModportItemSyntax> items;
    Token semi;

    ModportDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, SeparatedSyntaxList<ModportItemSyntax> items, Token semi) :
        MemberSyntax(SyntaxKind::ModportDeclaration, attributes), keyword(keyword), items(items), semi(semi)
    {
        childCount += 3;
    }

    ModportDeclarationSyntax(const ModportDeclarationSyntax&) = delete;
    ModportDeclarationSyntax& operator=(const ModportDeclarationSyntax&) = delete;

    static const ModportDeclarationSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return &items;
            case 3: return semi;
            default: return nullptr;
        }
    }
};

struct ClockingSkewSyntax : public SyntaxNode {
    Token edge;
    Token hash;
    ExpressionSyntax* value;

    ClockingSkewSyntax(Token edge, Token hash, ExpressionSyntax* value) :
        SyntaxNode(SyntaxKind::ClockingSkew), edge(edge), hash(hash), value(value)
    {
        childCount += 3;
    }

    ClockingSkewSyntax(const ClockingSkewSyntax&) = delete;
    ClockingSkewSyntax& operator=(const ClockingSkewSyntax&) = delete;

    static const ClockingSkewSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return edge;
            case 1: return hash;
            case 2: return value;
            default: return nullptr;
        }
    }
};

struct ClockingDirectionSyntax : public SyntaxNode {
    Token input;
    ClockingSkewSyntax* inputSkew;
    Token output;
    ClockingSkewSyntax* ouputSkew;
    Token inout;

    ClockingDirectionSyntax(Token input, ClockingSkewSyntax* inputSkew, Token output, ClockingSkewSyntax* ouputSkew, Token inout) :
        SyntaxNode(SyntaxKind::ClockingDirection), input(input), inputSkew(inputSkew), output(output), ouputSkew(ouputSkew), inout(inout)
    {
        childCount += 5;
    }

    ClockingDirectionSyntax(const ClockingDirectionSyntax&) = delete;
    ClockingDirectionSyntax& operator=(const ClockingDirectionSyntax&) = delete;

    static const ClockingDirectionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return input;
            case 1: return inputSkew;
            case 2: return output;
            case 3: return ouputSkew;
            case 4: return inout;
            default: return nullptr;
        }
    }
};

struct ClockingItemSyntax : public SyntaxNode {
    Token defaultKeyword;
    ClockingDirectionSyntax* direction;
    SeparatedSyntaxList<AttributeSpecSyntax> assignments;
    Token semi;
    MemberSyntax* declaration;

    ClockingItemSyntax(Token defaultKeyword, ClockingDirectionSyntax* direction, SeparatedSyntaxList<AttributeSpecSyntax> assignments, Token semi, MemberSyntax* declaration) :
        SyntaxNode(SyntaxKind::ClockingItem), defaultKeyword(defaultKeyword), direction(direction), assignments(assignments), semi(semi), declaration(declaration)
    {
        childCount += 5;
    }

    ClockingItemSyntax(const ClockingItemSyntax&) = delete;
    ClockingItemSyntax& operator=(const ClockingItemSyntax&) = delete;

    static const ClockingItemSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return defaultKeyword;
            case 1: return direction;
            case 2: return &assignments;
            case 3: return semi;
            case 4: return declaration;
            default: return nullptr;
        }
    }
};

struct ClockingDeclarationSyntax : public MemberSyntax {
    Token globalOrDefault;
    Token clocking;
    Token blockName;
    Token at;
    ParenthesizedEventExpressionSyntax* event;
    Token eventIdentifier;
    Token semi;
    SyntaxList<ClockingItemSyntax> items;
    Token endClocking;
    NamedBlockClauseSyntax* endBlockName;

    ClockingDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token globalOrDefault, Token clocking, Token blockName, Token at, ParenthesizedEventExpressionSyntax* event, Token eventIdentifier, Token semi, SyntaxList<ClockingItemSyntax> items, Token endClocking, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(SyntaxKind::ClockingDeclaration, attributes), globalOrDefault(globalOrDefault), clocking(clocking), blockName(blockName), at(at), event(event), eventIdentifier(eventIdentifier), semi(semi), items(items), endClocking(endClocking), endBlockName(endBlockName)
    {
        childCount += 10;
    }

    ClockingDeclarationSyntax(const ClockingDeclarationSyntax&) = delete;
    ClockingDeclarationSyntax& operator=(const ClockingDeclarationSyntax&) = delete;

    static const ClockingDeclarationSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return globalOrDefault;
            case 2: return clocking;
            case 3: return blockName;
            case 4: return at;
            case 5: return event;
            case 6: return eventIdentifier;
            case 7: return semi;
            case 8: return &items;
            case 9: return endClocking;
            case 10: return endBlockName;
            default: return nullptr;
        }
    }
};

struct DPIImportExportSyntax : public MemberSyntax {
    Token keyword;
    Token stringLiteral;
    Token property;
    Token name;
    Token equals;
    FunctionPrototypeSyntax& method;

    DPIImportExportSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token stringLiteral, Token property, Token name, Token equals, FunctionPrototypeSyntax& method) :
        MemberSyntax(SyntaxKind::DPIImportExport, attributes), keyword(keyword), stringLiteral(stringLiteral), property(property), name(name), equals(equals), method(method)
    {
        childCount += 6;
    }

    DPIImportExportSyntax(const DPIImportExportSyntax&) = delete;
    DPIImportExportSyntax& operator=(const DPIImportExportSyntax&) = delete;

    static const DPIImportExportSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return stringLiteral;
            case 3: return property;
            case 4: return name;
            case 5: return equals;
            case 6: return &method;
            default: return nullptr;
        }
    }
};

// ----- CONSTRAINTS -----

struct ConstraintItemSyntax : public SyntaxNode {

    ConstraintItemSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct DistWeightSyntax : public SyntaxNode {
    Token op;
    ExpressionSyntax& expr;

    DistWeightSyntax(Token op, ExpressionSyntax& expr) :
        SyntaxNode(SyntaxKind::DistWeight), op(op), expr(expr)
    {
        childCount += 2;
    }

    DistWeightSyntax(const DistWeightSyntax&) = delete;
    DistWeightSyntax& operator=(const DistWeightSyntax&) = delete;

    static const DistWeightSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return op;
            case 1: return &expr;
            default: return nullptr;
        }
    }
};

struct DistItemSyntax : public SyntaxNode {
    ExpressionSyntax& range;
    DistWeightSyntax* weight;

    DistItemSyntax(ExpressionSyntax& range, DistWeightSyntax* weight) :
        SyntaxNode(SyntaxKind::DistItem), range(range), weight(weight)
    {
        childCount += 2;
    }

    DistItemSyntax(const DistItemSyntax&) = delete;
    DistItemSyntax& operator=(const DistItemSyntax&) = delete;

    static const DistItemSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &range;
            case 1: return weight;
            default: return nullptr;
        }
    }
};

struct DistConstraintListSyntax : public SyntaxNode {
    Token dist;
    Token openBrace;
    SeparatedSyntaxList<DistItemSyntax> items;
    Token closeBrace;

    DistConstraintListSyntax(Token dist, Token openBrace, SeparatedSyntaxList<DistItemSyntax> items, Token closeBrace) :
        SyntaxNode(SyntaxKind::DistConstraintList), dist(dist), openBrace(openBrace), items(items), closeBrace(closeBrace)
    {
        childCount += 4;
    }

    DistConstraintListSyntax(const DistConstraintListSyntax&) = delete;
    DistConstraintListSyntax& operator=(const DistConstraintListSyntax&) = delete;

    static const DistConstraintListSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return dist;
            case 1: return openBrace;
            case 2: return &items;
            case 3: return closeBrace;
            default: return nullptr;
        }
    }
};

struct ExpressionOrDistSyntax : public ExpressionSyntax {
    ExpressionSyntax& expr;
    DistConstraintListSyntax& distribution;

    ExpressionOrDistSyntax(ExpressionSyntax& expr, DistConstraintListSyntax& distribution) :
        ExpressionSyntax(SyntaxKind::ExpressionOrDist), expr(expr), distribution(distribution)
    {
        childCount += 2;
    }

    ExpressionOrDistSyntax(const ExpressionOrDistSyntax&) = delete;
    ExpressionOrDistSyntax& operator=(const ExpressionOrDistSyntax&) = delete;

    static const ExpressionOrDistSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &expr;
            case 1: return &distribution;
            default: return nullptr;
        }
    }
};

struct ExpressionConstraintSyntax : public ConstraintItemSyntax {
    Token soft;
    ExpressionSyntax& expr;
    Token semi;

    ExpressionConstraintSyntax(Token soft, ExpressionSyntax& expr, Token semi) :
        ConstraintItemSyntax(SyntaxKind::ExpressionConstraint), soft(soft), expr(expr), semi(semi)
    {
        childCount += 3;
    }

    ExpressionConstraintSyntax(const ExpressionConstraintSyntax&) = delete;
    ExpressionConstraintSyntax& operator=(const ExpressionConstraintSyntax&) = delete;

    static const ExpressionConstraintSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return soft;
            case 1: return &expr;
            case 2: return semi;
            default: return nullptr;
        }
    }
};

struct UniquenessConstraintSyntax : public ConstraintItemSyntax {
    Token unique;
    OpenRangeListSyntax& ranges;
    Token semi;

    UniquenessConstraintSyntax(Token unique, OpenRangeListSyntax& ranges, Token semi) :
        ConstraintItemSyntax(SyntaxKind::UniquenessConstraint), unique(unique), ranges(ranges), semi(semi)
    {
        childCount += 3;
    }

    UniquenessConstraintSyntax(const UniquenessConstraintSyntax&) = delete;
    UniquenessConstraintSyntax& operator=(const UniquenessConstraintSyntax&) = delete;

    static const UniquenessConstraintSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return unique;
            case 1: return &ranges;
            case 2: return semi;
            default: return nullptr;
        }
    }
};

struct ImplicationConstraintSyntax : public ConstraintItemSyntax {
    ExpressionSyntax& left;
    Token arrow;
    ConstraintItemSyntax& constraints;

    ImplicationConstraintSyntax(ExpressionSyntax& left, Token arrow, ConstraintItemSyntax& constraints) :
        ConstraintItemSyntax(SyntaxKind::ImplicationConstraint), left(left), arrow(arrow), constraints(constraints)
    {
        childCount += 3;
    }

    ImplicationConstraintSyntax(const ImplicationConstraintSyntax&) = delete;
    ImplicationConstraintSyntax& operator=(const ImplicationConstraintSyntax&) = delete;

    static const ImplicationConstraintSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &left;
            case 1: return arrow;
            case 2: return &constraints;
            default: return nullptr;
        }
    }
};

struct ElseConstraintClauseSyntax : public SyntaxNode {
    Token elseKeyword;
    ConstraintItemSyntax& constraints;

    ElseConstraintClauseSyntax(Token elseKeyword, ConstraintItemSyntax& constraints) :
        SyntaxNode(SyntaxKind::ElseConstraintClause), elseKeyword(elseKeyword), constraints(constraints)
    {
        childCount += 2;
    }

    ElseConstraintClauseSyntax(const ElseConstraintClauseSyntax&) = delete;
    ElseConstraintClauseSyntax& operator=(const ElseConstraintClauseSyntax&) = delete;

    static const ElseConstraintClauseSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return elseKeyword;
            case 1: return &constraints;
            default: return nullptr;
        }
    }
};

struct ConditionalConstraintSyntax : public ConstraintItemSyntax {
    Token ifKeyword;
    Token openParen;
    ExpressionSyntax& condition;
    Token closeParen;
    ConstraintItemSyntax& constraints;
    ElseConstraintClauseSyntax* elseClause;

    ConditionalConstraintSyntax(Token ifKeyword, Token openParen, ExpressionSyntax& condition, Token closeParen, ConstraintItemSyntax& constraints, ElseConstraintClauseSyntax* elseClause) :
        ConstraintItemSyntax(SyntaxKind::ConditionalConstraint), ifKeyword(ifKeyword), openParen(openParen), condition(condition), closeParen(closeParen), constraints(constraints), elseClause(elseClause)
    {
        childCount += 6;
    }

    ConditionalConstraintSyntax(const ConditionalConstraintSyntax&) = delete;
    ConditionalConstraintSyntax& operator=(const ConditionalConstraintSyntax&) = delete;

    static const ConditionalConstraintSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return ifKeyword;
            case 1: return openParen;
            case 2: return &condition;
            case 3: return closeParen;
            case 4: return &constraints;
            case 5: return elseClause;
            default: return nullptr;
        }
    }
};

struct LoopConstraintSyntax : public ConstraintItemSyntax {
    Token foreachKeyword;
    ForeachLoopListSyntax& loopList;
    ConstraintItemSyntax& constraints;

    LoopConstraintSyntax(Token foreachKeyword, ForeachLoopListSyntax& loopList, ConstraintItemSyntax& constraints) :
        ConstraintItemSyntax(SyntaxKind::LoopConstraint), foreachKeyword(foreachKeyword), loopList(loopList), constraints(constraints)
    {
        childCount += 3;
    }

    LoopConstraintSyntax(const LoopConstraintSyntax&) = delete;
    LoopConstraintSyntax& operator=(const LoopConstraintSyntax&) = delete;

    static const LoopConstraintSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return foreachKeyword;
            case 1: return &loopList;
            case 2: return &constraints;
            default: return nullptr;
        }
    }
};

struct DisableConstraintSyntax : public ConstraintItemSyntax {
    Token disable;
    Token soft;
    NameSyntax& name;
    Token semi;

    DisableConstraintSyntax(Token disable, Token soft, NameSyntax& name, Token semi) :
        ConstraintItemSyntax(SyntaxKind::DisableConstraint), disable(disable), soft(soft), name(name), semi(semi)
    {
        childCount += 4;
    }

    DisableConstraintSyntax(const DisableConstraintSyntax&) = delete;
    DisableConstraintSyntax& operator=(const DisableConstraintSyntax&) = delete;

    static const DisableConstraintSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return disable;
            case 1: return soft;
            case 2: return &name;
            case 3: return semi;
            default: return nullptr;
        }
    }
};

struct SolveBeforeConstraintSyntax : public ConstraintItemSyntax {
    Token solve;
    SeparatedSyntaxList<ExpressionSyntax> beforeExpr;
    Token before;
    SeparatedSyntaxList<ExpressionSyntax> afterExpr;
    Token semi;

    SolveBeforeConstraintSyntax(Token solve, SeparatedSyntaxList<ExpressionSyntax> beforeExpr, Token before, SeparatedSyntaxList<ExpressionSyntax> afterExpr, Token semi) :
        ConstraintItemSyntax(SyntaxKind::SolveBeforeConstraint), solve(solve), beforeExpr(beforeExpr), before(before), afterExpr(afterExpr), semi(semi)
    {
        childCount += 5;
    }

    SolveBeforeConstraintSyntax(const SolveBeforeConstraintSyntax&) = delete;
    SolveBeforeConstraintSyntax& operator=(const SolveBeforeConstraintSyntax&) = delete;

    static const SolveBeforeConstraintSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return solve;
            case 1: return &beforeExpr;
            case 2: return before;
            case 3: return &afterExpr;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct ConstraintBlockSyntax : public ConstraintItemSyntax {
    Token openBrace;
    SyntaxList<ConstraintItemSyntax> items;
    Token closeBrace;

    ConstraintBlockSyntax(Token openBrace, SyntaxList<ConstraintItemSyntax> items, Token closeBrace) :
        ConstraintItemSyntax(SyntaxKind::ConstraintBlock), openBrace(openBrace), items(items), closeBrace(closeBrace)
    {
        childCount += 3;
    }

    ConstraintBlockSyntax(const ConstraintBlockSyntax&) = delete;
    ConstraintBlockSyntax& operator=(const ConstraintBlockSyntax&) = delete;

    static const ConstraintBlockSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return &items;
            case 2: return closeBrace;
            default: return nullptr;
        }
    }
};

struct ConstraintPrototypeSyntax : public MemberSyntax {
    TokenList qualifiers;
    Token keyword;
    Token name;
    Token semi;

    ConstraintPrototypeSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, Token keyword, Token name, Token semi) :
        MemberSyntax(SyntaxKind::ConstraintPrototype, attributes), qualifiers(qualifiers), keyword(keyword), name(name), semi(semi)
    {
        childCount += 4;
    }

    ConstraintPrototypeSyntax(const ConstraintPrototypeSyntax&) = delete;
    ConstraintPrototypeSyntax& operator=(const ConstraintPrototypeSyntax&) = delete;

    static const ConstraintPrototypeSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &qualifiers;
            case 2: return keyword;
            case 3: return name;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct ConstraintDeclarationSyntax : public MemberSyntax {
    TokenList qualifiers;
    Token keyword;
    Token name;
    ConstraintBlockSyntax& block;

    ConstraintDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, Token keyword, Token name, ConstraintBlockSyntax& block) :
        MemberSyntax(SyntaxKind::ConstraintDeclaration, attributes), qualifiers(qualifiers), keyword(keyword), name(name), block(block)
    {
        childCount += 4;
    }

    ConstraintDeclarationSyntax(const ConstraintDeclarationSyntax&) = delete;
    ConstraintDeclarationSyntax& operator=(const ConstraintDeclarationSyntax&) = delete;

    static const ConstraintDeclarationSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &qualifiers;
            case 2: return keyword;
            case 3: return name;
            case 4: return &block;
            default: return nullptr;
        }
    }
};

struct WithClauseSyntax : public ExpressionSyntax {
    Token with;
    Token openParen;
    ExpressionSyntax& expr;
    Token closeParen;

    WithClauseSyntax(Token with, Token openParen, ExpressionSyntax& expr, Token closeParen) :
        ExpressionSyntax(SyntaxKind::WithClause), with(with), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 4;
    }

    WithClauseSyntax(const WithClauseSyntax&) = delete;
    WithClauseSyntax& operator=(const WithClauseSyntax&) = delete;

    static const WithClauseSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return with;
            case 1: return openParen;
            case 2: return &expr;
            case 3: return closeParen;
            default: return nullptr;
        }
    }
};

struct IdentifierListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<IdentifierNameSyntax> identifiers;
    Token closeParen;

    IdentifierListSyntax(Token openParen, SeparatedSyntaxList<IdentifierNameSyntax> identifiers, Token closeParen) :
        SyntaxNode(SyntaxKind::IdentifierList), openParen(openParen), identifiers(identifiers), closeParen(closeParen)
    {
        childCount += 3;
    }

    IdentifierListSyntax(const IdentifierListSyntax&) = delete;
    IdentifierListSyntax& operator=(const IdentifierListSyntax&) = delete;

    static const IdentifierListSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &identifiers;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct RandomizeMethodWithClauseSyntax : public ExpressionSyntax {
    Token with;
    IdentifierListSyntax* names;
    ConstraintBlockSyntax& constraints;

    RandomizeMethodWithClauseSyntax(Token with, IdentifierListSyntax* names, ConstraintBlockSyntax& constraints) :
        ExpressionSyntax(SyntaxKind::RandomizeMethodWithClause), with(with), names(names), constraints(constraints)
    {
        childCount += 3;
    }

    RandomizeMethodWithClauseSyntax(const RandomizeMethodWithClauseSyntax&) = delete;
    RandomizeMethodWithClauseSyntax& operator=(const RandomizeMethodWithClauseSyntax&) = delete;

    static const RandomizeMethodWithClauseSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return with;
            case 1: return names;
            case 2: return &constraints;
            default: return nullptr;
        }
    }
};

// ----- COVER GROUPS -----

struct WithFunctionSampleSyntax : public SyntaxNode {
    Token with;
    Token function;
    Token sample;
    AnsiPortListSyntax& portList;

    WithFunctionSampleSyntax(Token with, Token function, Token sample, AnsiPortListSyntax& portList) :
        SyntaxNode(SyntaxKind::WithFunctionSample), with(with), function(function), sample(sample), portList(portList)
    {
        childCount += 4;
    }

    WithFunctionSampleSyntax(const WithFunctionSampleSyntax&) = delete;
    WithFunctionSampleSyntax& operator=(const WithFunctionSampleSyntax&) = delete;

    static const WithFunctionSampleSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return with;
            case 1: return function;
            case 2: return sample;
            case 3: return &portList;
            default: return nullptr;
        }
    }
};

struct BlockEventExpressionSyntax : public SyntaxNode {

    BlockEventExpressionSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct BinaryBlockEventExpressionSyntax : public BlockEventExpressionSyntax {
    BlockEventExpressionSyntax& left;
    Token orKeyword;
    BlockEventExpressionSyntax& right;

    BinaryBlockEventExpressionSyntax(BlockEventExpressionSyntax& left, Token orKeyword, BlockEventExpressionSyntax& right) :
        BlockEventExpressionSyntax(SyntaxKind::BinaryBlockEventExpression), left(left), orKeyword(orKeyword), right(right)
    {
        childCount += 3;
    }

    BinaryBlockEventExpressionSyntax(const BinaryBlockEventExpressionSyntax&) = delete;
    BinaryBlockEventExpressionSyntax& operator=(const BinaryBlockEventExpressionSyntax&) = delete;

    static const BinaryBlockEventExpressionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &left;
            case 1: return orKeyword;
            case 2: return &right;
            default: return nullptr;
        }
    }
};

struct PrimaryBlockEventExpressionSyntax : public BlockEventExpressionSyntax {
    Token keyword;
    NameSyntax& name;

    PrimaryBlockEventExpressionSyntax(Token keyword, NameSyntax& name) :
        BlockEventExpressionSyntax(SyntaxKind::PrimaryBlockEventExpression), keyword(keyword), name(name)
    {
        childCount += 2;
    }

    PrimaryBlockEventExpressionSyntax(const PrimaryBlockEventExpressionSyntax&) = delete;
    PrimaryBlockEventExpressionSyntax& operator=(const PrimaryBlockEventExpressionSyntax&) = delete;

    static const PrimaryBlockEventExpressionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return keyword;
            case 1: return &name;
            default: return nullptr;
        }
    }
};

struct BlockCoverageEventSyntax : public SyntaxNode {
    Token atat;
    Token openParen;
    BlockEventExpressionSyntax& expr;
    Token closeParen;

    BlockCoverageEventSyntax(Token atat, Token openParen, BlockEventExpressionSyntax& expr, Token closeParen) :
        SyntaxNode(SyntaxKind::BlockCoverageEvent), atat(atat), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 4;
    }

    BlockCoverageEventSyntax(const BlockCoverageEventSyntax&) = delete;
    BlockCoverageEventSyntax& operator=(const BlockCoverageEventSyntax&) = delete;

    static const BlockCoverageEventSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return atat;
            case 1: return openParen;
            case 2: return &expr;
            case 3: return closeParen;
            default: return nullptr;
        }
    }
};

struct CovergroupDeclarationSyntax : public MemberSyntax {
    Token covergroup;
    Token name;
    AnsiPortListSyntax* portList;
    SyntaxNode* event;
    Token semi;
    SyntaxList<MemberSyntax> members;
    Token endgroup;
    NamedBlockClauseSyntax* endBlockName;

    CovergroupDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token covergroup, Token name, AnsiPortListSyntax* portList, SyntaxNode* event, Token semi, SyntaxList<MemberSyntax> members, Token endgroup, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(SyntaxKind::CovergroupDeclaration, attributes), covergroup(covergroup), name(name), portList(portList), event(event), semi(semi), members(members), endgroup(endgroup), endBlockName(endBlockName)
    {
        childCount += 8;
    }

    CovergroupDeclarationSyntax(const CovergroupDeclarationSyntax&) = delete;
    CovergroupDeclarationSyntax& operator=(const CovergroupDeclarationSyntax&) = delete;

    static const CovergroupDeclarationSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return covergroup;
            case 2: return name;
            case 3: return portList;
            case 4: return event;
            case 5: return semi;
            case 6: return &members;
            case 7: return endgroup;
            case 8: return endBlockName;
            default: return nullptr;
        }
    }
};

struct CoverageOptionSyntax : public MemberSyntax {
    Token option;
    Token dot;
    Token name;
    Token equals;
    ExpressionSyntax& expr;
    Token semi;

    CoverageOptionSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token option, Token dot, Token name, Token equals, ExpressionSyntax& expr, Token semi) :
        MemberSyntax(SyntaxKind::CoverageOption, attributes), option(option), dot(dot), name(name), equals(equals), expr(expr), semi(semi)
    {
        childCount += 6;
    }

    CoverageOptionSyntax(const CoverageOptionSyntax&) = delete;
    CoverageOptionSyntax& operator=(const CoverageOptionSyntax&) = delete;

    static const CoverageOptionSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return option;
            case 2: return dot;
            case 3: return name;
            case 4: return equals;
            case 5: return &expr;
            case 6: return semi;
            default: return nullptr;
        }
    }
};

struct CoverpointSyntax : public MemberSyntax {
    DataTypeSyntax* type;
    NamedLabelSyntax* label;
    Token coverpoint;
    ExpressionSyntax& expr;
    Token openBrace;
    SyntaxList<MemberSyntax> members;
    Token closeBrace;
    Token emptySemi;

    CoverpointSyntax(SyntaxList<AttributeInstanceSyntax> attributes, DataTypeSyntax* type, NamedLabelSyntax* label, Token coverpoint, ExpressionSyntax& expr, Token openBrace, SyntaxList<MemberSyntax> members, Token closeBrace, Token emptySemi) :
        MemberSyntax(SyntaxKind::Coverpoint, attributes), type(type), label(label), coverpoint(coverpoint), expr(expr), openBrace(openBrace), members(members), closeBrace(closeBrace), emptySemi(emptySemi)
    {
        childCount += 8;
    }

    CoverpointSyntax(const CoverpointSyntax&) = delete;
    CoverpointSyntax& operator=(const CoverpointSyntax&) = delete;

    static const CoverpointSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return type;
            case 2: return label;
            case 3: return coverpoint;
            case 4: return &expr;
            case 5: return openBrace;
            case 6: return &members;
            case 7: return closeBrace;
            case 8: return emptySemi;
            default: return nullptr;
        }
    }
};

struct CoverageBinInitializerSyntax : public SyntaxNode {

    CoverageBinInitializerSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct DefaultCoverageBinInitializerSyntax : public CoverageBinInitializerSyntax {
    Token defaultKeyword;
    Token sequenceKeyword;

    DefaultCoverageBinInitializerSyntax(Token defaultKeyword, Token sequenceKeyword) :
        CoverageBinInitializerSyntax(SyntaxKind::DefaultCoverageBinInitializer), defaultKeyword(defaultKeyword), sequenceKeyword(sequenceKeyword)
    {
        childCount += 2;
    }

    DefaultCoverageBinInitializerSyntax(const DefaultCoverageBinInitializerSyntax&) = delete;
    DefaultCoverageBinInitializerSyntax& operator=(const DefaultCoverageBinInitializerSyntax&) = delete;

    static const DefaultCoverageBinInitializerSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return defaultKeyword;
            case 1: return sequenceKeyword;
            default: return nullptr;
        }
    }
};

struct ExpressionCoverageBinInitializerSyntax : public CoverageBinInitializerSyntax {
    ExpressionSyntax& expr;
    WithClauseSyntax* withClause;

    ExpressionCoverageBinInitializerSyntax(ExpressionSyntax& expr, WithClauseSyntax* withClause) :
        CoverageBinInitializerSyntax(SyntaxKind::ExpressionCoverageBinInitializer), expr(expr), withClause(withClause)
    {
        childCount += 2;
    }

    ExpressionCoverageBinInitializerSyntax(const ExpressionCoverageBinInitializerSyntax&) = delete;
    ExpressionCoverageBinInitializerSyntax& operator=(const ExpressionCoverageBinInitializerSyntax&) = delete;

    static const ExpressionCoverageBinInitializerSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &expr;
            case 1: return withClause;
            default: return nullptr;
        }
    }
};

struct RangeCoverageBinInitializerSyntax : public CoverageBinInitializerSyntax {
    OpenRangeListSyntax& ranges;
    WithClauseSyntax* withClause;

    RangeCoverageBinInitializerSyntax(OpenRangeListSyntax& ranges, WithClauseSyntax* withClause) :
        CoverageBinInitializerSyntax(SyntaxKind::RangeCoverageBinInitializer), ranges(ranges), withClause(withClause)
    {
        childCount += 2;
    }

    RangeCoverageBinInitializerSyntax(const RangeCoverageBinInitializerSyntax&) = delete;
    RangeCoverageBinInitializerSyntax& operator=(const RangeCoverageBinInitializerSyntax&) = delete;

    static const RangeCoverageBinInitializerSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &ranges;
            case 1: return withClause;
            default: return nullptr;
        }
    }
};

struct IffClauseSyntax : public SyntaxNode {
    Token iff;
    Token openParen;
    ExpressionSyntax& expr;
    Token closeParen;

    IffClauseSyntax(Token iff, Token openParen, ExpressionSyntax& expr, Token closeParen) :
        SyntaxNode(SyntaxKind::IffClause), iff(iff), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 4;
    }

    IffClauseSyntax(const IffClauseSyntax&) = delete;
    IffClauseSyntax& operator=(const IffClauseSyntax&) = delete;

    static const IffClauseSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return iff;
            case 1: return openParen;
            case 2: return &expr;
            case 3: return closeParen;
            default: return nullptr;
        }
    }
};

struct CoverageBinsSyntax : public MemberSyntax {
    Token wildcard;
    Token keyword;
    Token name;
    ElementSelectSyntax* selector;
    Token equals;
    CoverageBinInitializerSyntax& initializer;
    IffClauseSyntax* iff;
    Token semi;

    CoverageBinsSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token wildcard, Token keyword, Token name, ElementSelectSyntax* selector, Token equals, CoverageBinInitializerSyntax& initializer, IffClauseSyntax* iff, Token semi) :
        MemberSyntax(SyntaxKind::CoverageBins, attributes), wildcard(wildcard), keyword(keyword), name(name), selector(selector), equals(equals), initializer(initializer), iff(iff), semi(semi)
    {
        childCount += 8;
    }

    CoverageBinsSyntax(const CoverageBinsSyntax&) = delete;
    CoverageBinsSyntax& operator=(const CoverageBinsSyntax&) = delete;

    static const CoverageBinsSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return wildcard;
            case 2: return keyword;
            case 3: return name;
            case 4: return selector;
            case 5: return equals;
            case 6: return &initializer;
            case 7: return iff;
            case 8: return semi;
            default: return nullptr;
        }
    }
};

// ----- TOP LEVEL -----

struct CompilationUnitSyntax : public SyntaxNode {
    SyntaxList<MemberSyntax> members;
    Token endOfFile;

    CompilationUnitSyntax(SyntaxList<MemberSyntax> members, Token endOfFile) :
        SyntaxNode(SyntaxKind::CompilationUnit), members(members), endOfFile(endOfFile)
    {
        childCount += 2;
    }

    CompilationUnitSyntax(const CompilationUnitSyntax&) = delete;
    CompilationUnitSyntax& operator=(const CompilationUnitSyntax&) = delete;

    static const CompilationUnitSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &members;
            case 1: return endOfFile;
            default: return nullptr;
        }
    }
};

// ----- DIRECTIVES -----

struct DirectiveSyntax : public SyntaxNode {
    Token directive;

    DirectiveSyntax(SyntaxKind kind, Token directive) :
        SyntaxNode(kind), directive(directive)
    {
        childCount += 1;
    }

    DirectiveSyntax(const DirectiveSyntax&) = delete;
    DirectiveSyntax& operator=(const DirectiveSyntax&) = delete;

    static const DirectiveSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override {
        switch (index) {
            case 0: return directive;
            default: return nullptr;
        }
    }
};

struct SimpleDirectiveSyntax : public DirectiveSyntax {
    Token endOfDirective;

    SimpleDirectiveSyntax(SyntaxKind kind, Token directive, Token endOfDirective) :
        DirectiveSyntax(kind, directive), endOfDirective(endOfDirective)
    {
        childCount += 1;
    }

    SimpleDirectiveSyntax(const SimpleDirectiveSyntax&) = delete;
    SimpleDirectiveSyntax& operator=(const SimpleDirectiveSyntax&) = delete;

    static const SimpleDirectiveSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return directive;
            case 1: return endOfDirective;
            default: return nullptr;
        }
    }
};

struct IncludeDirectiveSyntax : public DirectiveSyntax {
    Token fileName;
    Token endOfDirective;

    IncludeDirectiveSyntax(Token directive, Token fileName, Token endOfDirective) :
        DirectiveSyntax(SyntaxKind::IncludeDirective, directive), fileName(fileName), endOfDirective(endOfDirective)
    {
        childCount += 2;
    }

    IncludeDirectiveSyntax(const IncludeDirectiveSyntax&) = delete;
    IncludeDirectiveSyntax& operator=(const IncludeDirectiveSyntax&) = delete;

    static const IncludeDirectiveSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return directive;
            case 1: return fileName;
            case 2: return endOfDirective;
            default: return nullptr;
        }
    }
};

struct ConditionalBranchDirectiveSyntax : public DirectiveSyntax {
    Token name;
    Token endOfDirective;
    TokenList disabledTokens;

    ConditionalBranchDirectiveSyntax(SyntaxKind kind, Token directive, Token name, Token endOfDirective, TokenList disabledTokens) :
        DirectiveSyntax(kind, directive), name(name), endOfDirective(endOfDirective), disabledTokens(disabledTokens)
    {
        childCount += 3;
    }

    ConditionalBranchDirectiveSyntax(const ConditionalBranchDirectiveSyntax&) = delete;
    ConditionalBranchDirectiveSyntax& operator=(const ConditionalBranchDirectiveSyntax&) = delete;

    static const ConditionalBranchDirectiveSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return directive;
            case 1: return name;
            case 2: return endOfDirective;
            case 3: return &disabledTokens;
            default: return nullptr;
        }
    }
};

struct UnconditionalBranchDirectiveSyntax : public DirectiveSyntax {
    Token endOfDirective;
    TokenList disabledTokens;

    UnconditionalBranchDirectiveSyntax(SyntaxKind kind, Token directive, Token endOfDirective, TokenList disabledTokens) :
        DirectiveSyntax(kind, directive), endOfDirective(endOfDirective), disabledTokens(disabledTokens)
    {
        childCount += 2;
    }

    UnconditionalBranchDirectiveSyntax(const UnconditionalBranchDirectiveSyntax&) = delete;
    UnconditionalBranchDirectiveSyntax& operator=(const UnconditionalBranchDirectiveSyntax&) = delete;

    static const UnconditionalBranchDirectiveSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return directive;
            case 1: return endOfDirective;
            case 2: return &disabledTokens;
            default: return nullptr;
        }
    }
};

struct MacroArgumentDefaultSyntax : public SyntaxNode {
    Token equals;
    TokenList tokens;

    MacroArgumentDefaultSyntax(Token equals, TokenList tokens) :
        SyntaxNode(SyntaxKind::MacroArgumentDefault), equals(equals), tokens(tokens)
    {
        childCount += 2;
    }

    MacroArgumentDefaultSyntax(const MacroArgumentDefaultSyntax&) = delete;
    MacroArgumentDefaultSyntax& operator=(const MacroArgumentDefaultSyntax&) = delete;

    static const MacroArgumentDefaultSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return equals;
            case 1: return &tokens;
            default: return nullptr;
        }
    }
};

struct MacroFormalArgumentSyntax : public SyntaxNode {
    Token name;
    MacroArgumentDefaultSyntax* defaultValue;

    MacroFormalArgumentSyntax(Token name, MacroArgumentDefaultSyntax* defaultValue) :
        SyntaxNode(SyntaxKind::MacroFormalArgument), name(name), defaultValue(defaultValue)
    {
        childCount += 2;
    }

    MacroFormalArgumentSyntax(const MacroFormalArgumentSyntax&) = delete;
    MacroFormalArgumentSyntax& operator=(const MacroFormalArgumentSyntax&) = delete;

    static const MacroFormalArgumentSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return name;
            case 1: return defaultValue;
            default: return nullptr;
        }
    }
};

struct MacroFormalArgumentListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<MacroFormalArgumentSyntax> args;
    Token closeParen;

    MacroFormalArgumentListSyntax(Token openParen, SeparatedSyntaxList<MacroFormalArgumentSyntax> args, Token closeParen) :
        SyntaxNode(SyntaxKind::MacroFormalArgumentList), openParen(openParen), args(args), closeParen(closeParen)
    {
        childCount += 3;
    }

    MacroFormalArgumentListSyntax(const MacroFormalArgumentListSyntax&) = delete;
    MacroFormalArgumentListSyntax& operator=(const MacroFormalArgumentListSyntax&) = delete;

    static const MacroFormalArgumentListSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &args;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct DefineDirectiveSyntax : public DirectiveSyntax {
    Token name;
    MacroFormalArgumentListSyntax* formalArguments;
    TokenList body;
    Token endOfDirective;

    DefineDirectiveSyntax(Token directive, Token name, MacroFormalArgumentListSyntax* formalArguments, TokenList body, Token endOfDirective) :
        DirectiveSyntax(SyntaxKind::DefineDirective, directive), name(name), formalArguments(formalArguments), body(body), endOfDirective(endOfDirective)
    {
        childCount += 4;
    }

    DefineDirectiveSyntax(const DefineDirectiveSyntax&) = delete;
    DefineDirectiveSyntax& operator=(const DefineDirectiveSyntax&) = delete;

    static const DefineDirectiveSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return directive;
            case 1: return name;
            case 2: return formalArguments;
            case 3: return &body;
            case 4: return endOfDirective;
            default: return nullptr;
        }
    }
};

struct MacroActualArgumentSyntax : public SyntaxNode {
    TokenList tokens;

    MacroActualArgumentSyntax(TokenList tokens) :
        SyntaxNode(SyntaxKind::MacroActualArgument), tokens(tokens)
    {
        childCount += 1;
    }

    MacroActualArgumentSyntax(const MacroActualArgumentSyntax&) = delete;
    MacroActualArgumentSyntax& operator=(const MacroActualArgumentSyntax&) = delete;

    static const MacroActualArgumentSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &tokens;
            default: return nullptr;
        }
    }
};

struct MacroActualArgumentListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<MacroActualArgumentSyntax> args;
    Token closeParen;

    MacroActualArgumentListSyntax(Token openParen, SeparatedSyntaxList<MacroActualArgumentSyntax> args, Token closeParen) :
        SyntaxNode(SyntaxKind::MacroActualArgumentList), openParen(openParen), args(args), closeParen(closeParen)
    {
        childCount += 3;
    }

    MacroActualArgumentListSyntax(const MacroActualArgumentListSyntax&) = delete;
    MacroActualArgumentListSyntax& operator=(const MacroActualArgumentListSyntax&) = delete;

    static const MacroActualArgumentListSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &args;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct MacroUsageSyntax : public DirectiveSyntax {
    MacroActualArgumentListSyntax* args;

    MacroUsageSyntax(Token directive, MacroActualArgumentListSyntax* args) :
        DirectiveSyntax(SyntaxKind::MacroUsage, directive), args(args)
    {
        childCount += 1;
    }

    MacroUsageSyntax(const MacroUsageSyntax&) = delete;
    MacroUsageSyntax& operator=(const MacroUsageSyntax&) = delete;

    static const MacroUsageSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return directive;
            case 1: return args;
            default: return nullptr;
        }
    }
};

struct TimescaleDirectiveSyntax : public DirectiveSyntax {
    Token timeUnit;
    Token timeUnitUnit;
    Token slash;
    Token timePrecision;
    Token timePrecisionUnit;
    Token endOfDirective;

    TimescaleDirectiveSyntax(Token directive, Token timeUnit, Token timeUnitUnit, Token slash, Token timePrecision, Token timePrecisionUnit, Token endOfDirective) :
        DirectiveSyntax(SyntaxKind::TimescaleDirective, directive), timeUnit(timeUnit), timeUnitUnit(timeUnitUnit), slash(slash), timePrecision(timePrecision), timePrecisionUnit(timePrecisionUnit), endOfDirective(endOfDirective)
    {
        childCount += 6;
    }

    TimescaleDirectiveSyntax(const TimescaleDirectiveSyntax&) = delete;
    TimescaleDirectiveSyntax& operator=(const TimescaleDirectiveSyntax&) = delete;

    static const TimescaleDirectiveSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return directive;
            case 1: return timeUnit;
            case 2: return timeUnitUnit;
            case 3: return slash;
            case 4: return timePrecision;
            case 5: return timePrecisionUnit;
            case 6: return endOfDirective;
            default: return nullptr;
        }
    }
};

struct DefaultNetTypeDirectiveSyntax : public DirectiveSyntax {
    Token netType;
    Token endOfDirective;

    DefaultNetTypeDirectiveSyntax(Token directive, Token netType, Token endOfDirective) :
        DirectiveSyntax(SyntaxKind::DefaultNetTypeDirective, directive), netType(netType), endOfDirective(endOfDirective)
    {
        childCount += 2;
    }

    DefaultNetTypeDirectiveSyntax(const DefaultNetTypeDirectiveSyntax&) = delete;
    DefaultNetTypeDirectiveSyntax& operator=(const DefaultNetTypeDirectiveSyntax&) = delete;

    static const DefaultNetTypeDirectiveSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return directive;
            case 1: return netType;
            case 2: return endOfDirective;
            default: return nullptr;
        }
    }
};

struct LineDirectiveSyntax : public DirectiveSyntax {
    Token lineNumber;
    Token fileName;
    Token level;
    Token endOfDirective;

    LineDirectiveSyntax(Token directive, Token lineNumber, Token fileName, Token level, Token endOfDirective) :
        DirectiveSyntax(SyntaxKind::LineDirective, directive), lineNumber(lineNumber), fileName(fileName), level(level), endOfDirective(endOfDirective)
    {
        childCount += 4;
    }

    LineDirectiveSyntax(const LineDirectiveSyntax&) = delete;
    LineDirectiveSyntax& operator=(const LineDirectiveSyntax&) = delete;

    static const LineDirectiveSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return directive;
            case 1: return lineNumber;
            case 2: return fileName;
            case 3: return level;
            case 4: return endOfDirective;
            default: return nullptr;
        }
    }
};

struct UndefDirectiveSyntax : public DirectiveSyntax {
    Token name;
    Token endOfDirective;

    UndefDirectiveSyntax(Token directive, Token name, Token endOfDirective) :
        DirectiveSyntax(SyntaxKind::UndefDirective, directive), name(name), endOfDirective(endOfDirective)
    {
        childCount += 2;
    }

    UndefDirectiveSyntax(const UndefDirectiveSyntax&) = delete;
    UndefDirectiveSyntax& operator=(const UndefDirectiveSyntax&) = delete;

    static const UndefDirectiveSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return directive;
            case 1: return name;
            case 2: return endOfDirective;
            default: return nullptr;
        }
    }
};

struct BeginKeywordsDirectiveSyntax : public DirectiveSyntax {
    Token versionSpecifier;
    Token endOfDirective;

    BeginKeywordsDirectiveSyntax(Token directive, Token versionSpecifier, Token endOfDirective) :
        DirectiveSyntax(SyntaxKind::BeginKeywordsDirective, directive), versionSpecifier(versionSpecifier), endOfDirective(endOfDirective)
    {
        childCount += 2;
    }

    BeginKeywordsDirectiveSyntax(const BeginKeywordsDirectiveSyntax&) = delete;
    BeginKeywordsDirectiveSyntax& operator=(const BeginKeywordsDirectiveSyntax&) = delete;

    static const BeginKeywordsDirectiveSyntax Empty;

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return directive;
            case 1: return versionSpecifier;
            case 2: return endOfDirective;
            default: return nullptr;
        }
    }
};

template<typename T>
void dispatchVisitor(T& v, const SyntaxNode* node) {
    if (!node) return;
    switch (node->kind) {
        case SyntaxKind::Unknown: break;
        case SyntaxKind::List: v.visitDefault(*node); break;
        case SyntaxKind::SimpleAssignmentPattern: SyntaxNode::dispatch(v, *(const SimpleAssignmentPatternSyntax*)node); break;
        case SyntaxKind::VarDataType: SyntaxNode::dispatch(v, *(const VarDataTypeSyntax*)node); break;
        case SyntaxKind::NamedLabel: SyntaxNode::dispatch(v, *(const NamedLabelSyntax*)node); break;
        case SyntaxKind::ConstraintDeclaration: SyntaxNode::dispatch(v, *(const ConstraintDeclarationSyntax*)node); break;
        case SyntaxKind::AddExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::GreaterThanExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::AttributeSpec: SyntaxNode::dispatch(v, *(const AttributeSpecSyntax*)node); break;
        case SyntaxKind::StringLiteralExpression: SyntaxNode::dispatch(v, *(const LiteralExpressionSyntax*)node); break;
        case SyntaxKind::ModuleHeader: SyntaxNode::dispatch(v, *(const ModuleHeaderSyntax*)node); break;
        case SyntaxKind::ResetAllDirective: SyntaxNode::dispatch(v, *(const SimpleDirectiveSyntax*)node); break;
        case SyntaxKind::QueueDimensionSpecifier: SyntaxNode::dispatch(v, *(const QueueDimensionSpecifierSyntax*)node); break;
        case SyntaxKind::TimingControlExpression: SyntaxNode::dispatch(v, *(const TimingControlExpressionSyntax*)node); break;
        case SyntaxKind::ConstraintBlock: SyntaxNode::dispatch(v, *(const ConstraintBlockSyntax*)node); break;
        case SyntaxKind::ModportItem: SyntaxNode::dispatch(v, *(const ModportItemSyntax*)node); break;
        case SyntaxKind::UnaryPredecrementExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::BinarySequenceDelayExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::SignalEventExpression: SyntaxNode::dispatch(v, *(const SignalEventExpressionSyntax*)node); break;
        case SyntaxKind::DescendingRangeSelect: SyntaxNode::dispatch(v, *(const RangeSelectSyntax*)node); break;
        case SyntaxKind::OrAssignmentExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::UnitScope: SyntaxNode::dispatch(v, *(const KeywordNameSyntax*)node); break;
        case SyntaxKind::UnaryBitwiseOrExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::StructurePattern: SyntaxNode::dispatch(v, *(const StructurePatternSyntax*)node); break;
        case SyntaxKind::MinTypMaxExpression: SyntaxNode::dispatch(v, *(const MinTypMaxExpressionSyntax*)node); break;
        case SyntaxKind::AcceptOnPropertyExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::AttributeInstance: SyntaxNode::dispatch(v, *(const AttributeInstanceSyntax*)node); break;
        case SyntaxKind::VariableDimension: SyntaxNode::dispatch(v, *(const VariableDimensionSyntax*)node); break;
        case SyntaxKind::TimescaleDirective: SyntaxNode::dispatch(v, *(const TimescaleDirectiveSyntax*)node); break;
        case SyntaxKind::ArithmeticRightShiftAssignmentExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::WildcardInequalityExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ForLoopStatement: SyntaxNode::dispatch(v, *(const ForLoopStatementSyntax*)node); break;
        case SyntaxKind::IfNDefDirective: SyntaxNode::dispatch(v, *(const ConditionalBranchDirectiveSyntax*)node); break;
        case SyntaxKind::IncludeDirective: SyntaxNode::dispatch(v, *(const IncludeDirectiveSyntax*)node); break;
        case SyntaxKind::PropertySpec: SyntaxNode::dispatch(v, *(const PropertySpecSyntax*)node); break;
        case SyntaxKind::VariablePattern: SyntaxNode::dispatch(v, *(const VariablePatternSyntax*)node); break;
        case SyntaxKind::WithClause: SyntaxNode::dispatch(v, *(const WithClauseSyntax*)node); break;
        case SyntaxKind::ImmediateCoverStatement: SyntaxNode::dispatch(v, *(const ImmediateAssertionStatementSyntax*)node); break;
        case SyntaxKind::CastExpression: SyntaxNode::dispatch(v, *(const CastExpressionSyntax*)node); break;
        case SyntaxKind::SyncAcceptOnPropertyExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::DataDeclaration: SyntaxNode::dispatch(v, *(const DataDeclarationSyntax*)node); break;
        case SyntaxKind::UnaryBitwiseNotExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::GenerateRegion: SyntaxNode::dispatch(v, *(const GenerateRegionSyntax*)node); break;
        case SyntaxKind::DotMemberClause: SyntaxNode::dispatch(v, *(const DotMemberClauseSyntax*)node); break;
        case SyntaxKind::BadExpression: SyntaxNode::dispatch(v, *(const BadExpressionSyntax*)node); break;
        case SyntaxKind::SUntilPropertyExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::CoverPropertyStatement: SyntaxNode::dispatch(v, *(const ConcurrentAssertionStatementSyntax*)node); break;
        case SyntaxKind::EventType: SyntaxNode::dispatch(v, *(const KeywordTypeSyntax*)node); break;
        case SyntaxKind::DefaultNetTypeDirective: SyntaxNode::dispatch(v, *(const DefaultNetTypeDirectiveSyntax*)node); break;
        case SyntaxKind::RestrictPropertyStatement: SyntaxNode::dispatch(v, *(const ConcurrentAssertionStatementSyntax*)node); break;
        case SyntaxKind::ConditionalPattern: SyntaxNode::dispatch(v, *(const ConditionalPatternSyntax*)node); break;
        case SyntaxKind::ArrayAndMethod: SyntaxNode::dispatch(v, *(const KeywordNameSyntax*)node); break;
        case SyntaxKind::ScopedName: SyntaxNode::dispatch(v, *(const ScopedNameSyntax*)node); break;
        case SyntaxKind::TypedefDeclaration: SyntaxNode::dispatch(v, *(const TypedefDeclarationSyntax*)node); break;
        case SyntaxKind::PrimaryBlockEventExpression: SyntaxNode::dispatch(v, *(const PrimaryBlockEventExpressionSyntax*)node); break;
        case SyntaxKind::TimeUnitsDeclaration: SyntaxNode::dispatch(v, *(const TimeUnitsDeclarationSyntax*)node); break;
        case SyntaxKind::DisableForkStatement: SyntaxNode::dispatch(v, *(const DisableForkStatementSyntax*)node); break;
        case SyntaxKind::OverlappedImplicationPropertyExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ShortIntType: SyntaxNode::dispatch(v, *(const IntegerTypeSyntax*)node); break;
        case SyntaxKind::GreaterThanEqualExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::DataTypeDimensionSpecifier: SyntaxNode::dispatch(v, *(const DataTypeDimensionSpecifierSyntax*)node); break;
        case SyntaxKind::ImplementsClause: SyntaxNode::dispatch(v, *(const ImplementsClauseSyntax*)node); break;
        case SyntaxKind::AscendingRangeSelect: SyntaxNode::dispatch(v, *(const RangeSelectSyntax*)node); break;
        case SyntaxKind::ExpressionOrDist: SyntaxNode::dispatch(v, *(const ExpressionOrDistSyntax*)node); break;
        case SyntaxKind::UnaryNotPropertyExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::DividerClause: SyntaxNode::dispatch(v, *(const DividerClauseSyntax*)node); break;
        case SyntaxKind::ExplicitNonAnsiPort: SyntaxNode::dispatch(v, *(const ExplicitNonAnsiPortSyntax*)node); break;
        case SyntaxKind::AlwaysCombBlock: SyntaxNode::dispatch(v, *(const ProceduralBlockSyntax*)node); break;
        case SyntaxKind::AnsiPortList: SyntaxNode::dispatch(v, *(const AnsiPortListSyntax*)node); break;
        case SyntaxKind::AndAssignmentExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::RealTimeType: SyntaxNode::dispatch(v, *(const KeywordTypeSyntax*)node); break;
        case SyntaxKind::Untyped: SyntaxNode::dispatch(v, *(const KeywordTypeSyntax*)node); break;
        case SyntaxKind::EventuallyPropertyExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::TimingControlExpressionConcatenation: SyntaxNode::dispatch(v, *(const TimingControlExpressionConcatenationSyntax*)node); break;
        case SyntaxKind::InterfacePortHeader: SyntaxNode::dispatch(v, *(const InterfacePortHeaderSyntax*)node); break;
        case SyntaxKind::TimingControlStatement: SyntaxNode::dispatch(v, *(const TimingControlStatementSyntax*)node); break;
        case SyntaxKind::DisableIff: SyntaxNode::dispatch(v, *(const DisableIffSyntax*)node); break;
        case SyntaxKind::UnaryBitwiseNandExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::TimeLiteralExpression: SyntaxNode::dispatch(v, *(const LiteralExpressionSyntax*)node); break;
        case SyntaxKind::MultiplyAssignmentExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::IdentifierList: SyntaxNode::dispatch(v, *(const IdentifierListSyntax*)node); break;
        case SyntaxKind::NonAnsiPortList: SyntaxNode::dispatch(v, *(const NonAnsiPortListSyntax*)node); break;
        case SyntaxKind::CompilationUnit: SyntaxNode::dispatch(v, *(const CompilationUnitSyntax*)node); break;
        case SyntaxKind::CaseGenerate: SyntaxNode::dispatch(v, *(const CaseGenerateSyntax*)node); break;
        case SyntaxKind::StructuredAssignmentPattern: SyntaxNode::dispatch(v, *(const StructuredAssignmentPatternSyntax*)node); break;
        case SyntaxKind::WithFunctionSample: SyntaxNode::dispatch(v, *(const WithFunctionSampleSyntax*)node); break;
        case SyntaxKind::EventControlWithExpression: SyntaxNode::dispatch(v, *(const EventControlWithExpressionSyntax*)node); break;
        case SyntaxKind::ModportDeclaration: SyntaxNode::dispatch(v, *(const ModportDeclarationSyntax*)node); break;
        case SyntaxKind::OrderedStructurePatternMember: SyntaxNode::dispatch(v, *(const OrderedStructurePatternMemberSyntax*)node); break;
        case SyntaxKind::EventControl: SyntaxNode::dispatch(v, *(const EventControlSyntax*)node); break;
        case SyntaxKind::CaseStatement: SyntaxNode::dispatch(v, *(const CaseStatementSyntax*)node); break;
        case SyntaxKind::UntilWithPropertyExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ModAssignmentExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::TimeType: SyntaxNode::dispatch(v, *(const IntegerTypeSyntax*)node); break;
        case SyntaxKind::NetDeclaration: SyntaxNode::dispatch(v, *(const NetDeclarationSyntax*)node); break;
        case SyntaxKind::ExpressionConstraint: SyntaxNode::dispatch(v, *(const ExpressionConstraintSyntax*)node); break;
        case SyntaxKind::ColonExpressionClause: SyntaxNode::dispatch(v, *(const ColonExpressionClauseSyntax*)node); break;
        case SyntaxKind::LogicalAndExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ClockingSkew: SyntaxNode::dispatch(v, *(const ClockingSkewSyntax*)node); break;
        case SyntaxKind::StreamExpression: SyntaxNode::dispatch(v, *(const StreamExpressionSyntax*)node); break;
        case SyntaxKind::ParenImplicitEventControl: SyntaxNode::dispatch(v, *(const ParenImplicitEventControlSyntax*)node); break;
        case SyntaxKind::WildcardLiteralExpression: SyntaxNode::dispatch(v, *(const LiteralExpressionSyntax*)node); break;
        case SyntaxKind::BlockingEventTriggerStatement: SyntaxNode::dispatch(v, *(const EventTriggerStatementSyntax*)node); break;
        case SyntaxKind::ParenthesizedEventExpression: SyntaxNode::dispatch(v, *(const ParenthesizedEventExpressionSyntax*)node); break;
        case SyntaxKind::RejectOnPropertyExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::ExplicitAnsiPort: SyntaxNode::dispatch(v, *(const ExplicitAnsiPortSyntax*)node); break;
        case SyntaxKind::AssignmentPatternExpression: SyntaxNode::dispatch(v, *(const AssignmentPatternExpressionSyntax*)node); break;
        case SyntaxKind::MacroUsage: SyntaxNode::dispatch(v, *(const MacroUsageSyntax*)node); break;
        case SyntaxKind::PowerExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::NamedPortConnection: SyntaxNode::dispatch(v, *(const NamedPortConnectionSyntax*)node); break;
        case SyntaxKind::WildcardDimensionSpecifier: SyntaxNode::dispatch(v, *(const WildcardDimensionSpecifierSyntax*)node); break;
        case SyntaxKind::FinalBlock: SyntaxNode::dispatch(v, *(const ProceduralBlockSyntax*)node); break;
        case SyntaxKind::ParallelBlockStatement: SyntaxNode::dispatch(v, *(const BlockStatementSyntax*)node); break;
        case SyntaxKind::ActionBlock: SyntaxNode::dispatch(v, *(const ActionBlockSyntax*)node); break;
        case SyntaxKind::LogicalOrExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::EmptyArgument: SyntaxNode::dispatch(v, *(const EmptyArgumentSyntax*)node); break;
        case SyntaxKind::NonblockingAssignmentExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ConditionalConstraint: SyntaxNode::dispatch(v, *(const ConditionalConstraintSyntax*)node); break;
        case SyntaxKind::MacroArgumentDefault: SyntaxNode::dispatch(v, *(const MacroArgumentDefaultSyntax*)node); break;
        case SyntaxKind::StringType: SyntaxNode::dispatch(v, *(const KeywordTypeSyntax*)node); break;
        case SyntaxKind::RegType: SyntaxNode::dispatch(v, *(const IntegerTypeSyntax*)node); break;
        case SyntaxKind::ExtendsClause: SyntaxNode::dispatch(v, *(const ExtendsClauseSyntax*)node); break;
        case SyntaxKind::NamedArgument: SyntaxNode::dispatch(v, *(const NamedArgumentSyntax*)node); break;
        case SyntaxKind::UnaryBitwiseNorExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::NullLiteralExpression: SyntaxNode::dispatch(v, *(const LiteralExpressionSyntax*)node); break;
        case SyntaxKind::CaseInequalityExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::UnbasedUnsizedLiteralExpression: SyntaxNode::dispatch(v, *(const LiteralExpressionSyntax*)node); break;
        case SyntaxKind::LineDirective: SyntaxNode::dispatch(v, *(const LineDirectiveSyntax*)node); break;
        case SyntaxKind::ImpliesPropertyExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ChargeStrength: SyntaxNode::dispatch(v, *(const ChargeStrengthSyntax*)node); break;
        case SyntaxKind::UniquenessConstraint: SyntaxNode::dispatch(v, *(const UniquenessConstraintSyntax*)node); break;
        case SyntaxKind::LoopStatement: SyntaxNode::dispatch(v, *(const LoopStatementSyntax*)node); break;
        case SyntaxKind::UnaryMinusExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::ParenthesizedExpression: SyntaxNode::dispatch(v, *(const ParenthesizedExpressionSyntax*)node); break;
        case SyntaxKind::TypedefInterfaceClassDeclaration: SyntaxNode::dispatch(v, *(const TypedefInterfaceClassDeclarationSyntax*)node); break;
        case SyntaxKind::StandardCaseItem: SyntaxNode::dispatch(v, *(const StandardCaseItemSyntax*)node); break;
        case SyntaxKind::UnaryBitwiseXnorExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::LogicalRightShiftAssignmentExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::MacroFormalArgumentList: SyntaxNode::dispatch(v, *(const MacroFormalArgumentListSyntax*)node); break;
        case SyntaxKind::RealLiteralExpression: SyntaxNode::dispatch(v, *(const LiteralExpressionSyntax*)node); break;
        case SyntaxKind::NetPortHeader: SyntaxNode::dispatch(v, *(const NetPortHeaderSyntax*)node); break;
        case SyntaxKind::AddAssignmentExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::CellDefineDirective: SyntaxNode::dispatch(v, *(const SimpleDirectiveSyntax*)node); break;
        case SyntaxKind::ImplicitType: SyntaxNode::dispatch(v, *(const ImplicitTypeSyntax*)node); break;
        case SyntaxKind::JumpStatement: SyntaxNode::dispatch(v, *(const JumpStatementSyntax*)node); break;
        case SyntaxKind::AssertionItemPort: SyntaxNode::dispatch(v, *(const AssertionItemPortSyntax*)node); break;
        case SyntaxKind::UnaryLogicalNotExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::ClassPropertyDeclaration: SyntaxNode::dispatch(v, *(const ClassPropertyDeclarationSyntax*)node); break;
        case SyntaxKind::StreamingConcatenationExpression: SyntaxNode::dispatch(v, *(const StreamingConcatenationExpressionSyntax*)node); break;
        case SyntaxKind::ParameterValueAssignment: SyntaxNode::dispatch(v, *(const ParameterValueAssignmentSyntax*)node); break;
        case SyntaxKind::XorAssignmentExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::MacroActualArgumentList: SyntaxNode::dispatch(v, *(const MacroActualArgumentListSyntax*)node); break;
        case SyntaxKind::EmptyStatement: SyntaxNode::dispatch(v, *(const EmptyStatementSyntax*)node); break;
        case SyntaxKind::NonOverlappedImplicationPropertyExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::IntType: SyntaxNode::dispatch(v, *(const IntegerTypeSyntax*)node); break;
        case SyntaxKind::ShortRealType: SyntaxNode::dispatch(v, *(const KeywordTypeSyntax*)node); break;
        case SyntaxKind::EnumType: SyntaxNode::dispatch(v, *(const EnumTypeSyntax*)node); break;
        case SyntaxKind::UnionType: SyntaxNode::dispatch(v, *(const StructUnionTypeSyntax*)node); break;
        case SyntaxKind::LongIntType: SyntaxNode::dispatch(v, *(const IntegerTypeSyntax*)node); break;
        case SyntaxKind::CoverageOption: SyntaxNode::dispatch(v, *(const CoverageOptionSyntax*)node); break;
        case SyntaxKind::SNextTimePropertyExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::ProgramHeader: SyntaxNode::dispatch(v, *(const ModuleHeaderSyntax*)node); break;
        case SyntaxKind::NonblockingEventTriggerStatement: SyntaxNode::dispatch(v, *(const EventTriggerStatementSyntax*)node); break;
        case SyntaxKind::PatternCaseItem: SyntaxNode::dispatch(v, *(const PatternCaseItemSyntax*)node); break;
        case SyntaxKind::ArrayXorMethod: SyntaxNode::dispatch(v, *(const KeywordNameSyntax*)node); break;
        case SyntaxKind::DefParamAssignment: SyntaxNode::dispatch(v, *(const DefParamAssignmentSyntax*)node); break;
        case SyntaxKind::EndKeywordsDirective: SyntaxNode::dispatch(v, *(const SimpleDirectiveSyntax*)node); break;
        case SyntaxKind::AssertionItemPortList: SyntaxNode::dispatch(v, *(const AssertionItemPortListSyntax*)node); break;
        case SyntaxKind::DistWeight: SyntaxNode::dispatch(v, *(const DistWeightSyntax*)node); break;
        case SyntaxKind::LogicalShiftLeftExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::DelayControl: SyntaxNode::dispatch(v, *(const DelaySyntax*)node); break;
        case SyntaxKind::IfDefDirective: SyntaxNode::dispatch(v, *(const ConditionalBranchDirectiveSyntax*)node); break;
        case SyntaxKind::PackageImportDeclaration: SyntaxNode::dispatch(v, *(const PackageImportDeclarationSyntax*)node); break;
        case SyntaxKind::LoopGenerate: SyntaxNode::dispatch(v, *(const LoopGenerateSyntax*)node); break;
        case SyntaxKind::BitSelect: SyntaxNode::dispatch(v, *(const BitSelectSyntax*)node); break;
        case SyntaxKind::BinaryOrExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::EmptyMember: SyntaxNode::dispatch(v, *(const EmptyMemberSyntax*)node); break;
        case SyntaxKind::BinaryEventExpression: SyntaxNode::dispatch(v, *(const BinaryEventExpressionSyntax*)node); break;
        case SyntaxKind::Coverpoint: SyntaxNode::dispatch(v, *(const CoverpointSyntax*)node); break;
        case SyntaxKind::OrderedArgument: SyntaxNode::dispatch(v, *(const OrderedArgumentSyntax*)node); break;
        case SyntaxKind::FunctionPrototype: SyntaxNode::dispatch(v, *(const FunctionPrototypeSyntax*)node); break;
        case SyntaxKind::ByteType: SyntaxNode::dispatch(v, *(const IntegerTypeSyntax*)node); break;
        case SyntaxKind::FunctionDeclaration: SyntaxNode::dispatch(v, *(const FunctionDeclarationSyntax*)node); break;
        case SyntaxKind::PackageHeader: SyntaxNode::dispatch(v, *(const ModuleHeaderSyntax*)node); break;
        case SyntaxKind::ImplicationConstraint: SyntaxNode::dispatch(v, *(const ImplicationConstraintSyntax*)node); break;
        case SyntaxKind::MacroFormalArgument: SyntaxNode::dispatch(v, *(const MacroFormalArgumentSyntax*)node); break;
        case SyntaxKind::BeginKeywordsDirective: SyntaxNode::dispatch(v, *(const BeginKeywordsDirectiveSyntax*)node); break;
        case SyntaxKind::SAlwaysPropertyExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::AlwaysFFBlock: SyntaxNode::dispatch(v, *(const ProceduralBlockSyntax*)node); break;
        case SyntaxKind::ExpressionCoverageBinInitializer: SyntaxNode::dispatch(v, *(const ExpressionCoverageBinInitializerSyntax*)node); break;
        case SyntaxKind::InterfaceDeclaration: SyntaxNode::dispatch(v, *(const ModuleDeclarationSyntax*)node); break;
        case SyntaxKind::AlwaysBlock: SyntaxNode::dispatch(v, *(const ProceduralBlockSyntax*)node); break;
        case SyntaxKind::RangeCoverageBinInitializer: SyntaxNode::dispatch(v, *(const RangeCoverageBinInitializerSyntax*)node); break;
        case SyntaxKind::NamedStructurePatternMember: SyntaxNode::dispatch(v, *(const NamedStructurePatternMemberSyntax*)node); break;
        case SyntaxKind::WaitStatement: SyntaxNode::dispatch(v, *(const WaitStatementSyntax*)node); break;
        case SyntaxKind::FunctionPort: SyntaxNode::dispatch(v, *(const FunctionPortSyntax*)node); break;
        case SyntaxKind::ElseDirective: SyntaxNode::dispatch(v, *(const UnconditionalBranchDirectiveSyntax*)node); break;
        case SyntaxKind::CoverageBins: SyntaxNode::dispatch(v, *(const CoverageBinsSyntax*)node); break;
        case SyntaxKind::ClockingDirection: SyntaxNode::dispatch(v, *(const ClockingDirectionSyntax*)node); break;
        case SyntaxKind::ConcurrentAssertionMember: SyntaxNode::dispatch(v, *(const ConcurrentAssertionMemberSyntax*)node); break;
        case SyntaxKind::StructType: SyntaxNode::dispatch(v, *(const StructUnionTypeSyntax*)node); break;
        case SyntaxKind::UnaryBitwiseXorExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::ConstraintPrototype: SyntaxNode::dispatch(v, *(const ConstraintPrototypeSyntax*)node); break;
        case SyntaxKind::ElementSelectExpression: SyntaxNode::dispatch(v, *(const ElementSelectExpressionSyntax*)node); break;
        case SyntaxKind::HierarchicalInstance: SyntaxNode::dispatch(v, *(const HierarchicalInstanceSyntax*)node); break;
        case SyntaxKind::NewExpression: SyntaxNode::dispatch(v, *(const NewExpressionSyntax*)node); break;
        case SyntaxKind::CaseEqualityExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ReturnStatement: SyntaxNode::dispatch(v, *(const ReturnStatementSyntax*)node); break;
        case SyntaxKind::ImmediateAssertionMember: SyntaxNode::dispatch(v, *(const ImmediateAssertionMemberSyntax*)node); break;
        case SyntaxKind::MemberAccessExpression: SyntaxNode::dispatch(v, *(const MemberAccessExpressionSyntax*)node); break;
        case SyntaxKind::SolveBeforeConstraint: SyntaxNode::dispatch(v, *(const SolveBeforeConstraintSyntax*)node); break;
        case SyntaxKind::NewArrayExpression: SyntaxNode::dispatch(v, *(const NewArrayExpressionSyntax*)node); break;
        case SyntaxKind::BinaryXnorExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::LogicalEquivalenceExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::IffClause: SyntaxNode::dispatch(v, *(const IffClauseSyntax*)node); break;
        case SyntaxKind::ClockingItem: SyntaxNode::dispatch(v, *(const ClockingItemSyntax*)node); break;
        case SyntaxKind::DPIImportExport: SyntaxNode::dispatch(v, *(const DPIImportExportSyntax*)node); break;
        case SyntaxKind::TaggedUnionExpression: SyntaxNode::dispatch(v, *(const TaggedUnionExpressionSyntax*)node); break;
        case SyntaxKind::ConditionalStatement: SyntaxNode::dispatch(v, *(const ConditionalStatementSyntax*)node); break;
        case SyntaxKind::IdentifierName: SyntaxNode::dispatch(v, *(const IdentifierNameSyntax*)node); break;
        case SyntaxKind::RepeatedEventControl: SyntaxNode::dispatch(v, *(const RepeatedEventControlSyntax*)node); break;
        case SyntaxKind::BitType: SyntaxNode::dispatch(v, *(const IntegerTypeSyntax*)node); break;
        case SyntaxKind::GenerateBlock: SyntaxNode::dispatch(v, *(const GenerateBlockSyntax*)node); break;
        case SyntaxKind::UnarySequenceEventExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::LogicalLeftShiftAssignmentExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::VirtualInterfaceType: SyntaxNode::dispatch(v, *(const VirtualInterfaceTypeSyntax*)node); break;
        case SyntaxKind::DefaultCoverageBinInitializer: SyntaxNode::dispatch(v, *(const DefaultCoverageBinInitializerSyntax*)node); break;
        case SyntaxKind::DoWhileStatement: SyntaxNode::dispatch(v, *(const DoWhileStatementSyntax*)node); break;
        case SyntaxKind::WaitForkStatement: SyntaxNode::dispatch(v, *(const WaitForkStatementSyntax*)node); break;
        case SyntaxKind::SignedCastExpression: SyntaxNode::dispatch(v, *(const SignedCastExpressionSyntax*)node); break;
        case SyntaxKind::ExpressionStatement: SyntaxNode::dispatch(v, *(const ExpressionStatementSyntax*)node); break;
        case SyntaxKind::SEventuallyPropertyExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::PropertyType: SyntaxNode::dispatch(v, *(const KeywordTypeSyntax*)node); break;
        case SyntaxKind::SubtractAssignmentExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ThroughoutSequenceExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::WildcardEqualityExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ShortcutCycleDelayRange: SyntaxNode::dispatch(v, *(const ShortcutCycleDelayRangeSyntax*)node); break;
        case SyntaxKind::PostincrementExpression: SyntaxNode::dispatch(v, *(const PostfixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::IffPropertyExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::TypeReference: SyntaxNode::dispatch(v, *(const TypeReferenceSyntax*)node); break;
        case SyntaxKind::InterconnectPortHeader: SyntaxNode::dispatch(v, *(const InterconnectPortHeaderSyntax*)node); break;
        case SyntaxKind::ArgumentList: SyntaxNode::dispatch(v, *(const ArgumentListSyntax*)node); break;
        case SyntaxKind::InsideExpression: SyntaxNode::dispatch(v, *(const InsideExpressionSyntax*)node); break;
        case SyntaxKind::EndCellDefineDirective: SyntaxNode::dispatch(v, *(const SimpleDirectiveSyntax*)node); break;
        case SyntaxKind::WildcardPortConnection: SyntaxNode::dispatch(v, *(const WildcardPortConnectionSyntax*)node); break;
        case SyntaxKind::SyncRejectOnPropertyExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::VoidType: SyntaxNode::dispatch(v, *(const KeywordTypeSyntax*)node); break;
        case SyntaxKind::InitialBlock: SyntaxNode::dispatch(v, *(const ProceduralBlockSyntax*)node); break;
        case SyntaxKind::LetDeclaration: SyntaxNode::dispatch(v, *(const LetDeclarationSyntax*)node); break;
        case SyntaxKind::BinaryXorExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::NamedType: SyntaxNode::dispatch(v, *(const NamedTypeSyntax*)node); break;
        case SyntaxKind::VariablePortHeader: SyntaxNode::dispatch(v, *(const VariablePortHeaderSyntax*)node); break;
        case SyntaxKind::ClassScope: SyntaxNode::dispatch(v, *(const ClassScopeSyntax*)node); break;
        case SyntaxKind::ForeachLoopList: SyntaxNode::dispatch(v, *(const ForeachLoopListSyntax*)node); break;
        case SyntaxKind::ClassMethodPrototype: SyntaxNode::dispatch(v, *(const ClassMethodPrototypeSyntax*)node); break;
        case SyntaxKind::DivideExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::BinaryAndExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::EqualsValueClause: SyntaxNode::dispatch(v, *(const EqualsValueClauseSyntax*)node); break;
        case SyntaxKind::AlwaysPropertyExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::ForVariableDeclaration: SyntaxNode::dispatch(v, *(const ForVariableDeclarationSyntax*)node); break;
        case SyntaxKind::DriveStrength: SyntaxNode::dispatch(v, *(const DriveStrengthSyntax*)node); break;
        case SyntaxKind::UnaryPlusExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::CoverSequenceStatement: SyntaxNode::dispatch(v, *(const ConcurrentAssertionStatementSyntax*)node); break;
        case SyntaxKind::ProceduralAssignStatement: SyntaxNode::dispatch(v, *(const ProceduralAssignStatementSyntax*)node); break;
        case SyntaxKind::ConditionalPredicate: SyntaxNode::dispatch(v, *(const ConditionalPredicateSyntax*)node); break;
        case SyntaxKind::ImmediateAssumeStatement: SyntaxNode::dispatch(v, *(const ImmediateAssertionStatementSyntax*)node); break;
        case SyntaxKind::LogicalImplicationExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::UndefineAllDirective: SyntaxNode::dispatch(v, *(const SimpleDirectiveSyntax*)node); break;
        case SyntaxKind::UnaryBitwiseAndExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::InequalityExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ParameterDeclaration: SyntaxNode::dispatch(v, *(const ParameterDeclarationSyntax*)node); break;
        case SyntaxKind::TaskDeclaration: SyntaxNode::dispatch(v, *(const FunctionDeclarationSyntax*)node); break;
        case SyntaxKind::OrSequenceExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ImplicitNonAnsiPort: SyntaxNode::dispatch(v, *(const ImplicitNonAnsiPortSyntax*)node); break;
        case SyntaxKind::AlwaysLatchBlock: SyntaxNode::dispatch(v, *(const ProceduralBlockSyntax*)node); break;
        case SyntaxKind::StreamExpressionWithRange: SyntaxNode::dispatch(v, *(const StreamExpressionWithRange*)node); break;
        case SyntaxKind::IdentifierSelectName: SyntaxNode::dispatch(v, *(const IdentifierSelectNameSyntax*)node); break;
        case SyntaxKind::EqualityExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ArithmeticShiftLeftExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::LocalScope: SyntaxNode::dispatch(v, *(const KeywordNameSyntax*)node); break;
        case SyntaxKind::ConditionalExpression: SyntaxNode::dispatch(v, *(const ConditionalExpressionSyntax*)node); break;
        case SyntaxKind::ProceduralDeassignStatement: SyntaxNode::dispatch(v, *(const ProceduralDeassignStatementSyntax*)node); break;
        case SyntaxKind::DistItem: SyntaxNode::dispatch(v, *(const DistItemSyntax*)node); break;
        case SyntaxKind::ArrayUniqueMethod: SyntaxNode::dispatch(v, *(const KeywordNameSyntax*)node); break;
        case SyntaxKind::ProgramDeclaration: SyntaxNode::dispatch(v, *(const ModuleDeclarationSyntax*)node); break;
        case SyntaxKind::ForeachLoopStatement: SyntaxNode::dispatch(v, *(const ForeachLoopStatementSyntax*)node); break;
        case SyntaxKind::ArithmeticLeftShiftAssignmentExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::NonOverlappedFollowedByPropertyExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ImplicitAnsiPort: SyntaxNode::dispatch(v, *(const ImplicitAnsiPortSyntax*)node); break;
        case SyntaxKind::ProceduralReleaseStatement: SyntaxNode::dispatch(v, *(const ProceduralDeassignStatementSyntax*)node); break;
        case SyntaxKind::DivideAssignmentExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::DisableStatement: SyntaxNode::dispatch(v, *(const DisableStatementSyntax*)node); break;
        case SyntaxKind::ParameterDeclarationStatement: SyntaxNode::dispatch(v, *(const ParameterDeclarationStatementSyntax*)node); break;
        case SyntaxKind::DisableConstraint: SyntaxNode::dispatch(v, *(const DisableConstraintSyntax*)node); break;
        case SyntaxKind::DeferredAssertion: SyntaxNode::dispatch(v, *(const DeferredAssertionSyntax*)node); break;
        case SyntaxKind::FunctionPortList: SyntaxNode::dispatch(v, *(const FunctionPortListSyntax*)node); break;
        case SyntaxKind::ThisHandle: SyntaxNode::dispatch(v, *(const KeywordNameSyntax*)node); break;
        case SyntaxKind::ClassName: SyntaxNode::dispatch(v, *(const ClassNameSyntax*)node); break;
        case SyntaxKind::AssignmentExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::StructUnionMember: SyntaxNode::dispatch(v, *(const StructUnionMemberSyntax*)node); break;
        case SyntaxKind::DefParam: SyntaxNode::dispatch(v, *(const DefParamSyntax*)node); break;
        case SyntaxKind::HierarchyInstantiation: SyntaxNode::dispatch(v, *(const HierarchyInstantiationSyntax*)node); break;
        case SyntaxKind::SuperHandle: SyntaxNode::dispatch(v, *(const KeywordNameSyntax*)node); break;
        case SyntaxKind::IntersectSequenceExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::LogicalShiftRightExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::DefineDirective: SyntaxNode::dispatch(v, *(const DefineDirectiveSyntax*)node); break;
        case SyntaxKind::SUntilWithPropertyExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::WithinSequenceExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ArithmeticShiftRightExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ModuleDeclaration: SyntaxNode::dispatch(v, *(const ModuleDeclarationSyntax*)node); break;
        case SyntaxKind::UnconnectedDriveDirective: SyntaxNode::dispatch(v, *(const SimpleDirectiveSyntax*)node); break;
        case SyntaxKind::ConstructorName: SyntaxNode::dispatch(v, *(const KeywordNameSyntax*)node); break;
        case SyntaxKind::NewClassExpression: SyntaxNode::dispatch(v, *(const NewClassExpressionSyntax*)node); break;
        case SyntaxKind::DistConstraintList: SyntaxNode::dispatch(v, *(const DistConstraintListSyntax*)node); break;
        case SyntaxKind::ElementSelect: SyntaxNode::dispatch(v, *(const ElementSelectSyntax*)node); break;
        case SyntaxKind::ExpectPropertyStatement: SyntaxNode::dispatch(v, *(const ConcurrentAssertionStatementSyntax*)node); break;
        case SyntaxKind::PostdecrementExpression: SyntaxNode::dispatch(v, *(const PostfixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::UnarySequenceDelayExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::MatchesClause: SyntaxNode::dispatch(v, *(const MatchesClauseSyntax*)node); break;
        case SyntaxKind::GenvarDeclaration: SyntaxNode::dispatch(v, *(const GenvarDeclarationSyntax*)node); break;
        case SyntaxKind::ReplicatedAssignmentPattern: SyntaxNode::dispatch(v, *(const ReplicatedAssignmentPatternSyntax*)node); break;
        case SyntaxKind::LogicType: SyntaxNode::dispatch(v, *(const IntegerTypeSyntax*)node); break;
        case SyntaxKind::LoopConstraint: SyntaxNode::dispatch(v, *(const LoopConstraintSyntax*)node); break;
        case SyntaxKind::IntegerVectorExpression: SyntaxNode::dispatch(v, *(const IntegerVectorExpressionSyntax*)node); break;
        case SyntaxKind::PragmaDirective: SyntaxNode::dispatch(v, *(const SimpleDirectiveSyntax*)node); break;
        case SyntaxKind::SubtractExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::SimpleRangeSelect: SyntaxNode::dispatch(v, *(const RangeSelectSyntax*)node); break;
        case SyntaxKind::TaggedPattern: SyntaxNode::dispatch(v, *(const TaggedPatternSyntax*)node); break;
        case SyntaxKind::ForeverStatement: SyntaxNode::dispatch(v, *(const ForeverStatementSyntax*)node); break;
        case SyntaxKind::PackageImportItem: SyntaxNode::dispatch(v, *(const PackageImportItemSyntax*)node); break;
        case SyntaxKind::AssignmentPatternItem: SyntaxNode::dispatch(v, *(const AssignmentPatternItemSyntax*)node); break;
        case SyntaxKind::ElseClause: SyntaxNode::dispatch(v, *(const ElseClauseSyntax*)node); break;
        case SyntaxKind::AndSequenceExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::BlockCoverageEvent: SyntaxNode::dispatch(v, *(const BlockCoverageEventSyntax*)node); break;
        case SyntaxKind::SystemName: SyntaxNode::dispatch(v, *(const KeywordNameSyntax*)node); break;
        case SyntaxKind::ClassMethodDeclaration: SyntaxNode::dispatch(v, *(const ClassMethodDeclarationSyntax*)node); break;
        case SyntaxKind::OrderedPortConnection: SyntaxNode::dispatch(v, *(const OrderedPortConnectionSyntax*)node); break;
        case SyntaxKind::IntegerType: SyntaxNode::dispatch(v, *(const IntegerTypeSyntax*)node); break;
        case SyntaxKind::DefaultPatternKeyExpression: SyntaxNode::dispatch(v, *(const LiteralExpressionSyntax*)node); break;
        case SyntaxKind::ExpressionPattern: SyntaxNode::dispatch(v, *(const ExpressionPatternSyntax*)node); break;
        case SyntaxKind::ExternModule: SyntaxNode::dispatch(v, *(const ExternModuleSyntax*)node); break;
        case SyntaxKind::EmptyIdentifierName: SyntaxNode::dispatch(v, *(const EmptyIdentifierNameSyntax*)node); break;
        case SyntaxKind::SequentialBlockStatement: SyntaxNode::dispatch(v, *(const BlockStatementSyntax*)node); break;
        case SyntaxKind::MultipleConcatenationExpression: SyntaxNode::dispatch(v, *(const MultipleConcatenationExpressionSyntax*)node); break;
        case SyntaxKind::RandCaseStatement: SyntaxNode::dispatch(v, *(const RandCaseStatementSyntax*)node); break;
        case SyntaxKind::ClassDeclaration: SyntaxNode::dispatch(v, *(const ClassDeclarationSyntax*)node); break;
        case SyntaxKind::RandCaseItem: SyntaxNode::dispatch(v, *(const RandCaseItemSyntax*)node); break;
        case SyntaxKind::CovergroupDeclaration: SyntaxNode::dispatch(v, *(const CovergroupDeclarationSyntax*)node); break;
        case SyntaxKind::UnaryPreincrementExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::PackageDeclaration: SyntaxNode::dispatch(v, *(const ModuleDeclarationSyntax*)node); break;
        case SyntaxKind::PropertySequenceDeclaration: SyntaxNode::dispatch(v, *(const PropertySequenceDeclarationSyntax*)node); break;
        case SyntaxKind::MultiplyExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::OverlappedFollowedByPropertyExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ClockingDeclaration: SyntaxNode::dispatch(v, *(const ClockingDeclarationSyntax*)node); break;
        case SyntaxKind::WildcardPattern: SyntaxNode::dispatch(v, *(const WildcardPatternSyntax*)node); break;
        case SyntaxKind::LessThanEqualExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::MacroActualArgument: SyntaxNode::dispatch(v, *(const MacroActualArgumentSyntax*)node); break;
        case SyntaxKind::RootScope: SyntaxNode::dispatch(v, *(const KeywordNameSyntax*)node); break;
        case SyntaxKind::IntegerLiteralExpression: SyntaxNode::dispatch(v, *(const LiteralExpressionSyntax*)node); break;
        case SyntaxKind::AssumePropertyStatement: SyntaxNode::dispatch(v, *(const ConcurrentAssertionStatementSyntax*)node); break;
        case SyntaxKind::InterfaceHeader: SyntaxNode::dispatch(v, *(const ModuleHeaderSyntax*)node); break;
        case SyntaxKind::RandomizeMethodWithClause: SyntaxNode::dispatch(v, *(const RandomizeMethodWithClauseSyntax*)node); break;
        case SyntaxKind::BinaryBlockEventExpression: SyntaxNode::dispatch(v, *(const BinaryBlockEventExpressionSyntax*)node); break;
        case SyntaxKind::InvocationExpression: SyntaxNode::dispatch(v, *(const InvocationExpressionSyntax*)node); break;
        case SyntaxKind::ProceduralForceStatement: SyntaxNode::dispatch(v, *(const ProceduralAssignStatementSyntax*)node); break;
        case SyntaxKind::ModExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::NoUnconnectedDriveDirective: SyntaxNode::dispatch(v, *(const SimpleDirectiveSyntax*)node); break;
        case SyntaxKind::PortDeclaration: SyntaxNode::dispatch(v, *(const PortDeclarationSyntax*)node); break;
        case SyntaxKind::CHandleType: SyntaxNode::dispatch(v, *(const KeywordTypeSyntax*)node); break;
        case SyntaxKind::WildcardPortList: SyntaxNode::dispatch(v, *(const WildcardPortListSyntax*)node); break;
        case SyntaxKind::ParameterPortList: SyntaxNode::dispatch(v, *(const ParameterPortListSyntax*)node); break;
        case SyntaxKind::RealType: SyntaxNode::dispatch(v, *(const KeywordTypeSyntax*)node); break;
        case SyntaxKind::DefaultCaseItem: SyntaxNode::dispatch(v, *(const DefaultCaseItemSyntax*)node); break;
        case SyntaxKind::IfGenerate: SyntaxNode::dispatch(v, *(const IfGenerateSyntax*)node); break;
        case SyntaxKind::OneStepLiteralExpression: SyntaxNode::dispatch(v, *(const LiteralExpressionSyntax*)node); break;
        case SyntaxKind::ImmediateAssertStatement: SyntaxNode::dispatch(v, *(const ImmediateAssertionStatementSyntax*)node); break;
        case SyntaxKind::ElseConstraintClause: SyntaxNode::dispatch(v, *(const ElseConstraintClauseSyntax*)node); break;
        case SyntaxKind::UndefDirective: SyntaxNode::dispatch(v, *(const UndefDirectiveSyntax*)node); break;
        case SyntaxKind::TypedefKeywordDeclaration: SyntaxNode::dispatch(v, *(const TypedefKeywordDeclarationSyntax*)node); break;
        case SyntaxKind::OpenRangeList: SyntaxNode::dispatch(v, *(const OpenRangeListSyntax*)node); break;
        case SyntaxKind::RangeDimensionSpecifier: SyntaxNode::dispatch(v, *(const RangeDimensionSpecifierSyntax*)node); break;
        case SyntaxKind::VariableDeclarator: SyntaxNode::dispatch(v, *(const VariableDeclaratorSyntax*)node); break;
        case SyntaxKind::ArrayOrMethod: SyntaxNode::dispatch(v, *(const KeywordNameSyntax*)node); break;
        case SyntaxKind::ContinuousAssign: SyntaxNode::dispatch(v, *(const ContinuousAssignSyntax*)node); break;
        case SyntaxKind::EndIfDirective: SyntaxNode::dispatch(v, *(const UnconditionalBranchDirectiveSyntax*)node); break;
        case SyntaxKind::ImplicitEventControl: SyntaxNode::dispatch(v, *(const ImplicitEventControlSyntax*)node); break;
        case SyntaxKind::CycleDelay: SyntaxNode::dispatch(v, *(const DelaySyntax*)node); break;
        case SyntaxKind::NextTimePropertyExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::WaitOrderStatement: SyntaxNode::dispatch(v, *(const WaitOrderStatementSyntax*)node); break;
        case SyntaxKind::EmptyQueueExpression: SyntaxNode::dispatch(v, *(const EmptyQueueExpressionSyntax*)node); break;
        case SyntaxKind::TypeType: SyntaxNode::dispatch(v, *(const KeywordTypeSyntax*)node); break;
        case SyntaxKind::AssertPropertyStatement: SyntaxNode::dispatch(v, *(const ConcurrentAssertionStatementSyntax*)node); break;
        case SyntaxKind::SequenceType: SyntaxNode::dispatch(v, *(const KeywordTypeSyntax*)node); break;
        case SyntaxKind::ElsIfDirective: SyntaxNode::dispatch(v, *(const ConditionalBranchDirectiveSyntax*)node); break;
        case SyntaxKind::LessThanExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ConcatenationExpression: SyntaxNode::dispatch(v, *(const ConcatenationExpressionSyntax*)node); break;
        case SyntaxKind::UntilPropertyExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::NamedBlockClause: SyntaxNode::dispatch(v, *(const NamedBlockClauseSyntax*)node); break;
    }
}

}