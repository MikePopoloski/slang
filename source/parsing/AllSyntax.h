//------------------------------------------------------------------------------
// AllSyntax.h
// All generated syntax node data structures.
//
// File is under the MIT license; see LICENSE for details.
//------------------------------------------------------------------------------
#pragma once

#include <optional>

#include "lexing/Token.h"
#include "SyntaxNode.h"

// This file contains all parse tree syntax nodes.
// It is auto-generated by the syntax_gen.py script under the tools/ directory.

namespace slang {

struct ExpressionSyntax : public SyntaxNode {

    ExpressionSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct DataTypeSyntax : public ExpressionSyntax {

    DataTypeSyntax(SyntaxKind kind) :
        ExpressionSyntax(kind)
    {
    }
};

// ----- ATTRIBUTES -----

struct EqualsValueClauseSyntax : public SyntaxNode {
    Token equals;
    ExpressionSyntax& expr;

    EqualsValueClauseSyntax(Token equals, ExpressionSyntax& expr) :
        SyntaxNode(SyntaxKind::EqualsValueClause), equals(equals), expr(expr)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return equals;
            case 1: return &expr;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: equals = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct AttributeSpecSyntax : public SyntaxNode {
    Token name;
    EqualsValueClauseSyntax* value;

    AttributeSpecSyntax(Token name, EqualsValueClauseSyntax* value) :
        SyntaxNode(SyntaxKind::AttributeSpec), name(name), value(value)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return name;
            case 1: return value;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: name = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct AttributeInstanceSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<AttributeSpecSyntax> specs;
    Token closeParen;

    AttributeInstanceSyntax(Token openParen, SeparatedSyntaxList<AttributeSpecSyntax> specs, Token closeParen) :
        SyntaxNode(SyntaxKind::AttributeInstance), openParen(openParen), specs(specs), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &specs;
            case 2: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openParen = token; break;
            case 1: ASSERT(false); break;
            case 2: closeParen = token; break;
        }
    }
};

struct NamedLabelSyntax : public SyntaxNode {
    Token name;
    Token colon;

    NamedLabelSyntax(Token name, Token colon) :
        SyntaxNode(SyntaxKind::NamedLabel), name(name), colon(colon)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return name;
            case 1: return colon;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: name = token; break;
            case 1: colon = token; break;
        }
    }
};

struct StatementSyntax : public SyntaxNode {
    NamedLabelSyntax* label;
    SyntaxList<AttributeInstanceSyntax> attributes;

    StatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes) :
        SyntaxNode(kind), label(label), attributes(attributes)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
        }
        (void)token;
    }
};

struct MemberSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;

    MemberSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes) :
        SyntaxNode(kind), attributes(attributes)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override {
        switch (index) {
            case 0: return &attributes;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override {
        switch (index) {
            case 0: ASSERT(false); break;
        }
        (void)token;
    }
};

// ----- ARGUMENTS -----

struct ArgumentSyntax : public SyntaxNode {

    ArgumentSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct EmptyArgumentSyntax : public ArgumentSyntax {

    EmptyArgumentSyntax() :
        ArgumentSyntax(SyntaxKind::EmptyArgument)
    {
        childCount += 0;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        (void)index;
        return nullptr;
    }

    void replaceChild(uint32_t index, Token token) override final {
        (void)index;
        (void)token;
    }
};

struct OrderedArgumentSyntax : public ArgumentSyntax {
    ExpressionSyntax& expr;

    OrderedArgumentSyntax(ExpressionSyntax& expr) :
        ArgumentSyntax(SyntaxKind::OrderedArgument), expr(expr)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &expr;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
        }
        (void)token;
    }
};

struct NamedArgumentSyntax : public ArgumentSyntax {
    Token dot;
    Token name;
    Token openParen;
    ExpressionSyntax* expr;
    Token closeParen;

    NamedArgumentSyntax(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) :
        ArgumentSyntax(SyntaxKind::NamedArgument), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return dot;
            case 1: return name;
            case 2: return openParen;
            case 3: return expr;
            case 4: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: dot = token; break;
            case 1: name = token; break;
            case 2: openParen = token; break;
            case 3: ASSERT(false); break;
            case 4: closeParen = token; break;
        }
    }
};

struct ArgumentListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<ArgumentSyntax> parameters;
    Token closeParen;

    ArgumentListSyntax(Token openParen, SeparatedSyntaxList<ArgumentSyntax> parameters, Token closeParen) :
        SyntaxNode(SyntaxKind::ArgumentList), openParen(openParen), parameters(parameters), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &parameters;
            case 2: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openParen = token; break;
            case 1: ASSERT(false); break;
            case 2: closeParen = token; break;
        }
    }
};

struct ParameterValueAssignmentSyntax : public SyntaxNode {
    Token hash;
    ArgumentListSyntax& parameters;

    ParameterValueAssignmentSyntax(Token hash, ArgumentListSyntax& parameters) :
        SyntaxNode(SyntaxKind::ParameterValueAssignment), hash(hash), parameters(parameters)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return hash;
            case 1: return &parameters;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: hash = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

// ----- PATTERNS -----

struct PatternSyntax : public SyntaxNode {

    PatternSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct VariablePatternSyntax : public PatternSyntax {
    Token dot;
    Token variableName;

    VariablePatternSyntax(Token dot, Token variableName) :
        PatternSyntax(SyntaxKind::VariablePattern), dot(dot), variableName(variableName)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return dot;
            case 1: return variableName;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: dot = token; break;
            case 1: variableName = token; break;
        }
    }
};

struct WildcardPatternSyntax : public PatternSyntax {
    Token dotStar;

    WildcardPatternSyntax(Token dotStar) :
        PatternSyntax(SyntaxKind::WildcardPattern), dotStar(dotStar)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return dotStar;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: dotStar = token; break;
        }
    }
};

struct ExpressionPatternSyntax : public PatternSyntax {
    ExpressionSyntax& expr;

    ExpressionPatternSyntax(ExpressionSyntax& expr) :
        PatternSyntax(SyntaxKind::ExpressionPattern), expr(expr)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &expr;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
        }
        (void)token;
    }
};

struct TaggedPatternSyntax : public PatternSyntax {
    Token tagged;
    Token memberName;
    PatternSyntax* pattern;

    TaggedPatternSyntax(Token tagged, Token memberName, PatternSyntax* pattern) :
        PatternSyntax(SyntaxKind::TaggedPattern), tagged(tagged), memberName(memberName), pattern(pattern)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return tagged;
            case 1: return memberName;
            case 2: return pattern;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: tagged = token; break;
            case 1: memberName = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct StructurePatternMemberSyntax : public SyntaxNode {

    StructurePatternMemberSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct OrderedStructurePatternMemberSyntax : public StructurePatternMemberSyntax {
    PatternSyntax& pattern;

    OrderedStructurePatternMemberSyntax(PatternSyntax& pattern) :
        StructurePatternMemberSyntax(SyntaxKind::OrderedStructurePatternMember), pattern(pattern)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &pattern;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
        }
        (void)token;
    }
};

struct NamedStructurePatternMemberSyntax : public StructurePatternMemberSyntax {
    Token name;
    Token colon;
    PatternSyntax& pattern;

    NamedStructurePatternMemberSyntax(Token name, Token colon, PatternSyntax& pattern) :
        StructurePatternMemberSyntax(SyntaxKind::NamedStructurePatternMember), name(name), colon(colon), pattern(pattern)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return name;
            case 1: return colon;
            case 2: return &pattern;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: name = token; break;
            case 1: colon = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct StructurePatternSyntax : public PatternSyntax {
    Token openBrace;
    SeparatedSyntaxList<StructurePatternMemberSyntax> members;
    Token closeBrace;

    StructurePatternSyntax(Token openBrace, SeparatedSyntaxList<StructurePatternMemberSyntax> members, Token closeBrace) :
        PatternSyntax(SyntaxKind::StructurePattern), openBrace(openBrace), members(members), closeBrace(closeBrace)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return &members;
            case 2: return closeBrace;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openBrace = token; break;
            case 1: ASSERT(false); break;
            case 2: closeBrace = token; break;
        }
    }
};

struct MatchesClauseSyntax : public SyntaxNode {
    Token matchesKeyword;
    PatternSyntax& pattern;

    MatchesClauseSyntax(Token matchesKeyword, PatternSyntax& pattern) :
        SyntaxNode(SyntaxKind::MatchesClause), matchesKeyword(matchesKeyword), pattern(pattern)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return matchesKeyword;
            case 1: return &pattern;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: matchesKeyword = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct ConditionalPatternSyntax : public SyntaxNode {
    ExpressionSyntax& expr;
    MatchesClauseSyntax* matchesClause;

    ConditionalPatternSyntax(ExpressionSyntax& expr, MatchesClauseSyntax* matchesClause) :
        SyntaxNode(SyntaxKind::ConditionalPattern), expr(expr), matchesClause(matchesClause)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &expr;
            case 1: return matchesClause;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
        }
        (void)token;
    }
};

struct ConditionalPredicateSyntax : public SyntaxNode {
    SeparatedSyntaxList<ConditionalPatternSyntax> conditions;

    ConditionalPredicateSyntax(SeparatedSyntaxList<ConditionalPatternSyntax> conditions) :
        SyntaxNode(SyntaxKind::ConditionalPredicate), conditions(conditions)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &conditions;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
        }
        (void)token;
    }
};

struct AssignmentPatternSyntax : public SyntaxNode {

    AssignmentPatternSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct SimpleAssignmentPatternSyntax : public AssignmentPatternSyntax {
    Token openBrace;
    SeparatedSyntaxList<ExpressionSyntax> items;
    Token closeBrace;

    SimpleAssignmentPatternSyntax(Token openBrace, SeparatedSyntaxList<ExpressionSyntax> items, Token closeBrace) :
        AssignmentPatternSyntax(SyntaxKind::SimpleAssignmentPattern), openBrace(openBrace), items(items), closeBrace(closeBrace)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return &items;
            case 2: return closeBrace;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openBrace = token; break;
            case 1: ASSERT(false); break;
            case 2: closeBrace = token; break;
        }
    }
};

struct AssignmentPatternItemSyntax : public SyntaxNode {
    ExpressionSyntax& key;
    Token colon;
    ExpressionSyntax& expr;

    AssignmentPatternItemSyntax(ExpressionSyntax& key, Token colon, ExpressionSyntax& expr) :
        SyntaxNode(SyntaxKind::AssignmentPatternItem), key(key), colon(colon), expr(expr)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &key;
            case 1: return colon;
            case 2: return &expr;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: colon = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct StructuredAssignmentPatternSyntax : public AssignmentPatternSyntax {
    Token openBrace;
    SeparatedSyntaxList<AssignmentPatternItemSyntax> items;
    Token closeBrace;

    StructuredAssignmentPatternSyntax(Token openBrace, SeparatedSyntaxList<AssignmentPatternItemSyntax> items, Token closeBrace) :
        AssignmentPatternSyntax(SyntaxKind::StructuredAssignmentPattern), openBrace(openBrace), items(items), closeBrace(closeBrace)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return &items;
            case 2: return closeBrace;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openBrace = token; break;
            case 1: ASSERT(false); break;
            case 2: closeBrace = token; break;
        }
    }
};

struct ReplicatedAssignmentPatternSyntax : public AssignmentPatternSyntax {
    Token openBrace;
    ExpressionSyntax& countExpr;
    Token innerOpenBrace;
    SeparatedSyntaxList<ExpressionSyntax> items;
    Token innerCloseBrace;
    Token closeBrace;

    ReplicatedAssignmentPatternSyntax(Token openBrace, ExpressionSyntax& countExpr, Token innerOpenBrace, SeparatedSyntaxList<ExpressionSyntax> items, Token innerCloseBrace, Token closeBrace) :
        AssignmentPatternSyntax(SyntaxKind::ReplicatedAssignmentPattern), openBrace(openBrace), countExpr(countExpr), innerOpenBrace(innerOpenBrace), items(items), innerCloseBrace(innerCloseBrace), closeBrace(closeBrace)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return &countExpr;
            case 2: return innerOpenBrace;
            case 3: return &items;
            case 4: return innerCloseBrace;
            case 5: return closeBrace;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openBrace = token; break;
            case 1: ASSERT(false); break;
            case 2: innerOpenBrace = token; break;
            case 3: ASSERT(false); break;
            case 4: innerCloseBrace = token; break;
            case 5: closeBrace = token; break;
        }
    }
};

// ----- EXPRESSIONS -----

struct BadExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax& expr;

    BadExpressionSyntax(ExpressionSyntax& expr) :
        ExpressionSyntax(SyntaxKind::BadExpression), expr(expr)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &expr;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
        }
        (void)token;
    }
};

struct PrimaryExpressionSyntax : public ExpressionSyntax {

    PrimaryExpressionSyntax(SyntaxKind kind) :
        ExpressionSyntax(kind)
    {
    }
};

struct PrefixUnaryExpressionSyntax : public ExpressionSyntax {
    Token operatorToken;
    SyntaxList<AttributeInstanceSyntax> attributes;
    ExpressionSyntax& operand;

    PrefixUnaryExpressionSyntax(SyntaxKind kind, Token operatorToken, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& operand) :
        ExpressionSyntax(kind), operatorToken(operatorToken), attributes(attributes), operand(operand)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return operatorToken;
            case 1: return &attributes;
            case 2: return &operand;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: operatorToken = token; break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
        }
    }
};

struct PostfixUnaryExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax& operand;
    SyntaxList<AttributeInstanceSyntax> attributes;
    Token operatorToken;

    PostfixUnaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax& operand, SyntaxList<AttributeInstanceSyntax> attributes, Token operatorToken) :
        ExpressionSyntax(kind), operand(operand), attributes(attributes), operatorToken(operatorToken)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &operand;
            case 1: return &attributes;
            case 2: return operatorToken;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: operatorToken = token; break;
        }
    }
};

struct BinaryExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax& left;
    Token operatorToken;
    SyntaxList<AttributeInstanceSyntax> attributes;
    ExpressionSyntax& right;

    BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax& left, Token operatorToken, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& right) :
        ExpressionSyntax(kind), left(left), operatorToken(operatorToken), attributes(attributes), right(right)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &left;
            case 1: return operatorToken;
            case 2: return &attributes;
            case 3: return &right;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: operatorToken = token; break;
            case 2: ASSERT(false); break;
            case 3: ASSERT(false); break;
        }
    }
};

struct MinTypMaxExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax& min;
    Token colon1;
    ExpressionSyntax& typ;
    Token colon2;
    ExpressionSyntax& max;

    MinTypMaxExpressionSyntax(ExpressionSyntax& min, Token colon1, ExpressionSyntax& typ, Token colon2, ExpressionSyntax& max) :
        ExpressionSyntax(SyntaxKind::MinTypMaxExpression), min(min), colon1(colon1), typ(typ), colon2(colon2), max(max)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &min;
            case 1: return colon1;
            case 2: return &typ;
            case 3: return colon2;
            case 4: return &max;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: colon1 = token; break;
            case 2: ASSERT(false); break;
            case 3: colon2 = token; break;
            case 4: ASSERT(false); break;
        }
    }
};

struct TaggedUnionExpressionSyntax : public ExpressionSyntax {
    Token tagged;
    Token member;
    ExpressionSyntax* expr;

    TaggedUnionExpressionSyntax(Token tagged, Token member, ExpressionSyntax* expr) :
        ExpressionSyntax(SyntaxKind::TaggedUnionExpression), tagged(tagged), member(member), expr(expr)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return tagged;
            case 1: return member;
            case 2: return expr;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: tagged = token; break;
            case 1: member = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct OpenRangeListSyntax : public SyntaxNode {
    Token openBrace;
    SeparatedSyntaxList<ExpressionSyntax> valueRanges;
    Token closeBrace;

    OpenRangeListSyntax(Token openBrace, SeparatedSyntaxList<ExpressionSyntax> valueRanges, Token closeBrace) :
        SyntaxNode(SyntaxKind::OpenRangeList), openBrace(openBrace), valueRanges(valueRanges), closeBrace(closeBrace)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return &valueRanges;
            case 2: return closeBrace;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openBrace = token; break;
            case 1: ASSERT(false); break;
            case 2: closeBrace = token; break;
        }
    }
};

struct InsideExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax& expr;
    Token inside;
    OpenRangeListSyntax& ranges;

    InsideExpressionSyntax(ExpressionSyntax& expr, Token inside, OpenRangeListSyntax& ranges) :
        ExpressionSyntax(SyntaxKind::InsideExpression), expr(expr), inside(inside), ranges(ranges)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &expr;
            case 1: return inside;
            case 2: return &ranges;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: inside = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct ConditionalExpressionSyntax : public ExpressionSyntax {
    ConditionalPredicateSyntax& predicate;
    Token question;
    SyntaxList<AttributeInstanceSyntax> attributes;
    ExpressionSyntax& left;
    Token colon;
    ExpressionSyntax& right;

    ConditionalExpressionSyntax(ConditionalPredicateSyntax& predicate, Token question, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& left, Token colon, ExpressionSyntax& right) :
        ExpressionSyntax(SyntaxKind::ConditionalExpression), predicate(predicate), question(question), attributes(attributes), left(left), colon(colon), right(right)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &predicate;
            case 1: return question;
            case 2: return &attributes;
            case 3: return &left;
            case 4: return colon;
            case 5: return &right;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: question = token; break;
            case 2: ASSERT(false); break;
            case 3: ASSERT(false); break;
            case 4: colon = token; break;
            case 5: ASSERT(false); break;
        }
    }
};

struct AssignmentPatternExpressionSyntax : public PrimaryExpressionSyntax {
    DataTypeSyntax* type;
    AssignmentPatternSyntax& pattern;

    AssignmentPatternExpressionSyntax(DataTypeSyntax* type, AssignmentPatternSyntax& pattern) :
        PrimaryExpressionSyntax(SyntaxKind::AssignmentPatternExpression), type(type), pattern(pattern)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return type;
            case 1: return &pattern;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
        }
        (void)token;
    }
};

// ----- SELECTORS -----

struct SelectorSyntax : public SyntaxNode {

    SelectorSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct BitSelectSyntax : public SelectorSyntax {
    ExpressionSyntax& expr;

    BitSelectSyntax(ExpressionSyntax& expr) :
        SelectorSyntax(SyntaxKind::BitSelect), expr(expr)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &expr;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
        }
        (void)token;
    }
};

struct RangeSelectSyntax : public SelectorSyntax {
    ExpressionSyntax& left;
    Token range;
    ExpressionSyntax& right;

    RangeSelectSyntax(SyntaxKind kind, ExpressionSyntax& left, Token range, ExpressionSyntax& right) :
        SelectorSyntax(kind), left(left), range(range), right(right)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &left;
            case 1: return range;
            case 2: return &right;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: range = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct ElementSelectSyntax : public ExpressionSyntax {
    Token openBracket;
    SelectorSyntax* selector;
    Token closeBracket;

    ElementSelectSyntax(Token openBracket, SelectorSyntax* selector, Token closeBracket) :
        ExpressionSyntax(SyntaxKind::ElementSelect), openBracket(openBracket), selector(selector), closeBracket(closeBracket)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openBracket;
            case 1: return selector;
            case 2: return closeBracket;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openBracket = token; break;
            case 1: ASSERT(false); break;
            case 2: closeBracket = token; break;
        }
    }
};

// ----- NAMES -----

struct NameSyntax : public ExpressionSyntax {

    NameSyntax(SyntaxKind kind) :
        ExpressionSyntax(kind)
    {
    }
};

struct IdentifierNameSyntax : public NameSyntax {
    Token identifier;

    IdentifierNameSyntax(Token identifier) :
        NameSyntax(SyntaxKind::IdentifierName), identifier(identifier)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return identifier;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: identifier = token; break;
        }
    }
};

struct IdentifierSelectNameSyntax : public NameSyntax {
    Token identifier;
    SyntaxList<ElementSelectSyntax> selectors;

    IdentifierSelectNameSyntax(Token identifier, SyntaxList<ElementSelectSyntax> selectors) :
        NameSyntax(SyntaxKind::IdentifierSelectName), identifier(identifier), selectors(selectors)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return identifier;
            case 1: return &selectors;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: identifier = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct EmptyIdentifierNameSyntax : public NameSyntax {

    EmptyIdentifierNameSyntax() :
        NameSyntax(SyntaxKind::EmptyIdentifierName)
    {
        childCount += 0;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        (void)index;
        return nullptr;
    }

    void replaceChild(uint32_t index, Token token) override final {
        (void)index;
        (void)token;
    }
};

struct KeywordNameSyntax : public NameSyntax {
    Token keyword;

    KeywordNameSyntax(SyntaxKind kind, Token keyword) :
        NameSyntax(kind), keyword(keyword)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return keyword;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: keyword = token; break;
        }
    }
};

struct ClassNameSyntax : public NameSyntax {
    Token identifier;
    ParameterValueAssignmentSyntax& parameters;

    ClassNameSyntax(Token identifier, ParameterValueAssignmentSyntax& parameters) :
        NameSyntax(SyntaxKind::ClassName), identifier(identifier), parameters(parameters)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return identifier;
            case 1: return &parameters;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: identifier = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct ScopedNameSyntax : public NameSyntax {
    NameSyntax& left;
    Token separator;
    NameSyntax& right;

    ScopedNameSyntax(NameSyntax& left, Token separator, NameSyntax& right) :
        NameSyntax(SyntaxKind::ScopedName), left(left), separator(separator), right(right)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &left;
            case 1: return separator;
            case 2: return &right;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: separator = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct ClassScopeSyntax : public NameSyntax {
    NameSyntax& left;
    Token separator;

    ClassScopeSyntax(NameSyntax& left, Token separator) :
        NameSyntax(SyntaxKind::ClassScope), left(left), separator(separator)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &left;
            case 1: return separator;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: separator = token; break;
        }
    }
};

// ----- PRIMARY EXPRESSIONS -----

struct LiteralExpressionSyntax : public PrimaryExpressionSyntax {
    Token literal;

    LiteralExpressionSyntax(SyntaxKind kind, Token literal) :
        PrimaryExpressionSyntax(kind), literal(literal)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return literal;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: literal = token; break;
        }
    }
};

struct IntegerVectorExpressionSyntax : public PrimaryExpressionSyntax {
    Token size;
    Token base;
    Token value;

    IntegerVectorExpressionSyntax(Token size, Token base, Token value) :
        PrimaryExpressionSyntax(SyntaxKind::IntegerVectorExpression), size(size), base(base), value(value)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return size;
            case 1: return base;
            case 2: return value;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: size = token; break;
            case 1: base = token; break;
            case 2: value = token; break;
        }
    }
};

struct EmptyQueueExpressionSyntax : public PrimaryExpressionSyntax {
    Token openBrace;
    Token closeBrace;

    EmptyQueueExpressionSyntax(Token openBrace, Token closeBrace) :
        PrimaryExpressionSyntax(SyntaxKind::EmptyQueueExpression), openBrace(openBrace), closeBrace(closeBrace)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return closeBrace;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openBrace = token; break;
            case 1: closeBrace = token; break;
        }
    }
};

struct ConcatenationExpressionSyntax : public PrimaryExpressionSyntax {
    Token openBrace;
    SeparatedSyntaxList<ExpressionSyntax> expressions;
    Token closeBrace;

    ConcatenationExpressionSyntax(Token openBrace, SeparatedSyntaxList<ExpressionSyntax> expressions, Token closeBrace) :
        PrimaryExpressionSyntax(SyntaxKind::ConcatenationExpression), openBrace(openBrace), expressions(expressions), closeBrace(closeBrace)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return &expressions;
            case 2: return closeBrace;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openBrace = token; break;
            case 1: ASSERT(false); break;
            case 2: closeBrace = token; break;
        }
    }
};

struct MultipleConcatenationExpressionSyntax : public PrimaryExpressionSyntax {
    Token openBrace;
    ExpressionSyntax& expression;
    ConcatenationExpressionSyntax& concatenation;
    Token closeBrace;

    MultipleConcatenationExpressionSyntax(Token openBrace, ExpressionSyntax& expression, ConcatenationExpressionSyntax& concatenation, Token closeBrace) :
        PrimaryExpressionSyntax(SyntaxKind::MultipleConcatenationExpression), openBrace(openBrace), expression(expression), concatenation(concatenation), closeBrace(closeBrace)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return &expression;
            case 2: return &concatenation;
            case 3: return closeBrace;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openBrace = token; break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
            case 3: closeBrace = token; break;
        }
    }
};

struct StreamExpressionWithRange : public SyntaxNode {
    Token withKeyword;
    ElementSelectSyntax& range;

    StreamExpressionWithRange(Token withKeyword, ElementSelectSyntax& range) :
        SyntaxNode(SyntaxKind::StreamExpressionWithRange), withKeyword(withKeyword), range(range)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return withKeyword;
            case 1: return &range;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: withKeyword = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct StreamExpressionSyntax : public SyntaxNode {
    ExpressionSyntax& expression;
    StreamExpressionWithRange* withRange;

    StreamExpressionSyntax(ExpressionSyntax& expression, StreamExpressionWithRange* withRange) :
        SyntaxNode(SyntaxKind::StreamExpression), expression(expression), withRange(withRange)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &expression;
            case 1: return withRange;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
        }
        (void)token;
    }
};

struct StreamingConcatenationExpressionSyntax : public PrimaryExpressionSyntax {
    Token openBrace;
    Token operatorToken;
    ExpressionSyntax* sliceSize;
    Token innerOpenBrace;
    SeparatedSyntaxList<StreamExpressionSyntax> expressions;
    Token innerCloseBrace;
    Token closeBrace;

    StreamingConcatenationExpressionSyntax(Token openBrace, Token operatorToken, ExpressionSyntax* sliceSize, Token innerOpenBrace, SeparatedSyntaxList<StreamExpressionSyntax> expressions, Token innerCloseBrace, Token closeBrace) :
        PrimaryExpressionSyntax(SyntaxKind::StreamingConcatenationExpression), openBrace(openBrace), operatorToken(operatorToken), sliceSize(sliceSize), innerOpenBrace(innerOpenBrace), expressions(expressions), innerCloseBrace(innerCloseBrace), closeBrace(closeBrace)
    {
        childCount += 7;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return operatorToken;
            case 2: return sliceSize;
            case 3: return innerOpenBrace;
            case 4: return &expressions;
            case 5: return innerCloseBrace;
            case 6: return closeBrace;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openBrace = token; break;
            case 1: operatorToken = token; break;
            case 2: ASSERT(false); break;
            case 3: innerOpenBrace = token; break;
            case 4: ASSERT(false); break;
            case 5: innerCloseBrace = token; break;
            case 6: closeBrace = token; break;
        }
    }
};

struct ParenthesizedExpressionSyntax : public PrimaryExpressionSyntax {
    Token openParen;
    ExpressionSyntax& expression;
    Token closeParen;

    ParenthesizedExpressionSyntax(Token openParen, ExpressionSyntax& expression, Token closeParen) :
        PrimaryExpressionSyntax(SyntaxKind::ParenthesizedExpression), openParen(openParen), expression(expression), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &expression;
            case 2: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openParen = token; break;
            case 1: ASSERT(false); break;
            case 2: closeParen = token; break;
        }
    }
};

struct NewClassExpressionSyntax : public ExpressionSyntax {
    ClassScopeSyntax& classScope;
    Token newKeyword;
    ArgumentListSyntax* arguments;

    NewClassExpressionSyntax(ClassScopeSyntax& classScope, Token newKeyword, ArgumentListSyntax* arguments) :
        ExpressionSyntax(SyntaxKind::NewClassExpression), classScope(classScope), newKeyword(newKeyword), arguments(arguments)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &classScope;
            case 1: return newKeyword;
            case 2: return arguments;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: newKeyword = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct NewArrayExpressionSyntax : public ExpressionSyntax {
    Token newKeyword;
    Token openBracket;
    ExpressionSyntax& sizeExpr;
    Token closeBracket;
    ParenthesizedExpressionSyntax* initializer;

    NewArrayExpressionSyntax(Token newKeyword, Token openBracket, ExpressionSyntax& sizeExpr, Token closeBracket, ParenthesizedExpressionSyntax* initializer) :
        ExpressionSyntax(SyntaxKind::NewArrayExpression), newKeyword(newKeyword), openBracket(openBracket), sizeExpr(sizeExpr), closeBracket(closeBracket), initializer(initializer)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return newKeyword;
            case 1: return openBracket;
            case 2: return &sizeExpr;
            case 3: return closeBracket;
            case 4: return initializer;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: newKeyword = token; break;
            case 1: openBracket = token; break;
            case 2: ASSERT(false); break;
            case 3: closeBracket = token; break;
            case 4: ASSERT(false); break;
        }
    }
};

struct NewExpressionSyntax : public ExpressionSyntax {
    Token newKeyword;
    ExpressionSyntax& expr;

    NewExpressionSyntax(Token newKeyword, ExpressionSyntax& expr) :
        ExpressionSyntax(SyntaxKind::NewExpression), newKeyword(newKeyword), expr(expr)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return newKeyword;
            case 1: return &expr;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: newKeyword = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

// ----- POSTFIX EXPRESSIONS -----

struct ElementSelectExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax& left;
    ElementSelectSyntax& select;

    ElementSelectExpressionSyntax(ExpressionSyntax& left, ElementSelectSyntax& select) :
        ExpressionSyntax(SyntaxKind::ElementSelectExpression), left(left), select(select)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &left;
            case 1: return &select;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
        }
        (void)token;
    }
};

struct MemberAccessExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax& left;
    Token dot;
    Token name;

    MemberAccessExpressionSyntax(ExpressionSyntax& left, Token dot, Token name) :
        ExpressionSyntax(SyntaxKind::MemberAccessExpression), left(left), dot(dot), name(name)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &left;
            case 1: return dot;
            case 2: return name;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: dot = token; break;
            case 2: name = token; break;
        }
    }
};

struct InvocationExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax& left;
    SyntaxList<AttributeInstanceSyntax> attributes;
    ArgumentListSyntax* arguments;

    InvocationExpressionSyntax(ExpressionSyntax& left, SyntaxList<AttributeInstanceSyntax> attributes, ArgumentListSyntax* arguments) :
        ExpressionSyntax(SyntaxKind::InvocationExpression), left(left), attributes(attributes), arguments(arguments)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &left;
            case 1: return &attributes;
            case 2: return arguments;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
        }
        (void)token;
    }
};

struct CastExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax& left;
    Token apostrophe;
    ParenthesizedExpressionSyntax& right;

    CastExpressionSyntax(ExpressionSyntax& left, Token apostrophe, ParenthesizedExpressionSyntax& right) :
        ExpressionSyntax(SyntaxKind::CastExpression), left(left), apostrophe(apostrophe), right(right)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &left;
            case 1: return apostrophe;
            case 2: return &right;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: apostrophe = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct SignedCastExpressionSyntax : public ExpressionSyntax {
    Token signing;
    Token apostrophe;
    ParenthesizedExpressionSyntax& inner;

    SignedCastExpressionSyntax(Token signing, Token apostrophe, ParenthesizedExpressionSyntax& inner) :
        ExpressionSyntax(SyntaxKind::SignedCastExpression), signing(signing), apostrophe(apostrophe), inner(inner)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return signing;
            case 1: return apostrophe;
            case 2: return &inner;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: signing = token; break;
            case 1: apostrophe = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

// ----- TIMING CONTROL -----

struct TimingControlSyntax : public SyntaxNode {

    TimingControlSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct DelaySyntax : public TimingControlSyntax {
    Token hash;
    ExpressionSyntax& delayValue;

    DelaySyntax(SyntaxKind kind, Token hash, ExpressionSyntax& delayValue) :
        TimingControlSyntax(kind), hash(hash), delayValue(delayValue)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return hash;
            case 1: return &delayValue;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: hash = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct EventControlSyntax : public TimingControlSyntax {
    Token at;
    NameSyntax& eventName;

    EventControlSyntax(Token at, NameSyntax& eventName) :
        TimingControlSyntax(SyntaxKind::EventControl), at(at), eventName(eventName)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return at;
            case 1: return &eventName;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: at = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct EventExpressionSyntax : public SyntaxNode {

    EventExpressionSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct SignalEventExpressionSyntax : public EventExpressionSyntax {
    Token edge;
    ExpressionSyntax& expr;

    SignalEventExpressionSyntax(Token edge, ExpressionSyntax& expr) :
        EventExpressionSyntax(SyntaxKind::SignalEventExpression), edge(edge), expr(expr)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return edge;
            case 1: return &expr;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: edge = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct BinaryEventExpressionSyntax : public EventExpressionSyntax {
    EventExpressionSyntax& left;
    Token operatorToken;
    EventExpressionSyntax& right;

    BinaryEventExpressionSyntax(EventExpressionSyntax& left, Token operatorToken, EventExpressionSyntax& right) :
        EventExpressionSyntax(SyntaxKind::BinaryEventExpression), left(left), operatorToken(operatorToken), right(right)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &left;
            case 1: return operatorToken;
            case 2: return &right;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: operatorToken = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct ParenthesizedEventExpressionSyntax : public EventExpressionSyntax {
    Token openParen;
    EventExpressionSyntax& expr;
    Token closeParen;

    ParenthesizedEventExpressionSyntax(Token openParen, EventExpressionSyntax& expr, Token closeParen) :
        EventExpressionSyntax(SyntaxKind::ParenthesizedEventExpression), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &expr;
            case 2: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openParen = token; break;
            case 1: ASSERT(false); break;
            case 2: closeParen = token; break;
        }
    }
};

struct ImplicitEventControlSyntax : public TimingControlSyntax {
    Token atStar;

    ImplicitEventControlSyntax(Token atStar) :
        TimingControlSyntax(SyntaxKind::ImplicitEventControl), atStar(atStar)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return atStar;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: atStar = token; break;
        }
    }
};

struct ParenImplicitEventControlSyntax : public TimingControlSyntax {
    Token at;
    Token openParenStarCloseParen;

    ParenImplicitEventControlSyntax(Token at, Token openParenStarCloseParen) :
        TimingControlSyntax(SyntaxKind::ParenImplicitEventControl), at(at), openParenStarCloseParen(openParenStarCloseParen)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return at;
            case 1: return openParenStarCloseParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: at = token; break;
            case 1: openParenStarCloseParen = token; break;
        }
    }
};

struct EventControlWithExpressionSyntax : public TimingControlSyntax {
    Token at;
    EventExpressionSyntax& expr;

    EventControlWithExpressionSyntax(Token at, EventExpressionSyntax& expr) :
        TimingControlSyntax(SyntaxKind::EventControlWithExpression), at(at), expr(expr)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return at;
            case 1: return &expr;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: at = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct RepeatedEventControlSyntax : public TimingControlSyntax {
    Token repeat;
    Token openParen;
    ExpressionSyntax& expr;
    Token closeParen;
    TimingControlSyntax* eventControl;

    RepeatedEventControlSyntax(Token repeat, Token openParen, ExpressionSyntax& expr, Token closeParen, TimingControlSyntax* eventControl) :
        TimingControlSyntax(SyntaxKind::RepeatedEventControl), repeat(repeat), openParen(openParen), expr(expr), closeParen(closeParen), eventControl(eventControl)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return repeat;
            case 1: return openParen;
            case 2: return &expr;
            case 3: return closeParen;
            case 4: return eventControl;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: repeat = token; break;
            case 1: openParen = token; break;
            case 2: ASSERT(false); break;
            case 3: closeParen = token; break;
            case 4: ASSERT(false); break;
        }
    }
};

struct TimingControlExpressionSyntax : public ExpressionSyntax {
    TimingControlSyntax& timing;
    ExpressionSyntax& expr;

    TimingControlExpressionSyntax(TimingControlSyntax& timing, ExpressionSyntax& expr) :
        ExpressionSyntax(SyntaxKind::TimingControlExpression), timing(timing), expr(expr)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &timing;
            case 1: return &expr;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
        }
        (void)token;
    }
};

struct TimingControlExpressionConcatenationSyntax : public ExpressionSyntax {
    ExpressionSyntax& left;
    TimingControlSyntax& timing;
    ExpressionSyntax& right;

    TimingControlExpressionConcatenationSyntax(ExpressionSyntax& left, TimingControlSyntax& timing, ExpressionSyntax& right) :
        ExpressionSyntax(SyntaxKind::TimingControlExpressionConcatenation), left(left), timing(timing), right(right)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &left;
            case 1: return &timing;
            case 2: return &right;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
        }
        (void)token;
    }
};

struct ShortcutCycleDelayRangeSyntax : public TimingControlSyntax {
    Token doubleHash;
    Token openBracket;
    Token op;
    Token closeBracket;

    ShortcutCycleDelayRangeSyntax(Token doubleHash, Token openBracket, Token op, Token closeBracket) :
        TimingControlSyntax(SyntaxKind::ShortcutCycleDelayRange), doubleHash(doubleHash), openBracket(openBracket), op(op), closeBracket(closeBracket)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return doubleHash;
            case 1: return openBracket;
            case 2: return op;
            case 3: return closeBracket;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: doubleHash = token; break;
            case 1: openBracket = token; break;
            case 2: op = token; break;
            case 3: closeBracket = token; break;
        }
    }
};

// ----- DECLARATIONS -----

struct DimensionSpecifierSyntax : public SyntaxNode {

    DimensionSpecifierSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct RangeDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
    SelectorSyntax& selector;

    RangeDimensionSpecifierSyntax(SelectorSyntax& selector) :
        DimensionSpecifierSyntax(SyntaxKind::RangeDimensionSpecifier), selector(selector)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &selector;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
        }
        (void)token;
    }
};

struct DataTypeDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
    DataTypeSyntax& type;

    DataTypeDimensionSpecifierSyntax(DataTypeSyntax& type) :
        DimensionSpecifierSyntax(SyntaxKind::DataTypeDimensionSpecifier), type(type)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &type;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
        }
        (void)token;
    }
};

struct WildcardDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
    Token star;

    WildcardDimensionSpecifierSyntax(Token star) :
        DimensionSpecifierSyntax(SyntaxKind::WildcardDimensionSpecifier), star(star)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return star;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: star = token; break;
        }
    }
};

struct ColonExpressionClauseSyntax : public SyntaxNode {
    Token colon;
    ExpressionSyntax& expr;

    ColonExpressionClauseSyntax(Token colon, ExpressionSyntax& expr) :
        SyntaxNode(SyntaxKind::ColonExpressionClause), colon(colon), expr(expr)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return colon;
            case 1: return &expr;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: colon = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct QueueDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
    Token dollar;
    ColonExpressionClauseSyntax* maxSizeClause;

    QueueDimensionSpecifierSyntax(Token dollar, ColonExpressionClauseSyntax* maxSizeClause) :
        DimensionSpecifierSyntax(SyntaxKind::QueueDimensionSpecifier), dollar(dollar), maxSizeClause(maxSizeClause)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return dollar;
            case 1: return maxSizeClause;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: dollar = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct VariableDimensionSyntax : public SyntaxNode {
    Token openBracket;
    DimensionSpecifierSyntax* specifier;
    Token closeBracket;

    VariableDimensionSyntax(Token openBracket, DimensionSpecifierSyntax* specifier, Token closeBracket) :
        SyntaxNode(SyntaxKind::VariableDimension), openBracket(openBracket), specifier(specifier), closeBracket(closeBracket)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openBracket;
            case 1: return specifier;
            case 2: return closeBracket;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openBracket = token; break;
            case 1: ASSERT(false); break;
            case 2: closeBracket = token; break;
        }
    }
};

struct VariableDeclaratorSyntax : public SyntaxNode {
    Token name;
    SyntaxList<VariableDimensionSyntax> dimensions;
    EqualsValueClauseSyntax* initializer;

    VariableDeclaratorSyntax(Token name, SyntaxList<VariableDimensionSyntax> dimensions, EqualsValueClauseSyntax* initializer) :
        SyntaxNode(SyntaxKind::VariableDeclarator), name(name), dimensions(dimensions), initializer(initializer)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return name;
            case 1: return &dimensions;
            case 2: return initializer;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: name = token; break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
        }
    }
};

struct DataDeclarationSyntax : public MemberSyntax {
    TokenList modifiers;
    DataTypeSyntax& type;
    SeparatedSyntaxList<VariableDeclaratorSyntax> declarators;
    Token semi;

    DataDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList modifiers, DataTypeSyntax& type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token semi) :
        MemberSyntax(SyntaxKind::DataDeclaration, attributes), modifiers(modifiers), type(type), declarators(declarators), semi(semi)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &modifiers;
            case 2: return &type;
            case 3: return &declarators;
            case 4: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
            case 3: ASSERT(false); break;
            case 4: semi = token; break;
        }
    }
};

struct TypedefDeclarationSyntax : public MemberSyntax {
    Token typedefKeyword;
    DataTypeSyntax& type;
    Token name;
    SyntaxList<VariableDimensionSyntax> dimensions;
    Token semi;

    TypedefDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token typedefKeyword, DataTypeSyntax& type, Token name, SyntaxList<VariableDimensionSyntax> dimensions, Token semi) :
        MemberSyntax(SyntaxKind::TypedefDeclaration, attributes), typedefKeyword(typedefKeyword), type(type), name(name), dimensions(dimensions), semi(semi)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return typedefKeyword;
            case 2: return &type;
            case 3: return name;
            case 4: return &dimensions;
            case 5: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: typedefKeyword = token; break;
            case 2: ASSERT(false); break;
            case 3: name = token; break;
            case 4: ASSERT(false); break;
            case 5: semi = token; break;
        }
    }
};

struct TypedefKeywordDeclarationSyntax : public MemberSyntax {
    Token typedefKeyword;
    Token keyword;
    Token name;
    Token semi;

    TypedefKeywordDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token typedefKeyword, Token keyword, Token name, Token semi) :
        MemberSyntax(SyntaxKind::TypedefKeywordDeclaration, attributes), typedefKeyword(typedefKeyword), keyword(keyword), name(name), semi(semi)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return typedefKeyword;
            case 2: return keyword;
            case 3: return name;
            case 4: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: typedefKeyword = token; break;
            case 2: keyword = token; break;
            case 3: name = token; break;
            case 4: semi = token; break;
        }
    }
};

struct TypedefInterfaceClassDeclarationSyntax : public MemberSyntax {
    Token typedefKeyword;
    Token interfaceKeyword;
    Token classKeyword;
    Token name;
    Token semi;

    TypedefInterfaceClassDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token typedefKeyword, Token interfaceKeyword, Token classKeyword, Token name, Token semi) :
        MemberSyntax(SyntaxKind::TypedefInterfaceClassDeclaration, attributes), typedefKeyword(typedefKeyword), interfaceKeyword(interfaceKeyword), classKeyword(classKeyword), name(name), semi(semi)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return typedefKeyword;
            case 2: return interfaceKeyword;
            case 3: return classKeyword;
            case 4: return name;
            case 5: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: typedefKeyword = token; break;
            case 2: interfaceKeyword = token; break;
            case 3: classKeyword = token; break;
            case 4: name = token; break;
            case 5: semi = token; break;
        }
    }
};

struct NetStrengthSyntax : public SyntaxNode {

    NetStrengthSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct ChargeStrengthSyntax : public NetStrengthSyntax {
    Token openParen;
    Token strength;
    Token closeParen;

    ChargeStrengthSyntax(Token openParen, Token strength, Token closeParen) :
        NetStrengthSyntax(SyntaxKind::ChargeStrength), openParen(openParen), strength(strength), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openParen;
            case 1: return strength;
            case 2: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openParen = token; break;
            case 1: strength = token; break;
            case 2: closeParen = token; break;
        }
    }
};

struct DriveStrengthSyntax : public NetStrengthSyntax {
    Token openParen;
    Token strength0;
    Token comma;
    Token strength1;
    Token closeParen;

    DriveStrengthSyntax(Token openParen, Token strength0, Token comma, Token strength1, Token closeParen) :
        NetStrengthSyntax(SyntaxKind::DriveStrength), openParen(openParen), strength0(strength0), comma(comma), strength1(strength1), closeParen(closeParen)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openParen;
            case 1: return strength0;
            case 2: return comma;
            case 3: return strength1;
            case 4: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openParen = token; break;
            case 1: strength0 = token; break;
            case 2: comma = token; break;
            case 3: strength1 = token; break;
            case 4: closeParen = token; break;
        }
    }
};

struct NetDeclarationSyntax : public MemberSyntax {
    Token netType;
    NetStrengthSyntax* strength;
    Token expansionHint;
    DataTypeSyntax& type;
    SeparatedSyntaxList<VariableDeclaratorSyntax> declarators;
    Token semi;

    NetDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token netType, NetStrengthSyntax* strength, Token expansionHint, DataTypeSyntax& type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token semi) :
        MemberSyntax(SyntaxKind::NetDeclaration, attributes), netType(netType), strength(strength), expansionHint(expansionHint), type(type), declarators(declarators), semi(semi)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return netType;
            case 2: return strength;
            case 3: return expansionHint;
            case 4: return &type;
            case 5: return &declarators;
            case 6: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: netType = token; break;
            case 2: ASSERT(false); break;
            case 3: expansionHint = token; break;
            case 4: ASSERT(false); break;
            case 5: ASSERT(false); break;
            case 6: semi = token; break;
        }
    }
};

struct PackageImportItemSyntax : public SyntaxNode {
    Token package;
    Token doubleColon;
    Token item;

    PackageImportItemSyntax(Token package, Token doubleColon, Token item) :
        SyntaxNode(SyntaxKind::PackageImportItem), package(package), doubleColon(doubleColon), item(item)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return package;
            case 1: return doubleColon;
            case 2: return item;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: package = token; break;
            case 1: doubleColon = token; break;
            case 2: item = token; break;
        }
    }
};

struct PackageImportDeclarationSyntax : public MemberSyntax {
    Token keyword;
    SeparatedSyntaxList<PackageImportItemSyntax> items;
    Token semi;

    PackageImportDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, SeparatedSyntaxList<PackageImportItemSyntax> items, Token semi) :
        MemberSyntax(SyntaxKind::PackageImportDeclaration, attributes), keyword(keyword), items(items), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return &items;
            case 3: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: keyword = token; break;
            case 2: ASSERT(false); break;
            case 3: semi = token; break;
        }
    }
};

struct ParameterDeclarationSyntax : public SyntaxNode {
    Token keyword;
    DataTypeSyntax& type;
    SeparatedSyntaxList<VariableDeclaratorSyntax> declarators;

    ParameterDeclarationSyntax(Token keyword, DataTypeSyntax& type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators) :
        SyntaxNode(SyntaxKind::ParameterDeclaration), keyword(keyword), type(type), declarators(declarators)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return keyword;
            case 1: return &type;
            case 2: return &declarators;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: keyword = token; break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
        }
    }
};

struct ParameterDeclarationStatementSyntax : public MemberSyntax {
    ParameterDeclarationSyntax& parameter;
    Token semi;

    ParameterDeclarationStatementSyntax(SyntaxList<AttributeInstanceSyntax> attributes, ParameterDeclarationSyntax& parameter, Token semi) :
        MemberSyntax(SyntaxKind::ParameterDeclarationStatement, attributes), parameter(parameter), semi(semi)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &parameter;
            case 2: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: semi = token; break;
        }
    }
};

struct PortHeaderSyntax : public SyntaxNode {

    PortHeaderSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct PortDeclarationSyntax : public MemberSyntax {
    PortHeaderSyntax& header;
    SeparatedSyntaxList<VariableDeclaratorSyntax> declarators;
    Token semi;

    PortDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, PortHeaderSyntax& header, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token semi) :
        MemberSyntax(SyntaxKind::PortDeclaration, attributes), header(header), declarators(declarators), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &header;
            case 2: return &declarators;
            case 3: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
            case 3: semi = token; break;
        }
    }
};

struct GenvarDeclarationSyntax : public MemberSyntax {
    Token keyword;
    SeparatedSyntaxList<IdentifierNameSyntax> identifiers;
    Token semi;

    GenvarDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, SeparatedSyntaxList<IdentifierNameSyntax> identifiers, Token semi) :
        MemberSyntax(SyntaxKind::GenvarDeclaration, attributes), keyword(keyword), identifiers(identifiers), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return &identifiers;
            case 3: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: keyword = token; break;
            case 2: ASSERT(false); break;
            case 3: semi = token; break;
        }
    }
};

// ----- TYPES -----

struct IntegerTypeSyntax : public DataTypeSyntax {
    Token keyword;
    Token signing;
    SyntaxList<VariableDimensionSyntax> dimensions;

    IntegerTypeSyntax(SyntaxKind kind, Token keyword, Token signing, SyntaxList<VariableDimensionSyntax> dimensions) :
        DataTypeSyntax(kind), keyword(keyword), signing(signing), dimensions(dimensions)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return keyword;
            case 1: return signing;
            case 2: return &dimensions;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: keyword = token; break;
            case 1: signing = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct KeywordTypeSyntax : public DataTypeSyntax {
    Token keyword;

    KeywordTypeSyntax(SyntaxKind kind, Token keyword) :
        DataTypeSyntax(kind), keyword(keyword)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return keyword;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: keyword = token; break;
        }
    }
};

struct NamedTypeSyntax : public DataTypeSyntax {
    NameSyntax& name;

    NamedTypeSyntax(NameSyntax& name) :
        DataTypeSyntax(SyntaxKind::NamedType), name(name)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &name;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
        }
        (void)token;
    }
};

struct StructUnionMemberSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;
    Token randomQualifier;
    DataTypeSyntax& type;
    SeparatedSyntaxList<VariableDeclaratorSyntax> declarators;
    Token semi;

    StructUnionMemberSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token randomQualifier, DataTypeSyntax& type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token semi) :
        SyntaxNode(SyntaxKind::StructUnionMember), attributes(attributes), randomQualifier(randomQualifier), type(type), declarators(declarators), semi(semi)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return randomQualifier;
            case 2: return &type;
            case 3: return &declarators;
            case 4: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: randomQualifier = token; break;
            case 2: ASSERT(false); break;
            case 3: ASSERT(false); break;
            case 4: semi = token; break;
        }
    }
};

struct StructUnionTypeSyntax : public DataTypeSyntax {
    Token keyword;
    Token tagged;
    Token packed;
    Token signing;
    Token openBrace;
    SyntaxList<StructUnionMemberSyntax> members;
    Token closeBrace;
    SyntaxList<VariableDimensionSyntax> dimensions;

    StructUnionTypeSyntax(SyntaxKind kind, Token keyword, Token tagged, Token packed, Token signing, Token openBrace, SyntaxList<StructUnionMemberSyntax> members, Token closeBrace, SyntaxList<VariableDimensionSyntax> dimensions) :
        DataTypeSyntax(kind), keyword(keyword), tagged(tagged), packed(packed), signing(signing), openBrace(openBrace), members(members), closeBrace(closeBrace), dimensions(dimensions)
    {
        childCount += 8;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return keyword;
            case 1: return tagged;
            case 2: return packed;
            case 3: return signing;
            case 4: return openBrace;
            case 5: return &members;
            case 6: return closeBrace;
            case 7: return &dimensions;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: keyword = token; break;
            case 1: tagged = token; break;
            case 2: packed = token; break;
            case 3: signing = token; break;
            case 4: openBrace = token; break;
            case 5: ASSERT(false); break;
            case 6: closeBrace = token; break;
            case 7: ASSERT(false); break;
        }
    }
};

struct EnumTypeSyntax : public DataTypeSyntax {
    Token keyword;
    DataTypeSyntax* baseType;
    Token openBrace;
    SeparatedSyntaxList<VariableDeclaratorSyntax> members;
    Token closeBrace;
    SyntaxList<VariableDimensionSyntax> dimensions;

    EnumTypeSyntax(Token keyword, DataTypeSyntax* baseType, Token openBrace, SeparatedSyntaxList<VariableDeclaratorSyntax> members, Token closeBrace, SyntaxList<VariableDimensionSyntax> dimensions) :
        DataTypeSyntax(SyntaxKind::EnumType), keyword(keyword), baseType(baseType), openBrace(openBrace), members(members), closeBrace(closeBrace), dimensions(dimensions)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return keyword;
            case 1: return baseType;
            case 2: return openBrace;
            case 3: return &members;
            case 4: return closeBrace;
            case 5: return &dimensions;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: keyword = token; break;
            case 1: ASSERT(false); break;
            case 2: openBrace = token; break;
            case 3: ASSERT(false); break;
            case 4: closeBrace = token; break;
            case 5: ASSERT(false); break;
        }
    }
};

struct TypeReferenceSyntax : public DataTypeSyntax {
    Token typeKeyword;
    Token openParen;
    ExpressionSyntax& expr;
    Token closeParen;

    TypeReferenceSyntax(Token typeKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen) :
        DataTypeSyntax(SyntaxKind::TypeReference), typeKeyword(typeKeyword), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return typeKeyword;
            case 1: return openParen;
            case 2: return &expr;
            case 3: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: typeKeyword = token; break;
            case 1: openParen = token; break;
            case 2: ASSERT(false); break;
            case 3: closeParen = token; break;
        }
    }
};

struct DotMemberClauseSyntax : public SyntaxNode {
    Token dot;
    Token member;

    DotMemberClauseSyntax(Token dot, Token member) :
        SyntaxNode(SyntaxKind::DotMemberClause), dot(dot), member(member)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return dot;
            case 1: return member;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: dot = token; break;
            case 1: member = token; break;
        }
    }
};

struct VirtualInterfaceTypeSyntax : public DataTypeSyntax {
    Token virtualKeyword;
    Token interfaceKeyword;
    Token name;
    ParameterValueAssignmentSyntax* parameters;
    DotMemberClauseSyntax* modport;

    VirtualInterfaceTypeSyntax(Token virtualKeyword, Token interfaceKeyword, Token name, ParameterValueAssignmentSyntax* parameters, DotMemberClauseSyntax* modport) :
        DataTypeSyntax(SyntaxKind::VirtualInterfaceType), virtualKeyword(virtualKeyword), interfaceKeyword(interfaceKeyword), name(name), parameters(parameters), modport(modport)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return virtualKeyword;
            case 1: return interfaceKeyword;
            case 2: return name;
            case 3: return parameters;
            case 4: return modport;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: virtualKeyword = token; break;
            case 1: interfaceKeyword = token; break;
            case 2: name = token; break;
            case 3: ASSERT(false); break;
            case 4: ASSERT(false); break;
        }
    }
};

struct ImplicitTypeSyntax : public DataTypeSyntax {
    Token signing;
    SyntaxList<VariableDimensionSyntax> dimensions;

    ImplicitTypeSyntax(Token signing, SyntaxList<VariableDimensionSyntax> dimensions) :
        DataTypeSyntax(SyntaxKind::ImplicitType), signing(signing), dimensions(dimensions)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return signing;
            case 1: return &dimensions;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: signing = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct VarDataTypeSyntax : public DataTypeSyntax {
    Token var;
    DataTypeSyntax& type;

    VarDataTypeSyntax(Token var, DataTypeSyntax& type) :
        DataTypeSyntax(SyntaxKind::VarDataType), var(var), type(type)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return var;
            case 1: return &type;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: var = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

// ----- ASSERTIONS -----

struct DeferredAssertionSyntax : public SyntaxNode {
    Token hash;
    Token zero;
    Token finalKeyword;

    DeferredAssertionSyntax(Token hash, Token zero, Token finalKeyword) :
        SyntaxNode(SyntaxKind::DeferredAssertion), hash(hash), zero(zero), finalKeyword(finalKeyword)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return hash;
            case 1: return zero;
            case 2: return finalKeyword;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: hash = token; break;
            case 1: zero = token; break;
            case 2: finalKeyword = token; break;
        }
    }
};

struct ElseClauseSyntax : public SyntaxNode {
    Token elseKeyword;
    SyntaxNode& clause;

    ElseClauseSyntax(Token elseKeyword, SyntaxNode& clause) :
        SyntaxNode(SyntaxKind::ElseClause), elseKeyword(elseKeyword), clause(clause)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return elseKeyword;
            case 1: return &clause;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: elseKeyword = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct ActionBlockSyntax : public SyntaxNode {
    StatementSyntax* statement;
    ElseClauseSyntax* elseClause;

    ActionBlockSyntax(StatementSyntax* statement, ElseClauseSyntax* elseClause) :
        SyntaxNode(SyntaxKind::ActionBlock), statement(statement), elseClause(elseClause)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return statement;
            case 1: return elseClause;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
        }
        (void)token;
    }
};

struct ImmediateAssertionStatementSyntax : public StatementSyntax {
    Token keyword;
    DeferredAssertionSyntax* delay;
    ParenthesizedExpressionSyntax& expr;
    ActionBlockSyntax& action;

    ImmediateAssertionStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, DeferredAssertionSyntax* delay, ParenthesizedExpressionSyntax& expr, ActionBlockSyntax& action) :
        StatementSyntax(kind, label, attributes), keyword(keyword), delay(delay), expr(expr), action(action)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return keyword;
            case 3: return delay;
            case 4: return &expr;
            case 5: return &action;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: keyword = token; break;
            case 3: ASSERT(false); break;
            case 4: ASSERT(false); break;
            case 5: ASSERT(false); break;
        }
    }
};

struct DisableIffSyntax : public SyntaxNode {
    Token disable;
    Token iff;
    Token openParen;
    ExpressionSyntax& expr;
    Token closeParen;

    DisableIffSyntax(Token disable, Token iff, Token openParen, ExpressionSyntax& expr, Token closeParen) :
        SyntaxNode(SyntaxKind::DisableIff), disable(disable), iff(iff), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return disable;
            case 1: return iff;
            case 2: return openParen;
            case 3: return &expr;
            case 4: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: disable = token; break;
            case 1: iff = token; break;
            case 2: openParen = token; break;
            case 3: ASSERT(false); break;
            case 4: closeParen = token; break;
        }
    }
};

struct PropertySpecSyntax : public SyntaxNode {
    TimingControlSyntax* clocking;
    DisableIffSyntax* disable;
    ExpressionSyntax& expr;

    PropertySpecSyntax(TimingControlSyntax* clocking, DisableIffSyntax* disable, ExpressionSyntax& expr) :
        SyntaxNode(SyntaxKind::PropertySpec), clocking(clocking), disable(disable), expr(expr)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return clocking;
            case 1: return disable;
            case 2: return &expr;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
        }
        (void)token;
    }
};

struct ConcurrentAssertionStatementSyntax : public StatementSyntax {
    Token keyword;
    Token propertyOrSequence;
    Token openParen;
    PropertySpecSyntax& propertySpec;
    Token closeParen;
    ActionBlockSyntax& action;

    ConcurrentAssertionStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token propertyOrSequence, Token openParen, PropertySpecSyntax& propertySpec, Token closeParen, ActionBlockSyntax& action) :
        StatementSyntax(kind, label, attributes), keyword(keyword), propertyOrSequence(propertyOrSequence), openParen(openParen), propertySpec(propertySpec), closeParen(closeParen), action(action)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return keyword;
            case 3: return propertyOrSequence;
            case 4: return openParen;
            case 5: return &propertySpec;
            case 6: return closeParen;
            case 7: return &action;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: keyword = token; break;
            case 3: propertyOrSequence = token; break;
            case 4: openParen = token; break;
            case 5: ASSERT(false); break;
            case 6: closeParen = token; break;
            case 7: ASSERT(false); break;
        }
    }
};

struct ConcurrentAssertionMemberSyntax : public MemberSyntax {
    ConcurrentAssertionStatementSyntax& statement;

    ConcurrentAssertionMemberSyntax(SyntaxList<AttributeInstanceSyntax> attributes, ConcurrentAssertionStatementSyntax& statement) :
        MemberSyntax(SyntaxKind::ConcurrentAssertionMember, attributes), statement(statement)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &statement;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
        }
        (void)token;
    }
};

struct ImmediateAssertionMemberSyntax : public MemberSyntax {
    ImmediateAssertionStatementSyntax& statement;

    ImmediateAssertionMemberSyntax(SyntaxList<AttributeInstanceSyntax> attributes, ImmediateAssertionStatementSyntax& statement) :
        MemberSyntax(SyntaxKind::ImmediateAssertionMember, attributes), statement(statement)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &statement;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
        }
        (void)token;
    }
};

// ----- STATEMENTS -----

struct EmptyStatementSyntax : public StatementSyntax {
    Token semicolon;

    EmptyStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token semicolon) :
        StatementSyntax(SyntaxKind::EmptyStatement, label, attributes), semicolon(semicolon)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return semicolon;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: semicolon = token; break;
        }
    }
};

struct ConditionalStatementSyntax : public StatementSyntax {
    Token uniqueOrPriority;
    Token ifKeyword;
    Token openParen;
    ConditionalPredicateSyntax& predicate;
    Token closeParen;
    StatementSyntax& statement;
    ElseClauseSyntax* elseClause;

    ConditionalStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token uniqueOrPriority, Token ifKeyword, Token openParen, ConditionalPredicateSyntax& predicate, Token closeParen, StatementSyntax& statement, ElseClauseSyntax* elseClause) :
        StatementSyntax(SyntaxKind::ConditionalStatement, label, attributes), uniqueOrPriority(uniqueOrPriority), ifKeyword(ifKeyword), openParen(openParen), predicate(predicate), closeParen(closeParen), statement(statement), elseClause(elseClause)
    {
        childCount += 7;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return uniqueOrPriority;
            case 3: return ifKeyword;
            case 4: return openParen;
            case 5: return &predicate;
            case 6: return closeParen;
            case 7: return &statement;
            case 8: return elseClause;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: uniqueOrPriority = token; break;
            case 3: ifKeyword = token; break;
            case 4: openParen = token; break;
            case 5: ASSERT(false); break;
            case 6: closeParen = token; break;
            case 7: ASSERT(false); break;
            case 8: ASSERT(false); break;
        }
    }
};

struct CaseItemSyntax : public SyntaxNode {

    CaseItemSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct DefaultCaseItemSyntax : public CaseItemSyntax {
    Token defaultKeyword;
    Token colon;
    SyntaxNode& clause;

    DefaultCaseItemSyntax(Token defaultKeyword, Token colon, SyntaxNode& clause) :
        CaseItemSyntax(SyntaxKind::DefaultCaseItem), defaultKeyword(defaultKeyword), colon(colon), clause(clause)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return defaultKeyword;
            case 1: return colon;
            case 2: return &clause;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: defaultKeyword = token; break;
            case 1: colon = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct PatternCaseItemSyntax : public CaseItemSyntax {
    PatternSyntax& pattern;
    Token tripleAnd;
    ExpressionSyntax* expr;
    Token colon;
    StatementSyntax& statement;

    PatternCaseItemSyntax(PatternSyntax& pattern, Token tripleAnd, ExpressionSyntax* expr, Token colon, StatementSyntax& statement) :
        CaseItemSyntax(SyntaxKind::PatternCaseItem), pattern(pattern), tripleAnd(tripleAnd), expr(expr), colon(colon), statement(statement)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &pattern;
            case 1: return tripleAnd;
            case 2: return expr;
            case 3: return colon;
            case 4: return &statement;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: tripleAnd = token; break;
            case 2: ASSERT(false); break;
            case 3: colon = token; break;
            case 4: ASSERT(false); break;
        }
    }
};

struct StandardCaseItemSyntax : public CaseItemSyntax {
    SeparatedSyntaxList<ExpressionSyntax> expressions;
    Token colon;
    SyntaxNode& clause;

    StandardCaseItemSyntax(SeparatedSyntaxList<ExpressionSyntax> expressions, Token colon, SyntaxNode& clause) :
        CaseItemSyntax(SyntaxKind::StandardCaseItem), expressions(expressions), colon(colon), clause(clause)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &expressions;
            case 1: return colon;
            case 2: return &clause;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: colon = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct CaseStatementSyntax : public StatementSyntax {
    Token uniqueOrPriority;
    Token caseKeyword;
    Token openParen;
    ExpressionSyntax& expr;
    Token closeParen;
    Token matchesOrInside;
    SyntaxList<CaseItemSyntax> items;
    Token endcase;

    CaseStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token uniqueOrPriority, Token caseKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen, Token matchesOrInside, SyntaxList<CaseItemSyntax> items, Token endcase) :
        StatementSyntax(SyntaxKind::CaseStatement, label, attributes), uniqueOrPriority(uniqueOrPriority), caseKeyword(caseKeyword), openParen(openParen), expr(expr), closeParen(closeParen), matchesOrInside(matchesOrInside), items(items), endcase(endcase)
    {
        childCount += 8;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return uniqueOrPriority;
            case 3: return caseKeyword;
            case 4: return openParen;
            case 5: return &expr;
            case 6: return closeParen;
            case 7: return matchesOrInside;
            case 8: return &items;
            case 9: return endcase;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: uniqueOrPriority = token; break;
            case 3: caseKeyword = token; break;
            case 4: openParen = token; break;
            case 5: ASSERT(false); break;
            case 6: closeParen = token; break;
            case 7: matchesOrInside = token; break;
            case 8: ASSERT(false); break;
            case 9: endcase = token; break;
        }
    }
};

struct ForeverStatementSyntax : public StatementSyntax {
    Token foreverKeyword;
    StatementSyntax& statement;

    ForeverStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token foreverKeyword, StatementSyntax& statement) :
        StatementSyntax(SyntaxKind::ForeverStatement, label, attributes), foreverKeyword(foreverKeyword), statement(statement)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return foreverKeyword;
            case 3: return &statement;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: foreverKeyword = token; break;
            case 3: ASSERT(false); break;
        }
    }
};

struct LoopStatementSyntax : public StatementSyntax {
    Token repeatOrWhile;
    Token openParen;
    ExpressionSyntax& expr;
    Token closeParen;
    StatementSyntax& statement;

    LoopStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token repeatOrWhile, Token openParen, ExpressionSyntax& expr, Token closeParen, StatementSyntax& statement) :
        StatementSyntax(SyntaxKind::LoopStatement, label, attributes), repeatOrWhile(repeatOrWhile), openParen(openParen), expr(expr), closeParen(closeParen), statement(statement)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return repeatOrWhile;
            case 3: return openParen;
            case 4: return &expr;
            case 5: return closeParen;
            case 6: return &statement;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: repeatOrWhile = token; break;
            case 3: openParen = token; break;
            case 4: ASSERT(false); break;
            case 5: closeParen = token; break;
            case 6: ASSERT(false); break;
        }
    }
};

struct DoWhileStatementSyntax : public StatementSyntax {
    Token doKeyword;
    StatementSyntax& statement;
    Token whileKeyword;
    Token openParen;
    ExpressionSyntax& expr;
    Token closeParen;
    Token semi;

    DoWhileStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token doKeyword, StatementSyntax& statement, Token whileKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen, Token semi) :
        StatementSyntax(SyntaxKind::DoWhileStatement, label, attributes), doKeyword(doKeyword), statement(statement), whileKeyword(whileKeyword), openParen(openParen), expr(expr), closeParen(closeParen), semi(semi)
    {
        childCount += 7;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return doKeyword;
            case 3: return &statement;
            case 4: return whileKeyword;
            case 5: return openParen;
            case 6: return &expr;
            case 7: return closeParen;
            case 8: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: doKeyword = token; break;
            case 3: ASSERT(false); break;
            case 4: whileKeyword = token; break;
            case 5: openParen = token; break;
            case 6: ASSERT(false); break;
            case 7: closeParen = token; break;
            case 8: semi = token; break;
        }
    }
};

struct ForVariableDeclarationSyntax : public SyntaxNode {
    Token varKeyword;
    DataTypeSyntax& type;
    VariableDeclaratorSyntax& declarator;

    ForVariableDeclarationSyntax(Token varKeyword, DataTypeSyntax& type, VariableDeclaratorSyntax& declarator) :
        SyntaxNode(SyntaxKind::ForVariableDeclaration), varKeyword(varKeyword), type(type), declarator(declarator)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return varKeyword;
            case 1: return &type;
            case 2: return &declarator;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: varKeyword = token; break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
        }
    }
};

struct ForLoopStatementSyntax : public StatementSyntax {
    Token forKeyword;
    Token openParen;
    SeparatedSyntaxList<SyntaxNode> initializers;
    Token semi1;
    ExpressionSyntax& stopExpr;
    Token semi2;
    SeparatedSyntaxList<ExpressionSyntax> steps;
    Token closeParen;
    StatementSyntax& statement;

    ForLoopStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token forKeyword, Token openParen, SeparatedSyntaxList<SyntaxNode> initializers, Token semi1, ExpressionSyntax& stopExpr, Token semi2, SeparatedSyntaxList<ExpressionSyntax> steps, Token closeParen, StatementSyntax& statement) :
        StatementSyntax(SyntaxKind::ForLoopStatement, label, attributes), forKeyword(forKeyword), openParen(openParen), initializers(initializers), semi1(semi1), stopExpr(stopExpr), semi2(semi2), steps(steps), closeParen(closeParen), statement(statement)
    {
        childCount += 9;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return forKeyword;
            case 3: return openParen;
            case 4: return &initializers;
            case 5: return semi1;
            case 6: return &stopExpr;
            case 7: return semi2;
            case 8: return &steps;
            case 9: return closeParen;
            case 10: return &statement;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: forKeyword = token; break;
            case 3: openParen = token; break;
            case 4: ASSERT(false); break;
            case 5: semi1 = token; break;
            case 6: ASSERT(false); break;
            case 7: semi2 = token; break;
            case 8: ASSERT(false); break;
            case 9: closeParen = token; break;
            case 10: ASSERT(false); break;
        }
    }
};

struct ForeachLoopListSyntax : public SyntaxNode {
    Token openParen;
    NameSyntax& arrayName;
    Token openBracket;
    SeparatedSyntaxList<NameSyntax> loopVariables;
    Token closeBracket;
    Token closeParen;

    ForeachLoopListSyntax(Token openParen, NameSyntax& arrayName, Token openBracket, SeparatedSyntaxList<NameSyntax> loopVariables, Token closeBracket, Token closeParen) :
        SyntaxNode(SyntaxKind::ForeachLoopList), openParen(openParen), arrayName(arrayName), openBracket(openBracket), loopVariables(loopVariables), closeBracket(closeBracket), closeParen(closeParen)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &arrayName;
            case 2: return openBracket;
            case 3: return &loopVariables;
            case 4: return closeBracket;
            case 5: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openParen = token; break;
            case 1: ASSERT(false); break;
            case 2: openBracket = token; break;
            case 3: ASSERT(false); break;
            case 4: closeBracket = token; break;
            case 5: closeParen = token; break;
        }
    }
};

struct ForeachLoopStatementSyntax : public StatementSyntax {
    Token keyword;
    ForeachLoopListSyntax& loopList;
    StatementSyntax& statement;

    ForeachLoopStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, ForeachLoopListSyntax& loopList, StatementSyntax& statement) :
        StatementSyntax(SyntaxKind::ForeachLoopStatement, label, attributes), keyword(keyword), loopList(loopList), statement(statement)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return keyword;
            case 3: return &loopList;
            case 4: return &statement;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: keyword = token; break;
            case 3: ASSERT(false); break;
            case 4: ASSERT(false); break;
        }
    }
};

struct ReturnStatementSyntax : public StatementSyntax {
    Token returnKeyword;
    ExpressionSyntax* returnValue;
    Token semi;

    ReturnStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token returnKeyword, ExpressionSyntax* returnValue, Token semi) :
        StatementSyntax(SyntaxKind::ReturnStatement, label, attributes), returnKeyword(returnKeyword), returnValue(returnValue), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return returnKeyword;
            case 3: return returnValue;
            case 4: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: returnKeyword = token; break;
            case 3: ASSERT(false); break;
            case 4: semi = token; break;
        }
    }
};

struct JumpStatementSyntax : public StatementSyntax {
    Token breakOrContinue;
    Token semi;

    JumpStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token breakOrContinue, Token semi) :
        StatementSyntax(SyntaxKind::JumpStatement, label, attributes), breakOrContinue(breakOrContinue), semi(semi)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return breakOrContinue;
            case 3: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: breakOrContinue = token; break;
            case 3: semi = token; break;
        }
    }
};

struct TimingControlStatementSyntax : public StatementSyntax {
    TimingControlSyntax& timingControl;
    StatementSyntax& statement;

    TimingControlStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, TimingControlSyntax& timingControl, StatementSyntax& statement) :
        StatementSyntax(SyntaxKind::TimingControlStatement, label, attributes), timingControl(timingControl), statement(statement)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return &timingControl;
            case 3: return &statement;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
            case 3: ASSERT(false); break;
        }
        (void)token;
    }
};

struct ExpressionStatementSyntax : public StatementSyntax {
    ExpressionSyntax& expr;
    Token semi;

    ExpressionStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& expr, Token semi) :
        StatementSyntax(SyntaxKind::ExpressionStatement, label, attributes), expr(expr), semi(semi)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return &expr;
            case 3: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
            case 3: semi = token; break;
        }
    }
};

struct ProceduralAssignStatementSyntax : public StatementSyntax {
    Token keyword;
    ExpressionSyntax& lvalue;
    Token equals;
    ExpressionSyntax& value;
    Token semi;

    ProceduralAssignStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, ExpressionSyntax& lvalue, Token equals, ExpressionSyntax& value, Token semi) :
        StatementSyntax(kind, label, attributes), keyword(keyword), lvalue(lvalue), equals(equals), value(value), semi(semi)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return keyword;
            case 3: return &lvalue;
            case 4: return equals;
            case 5: return &value;
            case 6: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: keyword = token; break;
            case 3: ASSERT(false); break;
            case 4: equals = token; break;
            case 5: ASSERT(false); break;
            case 6: semi = token; break;
        }
    }
};

struct ProceduralDeassignStatementSyntax : public StatementSyntax {
    Token keyword;
    ExpressionSyntax& variable;
    Token semi;

    ProceduralDeassignStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, ExpressionSyntax& variable, Token semi) :
        StatementSyntax(kind, label, attributes), keyword(keyword), variable(variable), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return keyword;
            case 3: return &variable;
            case 4: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: keyword = token; break;
            case 3: ASSERT(false); break;
            case 4: semi = token; break;
        }
    }
};

struct DisableStatementSyntax : public StatementSyntax {
    Token disable;
    NameSyntax& name;
    Token semi;

    DisableStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token disable, NameSyntax& name, Token semi) :
        StatementSyntax(SyntaxKind::DisableStatement, label, attributes), disable(disable), name(name), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return disable;
            case 3: return &name;
            case 4: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: disable = token; break;
            case 3: ASSERT(false); break;
            case 4: semi = token; break;
        }
    }
};

struct DisableForkStatementSyntax : public StatementSyntax {
    Token disable;
    Token fork;
    Token semi;

    DisableForkStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token disable, Token fork, Token semi) :
        StatementSyntax(SyntaxKind::DisableForkStatement, label, attributes), disable(disable), fork(fork), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return disable;
            case 3: return fork;
            case 4: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: disable = token; break;
            case 3: fork = token; break;
            case 4: semi = token; break;
        }
    }
};

struct NamedBlockClauseSyntax : public SyntaxNode {
    Token colon;
    Token name;

    NamedBlockClauseSyntax(Token colon, Token name) :
        SyntaxNode(SyntaxKind::NamedBlockClause), colon(colon), name(name)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return colon;
            case 1: return name;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: colon = token; break;
            case 1: name = token; break;
        }
    }
};

struct BlockStatementSyntax : public StatementSyntax {
    Token begin;
    NamedBlockClauseSyntax* blockName;
    SyntaxList<SyntaxNode> items;
    Token end;
    NamedBlockClauseSyntax* endBlockName;

    BlockStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token begin, NamedBlockClauseSyntax* blockName, SyntaxList<SyntaxNode> items, Token end, NamedBlockClauseSyntax* endBlockName) :
        StatementSyntax(kind, label, attributes), begin(begin), blockName(blockName), items(items), end(end), endBlockName(endBlockName)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return begin;
            case 3: return blockName;
            case 4: return &items;
            case 5: return end;
            case 6: return endBlockName;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: begin = token; break;
            case 3: ASSERT(false); break;
            case 4: ASSERT(false); break;
            case 5: end = token; break;
            case 6: ASSERT(false); break;
        }
    }
};

struct WaitStatementSyntax : public StatementSyntax {
    Token wait;
    Token openParen;
    ExpressionSyntax& expr;
    Token closeParen;
    StatementSyntax& statement;

    WaitStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token wait, Token openParen, ExpressionSyntax& expr, Token closeParen, StatementSyntax& statement) :
        StatementSyntax(SyntaxKind::WaitStatement, label, attributes), wait(wait), openParen(openParen), expr(expr), closeParen(closeParen), statement(statement)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return wait;
            case 3: return openParen;
            case 4: return &expr;
            case 5: return closeParen;
            case 6: return &statement;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: wait = token; break;
            case 3: openParen = token; break;
            case 4: ASSERT(false); break;
            case 5: closeParen = token; break;
            case 6: ASSERT(false); break;
        }
    }
};

struct WaitForkStatementSyntax : public StatementSyntax {
    Token wait;
    Token fork;
    Token semi;

    WaitForkStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token wait, Token fork, Token semi) :
        StatementSyntax(SyntaxKind::WaitForkStatement, label, attributes), wait(wait), fork(fork), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return wait;
            case 3: return fork;
            case 4: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: wait = token; break;
            case 3: fork = token; break;
            case 4: semi = token; break;
        }
    }
};

struct WaitOrderStatementSyntax : public StatementSyntax {
    Token wait_order;
    Token openParen;
    SeparatedSyntaxList<NameSyntax> names;
    Token closeParen;
    ActionBlockSyntax& action;

    WaitOrderStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token wait_order, Token openParen, SeparatedSyntaxList<NameSyntax> names, Token closeParen, ActionBlockSyntax& action) :
        StatementSyntax(SyntaxKind::WaitOrderStatement, label, attributes), wait_order(wait_order), openParen(openParen), names(names), closeParen(closeParen), action(action)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return wait_order;
            case 3: return openParen;
            case 4: return &names;
            case 5: return closeParen;
            case 6: return &action;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: wait_order = token; break;
            case 3: openParen = token; break;
            case 4: ASSERT(false); break;
            case 5: closeParen = token; break;
            case 6: ASSERT(false); break;
        }
    }
};

struct RandCaseItemSyntax : public SyntaxNode {
    ExpressionSyntax& expr;
    Token colon;
    StatementSyntax& statement;

    RandCaseItemSyntax(ExpressionSyntax& expr, Token colon, StatementSyntax& statement) :
        SyntaxNode(SyntaxKind::RandCaseItem), expr(expr), colon(colon), statement(statement)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &expr;
            case 1: return colon;
            case 2: return &statement;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: colon = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct RandCaseStatementSyntax : public StatementSyntax {
    Token randCase;
    SyntaxList<RandCaseItemSyntax> items;
    Token endCase;

    RandCaseStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token randCase, SyntaxList<RandCaseItemSyntax> items, Token endCase) :
        StatementSyntax(SyntaxKind::RandCaseStatement, label, attributes), randCase(randCase), items(items), endCase(endCase)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return randCase;
            case 3: return &items;
            case 4: return endCase;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: randCase = token; break;
            case 3: ASSERT(false); break;
            case 4: endCase = token; break;
        }
    }
};

struct EventTriggerStatementSyntax : public StatementSyntax {
    Token trigger;
    TimingControlSyntax* timing;
    NameSyntax& name;

    EventTriggerStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token trigger, TimingControlSyntax* timing, NameSyntax& name) :
        StatementSyntax(kind, label, attributes), trigger(trigger), timing(timing), name(name)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return trigger;
            case 3: return timing;
            case 4: return &name;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: trigger = token; break;
            case 3: ASSERT(false); break;
            case 4: ASSERT(false); break;
        }
    }
};

// ----- MODULES -----

struct PortListSyntax : public SyntaxNode {

    PortListSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct NonAnsiPortSyntax : public SyntaxNode {

    NonAnsiPortSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct ImplicitNonAnsiPortSyntax : public NonAnsiPortSyntax {
    ExpressionSyntax& expr;

    ImplicitNonAnsiPortSyntax(ExpressionSyntax& expr) :
        NonAnsiPortSyntax(SyntaxKind::ImplicitNonAnsiPort), expr(expr)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &expr;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
        }
        (void)token;
    }
};

struct ExplicitNonAnsiPortSyntax : public NonAnsiPortSyntax {
    Token dot;
    Token name;
    Token openParen;
    ExpressionSyntax* expr;
    Token closeParen;

    ExplicitNonAnsiPortSyntax(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) :
        NonAnsiPortSyntax(SyntaxKind::ExplicitNonAnsiPort), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return dot;
            case 1: return name;
            case 2: return openParen;
            case 3: return expr;
            case 4: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: dot = token; break;
            case 1: name = token; break;
            case 2: openParen = token; break;
            case 3: ASSERT(false); break;
            case 4: closeParen = token; break;
        }
    }
};

struct NonAnsiPortListSyntax : public PortListSyntax {
    Token openParen;
    SeparatedSyntaxList<NonAnsiPortSyntax> ports;
    Token closeParen;

    NonAnsiPortListSyntax(Token openParen, SeparatedSyntaxList<NonAnsiPortSyntax> ports, Token closeParen) :
        PortListSyntax(SyntaxKind::NonAnsiPortList), openParen(openParen), ports(ports), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &ports;
            case 2: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openParen = token; break;
            case 1: ASSERT(false); break;
            case 2: closeParen = token; break;
        }
    }
};

struct AnsiPortSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;

    AnsiPortSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes) :
        SyntaxNode(kind), attributes(attributes)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override {
        switch (index) {
            case 0: return &attributes;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override {
        switch (index) {
            case 0: ASSERT(false); break;
        }
        (void)token;
    }
};

struct InterfacePortHeaderSyntax : public PortHeaderSyntax {
    Token nameOrKeyword;
    DotMemberClauseSyntax* modport;

    InterfacePortHeaderSyntax(Token nameOrKeyword, DotMemberClauseSyntax* modport) :
        PortHeaderSyntax(SyntaxKind::InterfacePortHeader), nameOrKeyword(nameOrKeyword), modport(modport)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return nameOrKeyword;
            case 1: return modport;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: nameOrKeyword = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct VariablePortHeaderSyntax : public PortHeaderSyntax {
    Token direction;
    Token varKeyword;
    DataTypeSyntax* type;

    VariablePortHeaderSyntax(Token direction, Token varKeyword, DataTypeSyntax* type) :
        PortHeaderSyntax(SyntaxKind::VariablePortHeader), direction(direction), varKeyword(varKeyword), type(type)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return direction;
            case 1: return varKeyword;
            case 2: return type;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: direction = token; break;
            case 1: varKeyword = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct InterconnectPortHeaderSyntax : public PortHeaderSyntax {
    Token direction;
    Token interconnect;
    DataTypeSyntax* type;

    InterconnectPortHeaderSyntax(Token direction, Token interconnect, DataTypeSyntax* type) :
        PortHeaderSyntax(SyntaxKind::InterconnectPortHeader), direction(direction), interconnect(interconnect), type(type)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return direction;
            case 1: return interconnect;
            case 2: return type;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: direction = token; break;
            case 1: interconnect = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct NetPortHeaderSyntax : public PortHeaderSyntax {
    Token direction;
    Token netType;
    DataTypeSyntax& dataType;

    NetPortHeaderSyntax(Token direction, Token netType, DataTypeSyntax& dataType) :
        PortHeaderSyntax(SyntaxKind::NetPortHeader), direction(direction), netType(netType), dataType(dataType)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return direction;
            case 1: return netType;
            case 2: return &dataType;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: direction = token; break;
            case 1: netType = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct ImplicitAnsiPortSyntax : public AnsiPortSyntax {
    PortHeaderSyntax& header;
    VariableDeclaratorSyntax& declarator;

    ImplicitAnsiPortSyntax(SyntaxList<AttributeInstanceSyntax> attributes, PortHeaderSyntax& header, VariableDeclaratorSyntax& declarator) :
        AnsiPortSyntax(SyntaxKind::ImplicitAnsiPort, attributes), header(header), declarator(declarator)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &header;
            case 2: return &declarator;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
        }
        (void)token;
    }
};

struct ExplicitAnsiPortSyntax : public AnsiPortSyntax {
    Token direction;
    Token dot;
    Token name;
    Token openParen;
    ExpressionSyntax* expr;
    Token closeParen;

    ExplicitAnsiPortSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token direction, Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) :
        AnsiPortSyntax(SyntaxKind::ExplicitAnsiPort, attributes), direction(direction), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return direction;
            case 2: return dot;
            case 3: return name;
            case 4: return openParen;
            case 5: return expr;
            case 6: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: direction = token; break;
            case 2: dot = token; break;
            case 3: name = token; break;
            case 4: openParen = token; break;
            case 5: ASSERT(false); break;
            case 6: closeParen = token; break;
        }
    }
};

struct AnsiPortListSyntax : public PortListSyntax {
    Token openParen;
    SeparatedSyntaxList<MemberSyntax> ports;
    Token closeParen;

    AnsiPortListSyntax(Token openParen, SeparatedSyntaxList<MemberSyntax> ports, Token closeParen) :
        PortListSyntax(SyntaxKind::AnsiPortList), openParen(openParen), ports(ports), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &ports;
            case 2: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openParen = token; break;
            case 1: ASSERT(false); break;
            case 2: closeParen = token; break;
        }
    }
};

struct WildcardPortListSyntax : public PortListSyntax {
    Token openParen;
    Token dotStar;
    Token closeParen;

    WildcardPortListSyntax(Token openParen, Token dotStar, Token closeParen) :
        PortListSyntax(SyntaxKind::WildcardPortList), openParen(openParen), dotStar(dotStar), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openParen;
            case 1: return dotStar;
            case 2: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openParen = token; break;
            case 1: dotStar = token; break;
            case 2: closeParen = token; break;
        }
    }
};

struct ParameterPortListSyntax : public SyntaxNode {
    Token hash;
    Token openParen;
    SeparatedSyntaxList<ParameterDeclarationSyntax> declarations;
    Token closeParen;

    ParameterPortListSyntax(Token hash, Token openParen, SeparatedSyntaxList<ParameterDeclarationSyntax> declarations, Token closeParen) :
        SyntaxNode(SyntaxKind::ParameterPortList), hash(hash), openParen(openParen), declarations(declarations), closeParen(closeParen)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return hash;
            case 1: return openParen;
            case 2: return &declarations;
            case 3: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: hash = token; break;
            case 1: openParen = token; break;
            case 2: ASSERT(false); break;
            case 3: closeParen = token; break;
        }
    }
};

struct ModuleHeaderSyntax : public SyntaxNode {
    Token moduleKeyword;
    Token lifetime;
    Token name;
    SyntaxList<PackageImportDeclarationSyntax> imports;
    ParameterPortListSyntax* parameters;
    PortListSyntax* ports;
    Token semi;

    ModuleHeaderSyntax(SyntaxKind kind, Token moduleKeyword, Token lifetime, Token name, SyntaxList<PackageImportDeclarationSyntax> imports, ParameterPortListSyntax* parameters, PortListSyntax* ports, Token semi) :
        SyntaxNode(kind), moduleKeyword(moduleKeyword), lifetime(lifetime), name(name), imports(imports), parameters(parameters), ports(ports), semi(semi)
    {
        childCount += 7;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return moduleKeyword;
            case 1: return lifetime;
            case 2: return name;
            case 3: return &imports;
            case 4: return parameters;
            case 5: return ports;
            case 6: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: moduleKeyword = token; break;
            case 1: lifetime = token; break;
            case 2: name = token; break;
            case 3: ASSERT(false); break;
            case 4: ASSERT(false); break;
            case 5: ASSERT(false); break;
            case 6: semi = token; break;
        }
    }
};

struct ModuleDeclarationSyntax : public MemberSyntax {
    ModuleHeaderSyntax& header;
    SyntaxList<MemberSyntax> members;
    Token endmodule;
    NamedBlockClauseSyntax* blockName;

    ModuleDeclarationSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes, ModuleHeaderSyntax& header, SyntaxList<MemberSyntax> members, Token endmodule, NamedBlockClauseSyntax* blockName) :
        MemberSyntax(kind, attributes), header(header), members(members), endmodule(endmodule), blockName(blockName)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &header;
            case 2: return &members;
            case 3: return endmodule;
            case 4: return blockName;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
            case 3: endmodule = token; break;
            case 4: ASSERT(false); break;
        }
    }
};

struct ExternModuleSyntax : public SyntaxNode {
    Token externKeyword;
    ModuleHeaderSyntax& header;

    ExternModuleSyntax(Token externKeyword, ModuleHeaderSyntax& header) :
        SyntaxNode(SyntaxKind::ExternModule), externKeyword(externKeyword), header(header)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return externKeyword;
            case 1: return &header;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: externKeyword = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

// ----- MEMBERS -----

struct EmptyMemberSyntax : public MemberSyntax {
    TokenList qualifiers;
    Token semi;

    EmptyMemberSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, Token semi) :
        MemberSyntax(SyntaxKind::EmptyMember, attributes), qualifiers(qualifiers), semi(semi)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &qualifiers;
            case 2: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: semi = token; break;
        }
    }
};

struct ProceduralBlockSyntax : public MemberSyntax {
    Token keyword;
    StatementSyntax& statement;

    ProceduralBlockSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, StatementSyntax& statement) :
        MemberSyntax(kind, attributes), keyword(keyword), statement(statement)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return &statement;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: keyword = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct GenerateRegionSyntax : public MemberSyntax {
    Token keyword;
    SyntaxList<MemberSyntax> members;
    Token endgenerate;

    GenerateRegionSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, SyntaxList<MemberSyntax> members, Token endgenerate) :
        MemberSyntax(SyntaxKind::GenerateRegion, attributes), keyword(keyword), members(members), endgenerate(endgenerate)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return &members;
            case 3: return endgenerate;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: keyword = token; break;
            case 2: ASSERT(false); break;
            case 3: endgenerate = token; break;
        }
    }
};

struct LoopGenerateSyntax : public MemberSyntax {
    Token keyword;
    Token openParen;
    Token genvar;
    Token identifier;
    Token equals;
    ExpressionSyntax& initialExpr;
    Token semi1;
    ExpressionSyntax& stopExpr;
    Token semi2;
    ExpressionSyntax& iterationExpr;
    Token closeParen;
    MemberSyntax& block;

    LoopGenerateSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token openParen, Token genvar, Token identifier, Token equals, ExpressionSyntax& initialExpr, Token semi1, ExpressionSyntax& stopExpr, Token semi2, ExpressionSyntax& iterationExpr, Token closeParen, MemberSyntax& block) :
        MemberSyntax(SyntaxKind::LoopGenerate, attributes), keyword(keyword), openParen(openParen), genvar(genvar), identifier(identifier), equals(equals), initialExpr(initialExpr), semi1(semi1), stopExpr(stopExpr), semi2(semi2), iterationExpr(iterationExpr), closeParen(closeParen), block(block)
    {
        childCount += 12;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return openParen;
            case 3: return genvar;
            case 4: return identifier;
            case 5: return equals;
            case 6: return &initialExpr;
            case 7: return semi1;
            case 8: return &stopExpr;
            case 9: return semi2;
            case 10: return &iterationExpr;
            case 11: return closeParen;
            case 12: return &block;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: keyword = token; break;
            case 2: openParen = token; break;
            case 3: genvar = token; break;
            case 4: identifier = token; break;
            case 5: equals = token; break;
            case 6: ASSERT(false); break;
            case 7: semi1 = token; break;
            case 8: ASSERT(false); break;
            case 9: semi2 = token; break;
            case 10: ASSERT(false); break;
            case 11: closeParen = token; break;
            case 12: ASSERT(false); break;
        }
    }
};

struct IfGenerateSyntax : public MemberSyntax {
    Token keyword;
    Token openParen;
    ExpressionSyntax& condition;
    Token closeParen;
    MemberSyntax& block;
    ElseClauseSyntax* elseClause;

    IfGenerateSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, MemberSyntax& block, ElseClauseSyntax* elseClause) :
        MemberSyntax(SyntaxKind::IfGenerate, attributes), keyword(keyword), openParen(openParen), condition(condition), closeParen(closeParen), block(block), elseClause(elseClause)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return openParen;
            case 3: return &condition;
            case 4: return closeParen;
            case 5: return &block;
            case 6: return elseClause;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: keyword = token; break;
            case 2: openParen = token; break;
            case 3: ASSERT(false); break;
            case 4: closeParen = token; break;
            case 5: ASSERT(false); break;
            case 6: ASSERT(false); break;
        }
    }
};

struct CaseGenerateSyntax : public MemberSyntax {
    Token keyword;
    Token openParen;
    ExpressionSyntax& condition;
    Token closeParen;
    SyntaxList<CaseItemSyntax> items;
    Token endCase;

    CaseGenerateSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, SyntaxList<CaseItemSyntax> items, Token endCase) :
        MemberSyntax(SyntaxKind::CaseGenerate, attributes), keyword(keyword), openParen(openParen), condition(condition), closeParen(closeParen), items(items), endCase(endCase)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return openParen;
            case 3: return &condition;
            case 4: return closeParen;
            case 5: return &items;
            case 6: return endCase;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: keyword = token; break;
            case 2: openParen = token; break;
            case 3: ASSERT(false); break;
            case 4: closeParen = token; break;
            case 5: ASSERT(false); break;
            case 6: endCase = token; break;
        }
    }
};

struct GenerateBlockSyntax : public MemberSyntax {
    NamedLabelSyntax* label;
    Token begin;
    NamedBlockClauseSyntax* beginName;
    SyntaxList<MemberSyntax> members;
    Token end;
    NamedBlockClauseSyntax* endName;

    GenerateBlockSyntax(SyntaxList<AttributeInstanceSyntax> attributes, NamedLabelSyntax* label, Token begin, NamedBlockClauseSyntax* beginName, SyntaxList<MemberSyntax> members, Token end, NamedBlockClauseSyntax* endName) :
        MemberSyntax(SyntaxKind::GenerateBlock, attributes), label(label), begin(begin), beginName(beginName), members(members), end(end), endName(endName)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return label;
            case 2: return begin;
            case 3: return beginName;
            case 4: return &members;
            case 5: return end;
            case 6: return endName;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: begin = token; break;
            case 3: ASSERT(false); break;
            case 4: ASSERT(false); break;
            case 5: end = token; break;
            case 6: ASSERT(false); break;
        }
    }
};

struct DividerClauseSyntax : public SyntaxNode {
    Token divide;
    Token value;

    DividerClauseSyntax(Token divide, Token value) :
        SyntaxNode(SyntaxKind::DividerClause), divide(divide), value(value)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return divide;
            case 1: return value;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: divide = token; break;
            case 1: value = token; break;
        }
    }
};

struct TimeUnitsDeclarationSyntax : public MemberSyntax {
    Token keyword;
    Token time;
    DividerClauseSyntax* divider;
    Token semi;

    TimeUnitsDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token time, DividerClauseSyntax* divider, Token semi) :
        MemberSyntax(SyntaxKind::TimeUnitsDeclaration, attributes), keyword(keyword), time(time), divider(divider), semi(semi)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return time;
            case 3: return divider;
            case 4: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: keyword = token; break;
            case 2: time = token; break;
            case 3: ASSERT(false); break;
            case 4: semi = token; break;
        }
    }
};

struct PortConnectionSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;

    PortConnectionSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes) :
        SyntaxNode(kind), attributes(attributes)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override {
        switch (index) {
            case 0: return &attributes;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override {
        switch (index) {
            case 0: ASSERT(false); break;
        }
        (void)token;
    }
};

struct OrderedPortConnectionSyntax : public PortConnectionSyntax {
    ExpressionSyntax& expr;

    OrderedPortConnectionSyntax(SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& expr) :
        PortConnectionSyntax(SyntaxKind::OrderedPortConnection, attributes), expr(expr)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &expr;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
        }
        (void)token;
    }
};

struct NamedPortConnectionSyntax : public PortConnectionSyntax {
    Token dot;
    Token name;
    Token openParen;
    ExpressionSyntax* expr;
    Token closeParen;

    NamedPortConnectionSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) :
        PortConnectionSyntax(SyntaxKind::NamedPortConnection, attributes), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return dot;
            case 2: return name;
            case 3: return openParen;
            case 4: return expr;
            case 5: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: dot = token; break;
            case 2: name = token; break;
            case 3: openParen = token; break;
            case 4: ASSERT(false); break;
            case 5: closeParen = token; break;
        }
    }
};

struct WildcardPortConnectionSyntax : public PortConnectionSyntax {
    Token dotStar;

    WildcardPortConnectionSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token dotStar) :
        PortConnectionSyntax(SyntaxKind::WildcardPortConnection, attributes), dotStar(dotStar)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return dotStar;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: dotStar = token; break;
        }
    }
};

struct HierarchicalInstanceSyntax : public SyntaxNode {
    Token name;
    SyntaxList<VariableDimensionSyntax> dimensions;
    Token openParen;
    SeparatedSyntaxList<PortConnectionSyntax> connections;
    Token closeParen;

    HierarchicalInstanceSyntax(Token name, SyntaxList<VariableDimensionSyntax> dimensions, Token openParen, SeparatedSyntaxList<PortConnectionSyntax> connections, Token closeParen) :
        SyntaxNode(SyntaxKind::HierarchicalInstance), name(name), dimensions(dimensions), openParen(openParen), connections(connections), closeParen(closeParen)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return name;
            case 1: return &dimensions;
            case 2: return openParen;
            case 3: return &connections;
            case 4: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: name = token; break;
            case 1: ASSERT(false); break;
            case 2: openParen = token; break;
            case 3: ASSERT(false); break;
            case 4: closeParen = token; break;
        }
    }
};

struct HierarchyInstantiationSyntax : public MemberSyntax {
    Token type;
    ParameterValueAssignmentSyntax* parameters;
    SeparatedSyntaxList<HierarchicalInstanceSyntax> instances;
    Token semi;

    HierarchyInstantiationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token type, ParameterValueAssignmentSyntax* parameters, SeparatedSyntaxList<HierarchicalInstanceSyntax> instances, Token semi) :
        MemberSyntax(SyntaxKind::HierarchyInstantiation, attributes), type(type), parameters(parameters), instances(instances), semi(semi)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return type;
            case 2: return parameters;
            case 3: return &instances;
            case 4: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: type = token; break;
            case 2: ASSERT(false); break;
            case 3: ASSERT(false); break;
            case 4: semi = token; break;
        }
    }
};

struct FunctionPortSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;
    Token constKeyword;
    Token direction;
    Token varKeyword;
    DataTypeSyntax* dataType;
    VariableDeclaratorSyntax& declarator;

    FunctionPortSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token constKeyword, Token direction, Token varKeyword, DataTypeSyntax* dataType, VariableDeclaratorSyntax& declarator) :
        SyntaxNode(SyntaxKind::FunctionPort), attributes(attributes), constKeyword(constKeyword), direction(direction), varKeyword(varKeyword), dataType(dataType), declarator(declarator)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return constKeyword;
            case 2: return direction;
            case 3: return varKeyword;
            case 4: return dataType;
            case 5: return &declarator;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: constKeyword = token; break;
            case 2: direction = token; break;
            case 3: varKeyword = token; break;
            case 4: ASSERT(false); break;
            case 5: ASSERT(false); break;
        }
    }
};

struct FunctionPortListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<FunctionPortSyntax> ports;
    Token closeParen;

    FunctionPortListSyntax(Token openParen, SeparatedSyntaxList<FunctionPortSyntax> ports, Token closeParen) :
        SyntaxNode(SyntaxKind::FunctionPortList), openParen(openParen), ports(ports), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &ports;
            case 2: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openParen = token; break;
            case 1: ASSERT(false); break;
            case 2: closeParen = token; break;
        }
    }
};

struct FunctionPrototypeSyntax : public SyntaxNode {
    Token keyword;
    Token lifetime;
    DataTypeSyntax* returnType;
    NameSyntax& name;
    FunctionPortListSyntax* portList;
    Token semi;

    FunctionPrototypeSyntax(Token keyword, Token lifetime, DataTypeSyntax* returnType, NameSyntax& name, FunctionPortListSyntax* portList, Token semi) :
        SyntaxNode(SyntaxKind::FunctionPrototype), keyword(keyword), lifetime(lifetime), returnType(returnType), name(name), portList(portList), semi(semi)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return keyword;
            case 1: return lifetime;
            case 2: return returnType;
            case 3: return &name;
            case 4: return portList;
            case 5: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: keyword = token; break;
            case 1: lifetime = token; break;
            case 2: ASSERT(false); break;
            case 3: ASSERT(false); break;
            case 4: ASSERT(false); break;
            case 5: semi = token; break;
        }
    }
};

struct FunctionDeclarationSyntax : public MemberSyntax {
    FunctionPrototypeSyntax& prototype;
    SyntaxList<SyntaxNode> items;
    Token end;
    NamedBlockClauseSyntax* endBlockName;

    FunctionDeclarationSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes, FunctionPrototypeSyntax& prototype, SyntaxList<SyntaxNode> items, Token end, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(kind, attributes), prototype(prototype), items(items), end(end), endBlockName(endBlockName)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &prototype;
            case 2: return &items;
            case 3: return end;
            case 4: return endBlockName;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
            case 3: end = token; break;
            case 4: ASSERT(false); break;
        }
    }
};

struct AssertionItemPortSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;
    Token local;
    Token direction;
    DataTypeSyntax& type;
    VariableDeclaratorSyntax& declarator;

    AssertionItemPortSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token local, Token direction, DataTypeSyntax& type, VariableDeclaratorSyntax& declarator) :
        SyntaxNode(SyntaxKind::AssertionItemPort), attributes(attributes), local(local), direction(direction), type(type), declarator(declarator)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return local;
            case 2: return direction;
            case 3: return &type;
            case 4: return &declarator;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: local = token; break;
            case 2: direction = token; break;
            case 3: ASSERT(false); break;
            case 4: ASSERT(false); break;
        }
    }
};

struct AssertionItemPortListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<AssertionItemPortSyntax> ports;
    Token closeParen;

    AssertionItemPortListSyntax(Token openParen, SeparatedSyntaxList<AssertionItemPortSyntax> ports, Token closeParen) :
        SyntaxNode(SyntaxKind::AssertionItemPortList), openParen(openParen), ports(ports), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &ports;
            case 2: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openParen = token; break;
            case 1: ASSERT(false); break;
            case 2: closeParen = token; break;
        }
    }
};

struct LetDeclarationSyntax : public MemberSyntax {
    Token let;
    Token identifier;
    AssertionItemPortListSyntax* portList;
    EqualsValueClauseSyntax& initializer;
    Token semi;

    LetDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token let, Token identifier, AssertionItemPortListSyntax* portList, EqualsValueClauseSyntax& initializer, Token semi) :
        MemberSyntax(SyntaxKind::LetDeclaration, attributes), let(let), identifier(identifier), portList(portList), initializer(initializer), semi(semi)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return let;
            case 2: return identifier;
            case 3: return portList;
            case 4: return &initializer;
            case 5: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: let = token; break;
            case 2: identifier = token; break;
            case 3: ASSERT(false); break;
            case 4: ASSERT(false); break;
            case 5: semi = token; break;
        }
    }
};

struct PropertySequenceDeclarationSyntax : public MemberSyntax {
    Token start;
    Token name;
    AssertionItemPortListSyntax* portList;
    Token semi;
    SyntaxList<DataDeclarationSyntax> assertionVariables;
    PropertySpecSyntax* propertySpec;
    ExpressionSyntax* seqExpr;
    Token optionalSemi;
    Token end;
    NamedBlockClauseSyntax* endBlockName;

    PropertySequenceDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token start, Token name, AssertionItemPortListSyntax* portList, Token semi, SyntaxList<DataDeclarationSyntax> assertionVariables, PropertySpecSyntax* propertySpec, ExpressionSyntax* seqExpr, Token optionalSemi, Token end, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(SyntaxKind::PropertySequenceDeclaration, attributes), start(start), name(name), portList(portList), semi(semi), assertionVariables(assertionVariables), propertySpec(propertySpec), seqExpr(seqExpr), optionalSemi(optionalSemi), end(end), endBlockName(endBlockName)
    {
        childCount += 10;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return start;
            case 2: return name;
            case 3: return portList;
            case 4: return semi;
            case 5: return &assertionVariables;
            case 6: return propertySpec;
            case 7: return seqExpr;
            case 8: return optionalSemi;
            case 9: return end;
            case 10: return endBlockName;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: start = token; break;
            case 2: name = token; break;
            case 3: ASSERT(false); break;
            case 4: semi = token; break;
            case 5: ASSERT(false); break;
            case 6: ASSERT(false); break;
            case 7: ASSERT(false); break;
            case 8: optionalSemi = token; break;
            case 9: end = token; break;
            case 10: ASSERT(false); break;
        }
    }
};

struct ExtendsClauseSyntax : public SyntaxNode {
    Token keyword;
    NameSyntax& baseName;
    ArgumentListSyntax* arguments;

    ExtendsClauseSyntax(Token keyword, NameSyntax& baseName, ArgumentListSyntax* arguments) :
        SyntaxNode(SyntaxKind::ExtendsClause), keyword(keyword), baseName(baseName), arguments(arguments)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return keyword;
            case 1: return &baseName;
            case 2: return arguments;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: keyword = token; break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
        }
    }
};

struct ImplementsClauseSyntax : public SyntaxNode {
    Token keyword;
    SeparatedSyntaxList<NameSyntax> interfaces;

    ImplementsClauseSyntax(Token keyword, SeparatedSyntaxList<NameSyntax> interfaces) :
        SyntaxNode(SyntaxKind::ImplementsClause), keyword(keyword), interfaces(interfaces)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return keyword;
            case 1: return &interfaces;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: keyword = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct ClassDeclarationSyntax : public MemberSyntax {
    Token virtualOrInterface;
    Token classKeyword;
    Token lifetime;
    Token name;
    ParameterPortListSyntax* parameters;
    ExtendsClauseSyntax* extendsClause;
    ImplementsClauseSyntax* implementsClause;
    Token semi;
    SyntaxList<MemberSyntax> items;
    Token endClass;
    NamedBlockClauseSyntax* endBlockName;

    ClassDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token virtualOrInterface, Token classKeyword, Token lifetime, Token name, ParameterPortListSyntax* parameters, ExtendsClauseSyntax* extendsClause, ImplementsClauseSyntax* implementsClause, Token semi, SyntaxList<MemberSyntax> items, Token endClass, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(SyntaxKind::ClassDeclaration, attributes), virtualOrInterface(virtualOrInterface), classKeyword(classKeyword), lifetime(lifetime), name(name), parameters(parameters), extendsClause(extendsClause), implementsClause(implementsClause), semi(semi), items(items), endClass(endClass), endBlockName(endBlockName)
    {
        childCount += 11;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return virtualOrInterface;
            case 2: return classKeyword;
            case 3: return lifetime;
            case 4: return name;
            case 5: return parameters;
            case 6: return extendsClause;
            case 7: return implementsClause;
            case 8: return semi;
            case 9: return &items;
            case 10: return endClass;
            case 11: return endBlockName;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: virtualOrInterface = token; break;
            case 2: classKeyword = token; break;
            case 3: lifetime = token; break;
            case 4: name = token; break;
            case 5: ASSERT(false); break;
            case 6: ASSERT(false); break;
            case 7: ASSERT(false); break;
            case 8: semi = token; break;
            case 9: ASSERT(false); break;
            case 10: endClass = token; break;
            case 11: ASSERT(false); break;
        }
    }
};

struct ClassPropertyDeclarationSyntax : public MemberSyntax {
    TokenList qualifiers;
    MemberSyntax& declaration;

    ClassPropertyDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, MemberSyntax& declaration) :
        MemberSyntax(SyntaxKind::ClassPropertyDeclaration, attributes), qualifiers(qualifiers), declaration(declaration)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &qualifiers;
            case 2: return &declaration;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
        }
        (void)token;
    }
};

struct ClassMethodDeclarationSyntax : public MemberSyntax {
    TokenList qualifiers;
    FunctionDeclarationSyntax& declaration;

    ClassMethodDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, FunctionDeclarationSyntax& declaration) :
        MemberSyntax(SyntaxKind::ClassMethodDeclaration, attributes), qualifiers(qualifiers), declaration(declaration)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &qualifiers;
            case 2: return &declaration;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
        }
        (void)token;
    }
};

struct ClassMethodPrototypeSyntax : public MemberSyntax {
    TokenList qualifiers;
    FunctionPrototypeSyntax& prototype;

    ClassMethodPrototypeSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, FunctionPrototypeSyntax& prototype) :
        MemberSyntax(SyntaxKind::ClassMethodPrototype, attributes), qualifiers(qualifiers), prototype(prototype)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &qualifiers;
            case 2: return &prototype;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
        }
        (void)token;
    }
};

struct ContinuousAssignSyntax : public MemberSyntax {
    Token assign;
    SeparatedSyntaxList<ExpressionSyntax> assignments;
    Token semi;

    ContinuousAssignSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token assign, SeparatedSyntaxList<ExpressionSyntax> assignments, Token semi) :
        MemberSyntax(SyntaxKind::ContinuousAssign, attributes), assign(assign), assignments(assignments), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return assign;
            case 2: return &assignments;
            case 3: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: assign = token; break;
            case 2: ASSERT(false); break;
            case 3: semi = token; break;
        }
    }
};

struct DefParamAssignmentSyntax : public SyntaxNode {
    NameSyntax& name;
    EqualsValueClauseSyntax* setter;

    DefParamAssignmentSyntax(NameSyntax& name, EqualsValueClauseSyntax* setter) :
        SyntaxNode(SyntaxKind::DefParamAssignment), name(name), setter(setter)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &name;
            case 1: return setter;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
        }
        (void)token;
    }
};

struct DefParamSyntax : public MemberSyntax {
    Token defparam;
    SeparatedSyntaxList<DefParamAssignmentSyntax> assignments;
    Token semi;

    DefParamSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token defparam, SeparatedSyntaxList<DefParamAssignmentSyntax> assignments, Token semi) :
        MemberSyntax(SyntaxKind::DefParam, attributes), defparam(defparam), assignments(assignments), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return defparam;
            case 2: return &assignments;
            case 3: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: defparam = token; break;
            case 2: ASSERT(false); break;
            case 3: semi = token; break;
        }
    }
};

struct ModportItemSyntax : public SyntaxNode {
    Token name;
    AnsiPortListSyntax& ports;

    ModportItemSyntax(Token name, AnsiPortListSyntax& ports) :
        SyntaxNode(SyntaxKind::ModportItem), name(name), ports(ports)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return name;
            case 1: return &ports;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: name = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct ModportDeclarationSyntax : public MemberSyntax {
    Token keyword;
    SeparatedSyntaxList<ModportItemSyntax> items;
    Token semi;

    ModportDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, SeparatedSyntaxList<ModportItemSyntax> items, Token semi) :
        MemberSyntax(SyntaxKind::ModportDeclaration, attributes), keyword(keyword), items(items), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return &items;
            case 3: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: keyword = token; break;
            case 2: ASSERT(false); break;
            case 3: semi = token; break;
        }
    }
};

struct ClockingSkewSyntax : public SyntaxNode {
    Token edge;
    Token hash;
    ExpressionSyntax* value;

    ClockingSkewSyntax(Token edge, Token hash, ExpressionSyntax* value) :
        SyntaxNode(SyntaxKind::ClockingSkew), edge(edge), hash(hash), value(value)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return edge;
            case 1: return hash;
            case 2: return value;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: edge = token; break;
            case 1: hash = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct ClockingDirectionSyntax : public SyntaxNode {
    Token input;
    ClockingSkewSyntax* inputSkew;
    Token output;
    ClockingSkewSyntax* ouputSkew;
    Token inout;

    ClockingDirectionSyntax(Token input, ClockingSkewSyntax* inputSkew, Token output, ClockingSkewSyntax* ouputSkew, Token inout) :
        SyntaxNode(SyntaxKind::ClockingDirection), input(input), inputSkew(inputSkew), output(output), ouputSkew(ouputSkew), inout(inout)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return input;
            case 1: return inputSkew;
            case 2: return output;
            case 3: return ouputSkew;
            case 4: return inout;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: input = token; break;
            case 1: ASSERT(false); break;
            case 2: output = token; break;
            case 3: ASSERT(false); break;
            case 4: inout = token; break;
        }
    }
};

struct ClockingItemSyntax : public SyntaxNode {
    Token defaultKeyword;
    ClockingDirectionSyntax* direction;
    SeparatedSyntaxList<AttributeSpecSyntax> assignments;
    Token semi;
    MemberSyntax* declaration;

    ClockingItemSyntax(Token defaultKeyword, ClockingDirectionSyntax* direction, SeparatedSyntaxList<AttributeSpecSyntax> assignments, Token semi, MemberSyntax* declaration) :
        SyntaxNode(SyntaxKind::ClockingItem), defaultKeyword(defaultKeyword), direction(direction), assignments(assignments), semi(semi), declaration(declaration)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return defaultKeyword;
            case 1: return direction;
            case 2: return &assignments;
            case 3: return semi;
            case 4: return declaration;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: defaultKeyword = token; break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
            case 3: semi = token; break;
            case 4: ASSERT(false); break;
        }
    }
};

struct ClockingDeclarationSyntax : public MemberSyntax {
    Token globalOrDefault;
    Token clocking;
    Token blockName;
    Token at;
    ParenthesizedEventExpressionSyntax* event;
    Token eventIdentifier;
    Token semi;
    SyntaxList<ClockingItemSyntax> items;
    Token endClocking;
    NamedBlockClauseSyntax* endBlockName;

    ClockingDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token globalOrDefault, Token clocking, Token blockName, Token at, ParenthesizedEventExpressionSyntax* event, Token eventIdentifier, Token semi, SyntaxList<ClockingItemSyntax> items, Token endClocking, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(SyntaxKind::ClockingDeclaration, attributes), globalOrDefault(globalOrDefault), clocking(clocking), blockName(blockName), at(at), event(event), eventIdentifier(eventIdentifier), semi(semi), items(items), endClocking(endClocking), endBlockName(endBlockName)
    {
        childCount += 10;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return globalOrDefault;
            case 2: return clocking;
            case 3: return blockName;
            case 4: return at;
            case 5: return event;
            case 6: return eventIdentifier;
            case 7: return semi;
            case 8: return &items;
            case 9: return endClocking;
            case 10: return endBlockName;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: globalOrDefault = token; break;
            case 2: clocking = token; break;
            case 3: blockName = token; break;
            case 4: at = token; break;
            case 5: ASSERT(false); break;
            case 6: eventIdentifier = token; break;
            case 7: semi = token; break;
            case 8: ASSERT(false); break;
            case 9: endClocking = token; break;
            case 10: ASSERT(false); break;
        }
    }
};

struct DPIImportExportSyntax : public MemberSyntax {
    Token keyword;
    Token stringLiteral;
    Token property;
    Token name;
    Token equals;
    FunctionPrototypeSyntax& method;

    DPIImportExportSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token stringLiteral, Token property, Token name, Token equals, FunctionPrototypeSyntax& method) :
        MemberSyntax(SyntaxKind::DPIImportExport, attributes), keyword(keyword), stringLiteral(stringLiteral), property(property), name(name), equals(equals), method(method)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return stringLiteral;
            case 3: return property;
            case 4: return name;
            case 5: return equals;
            case 6: return &method;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: keyword = token; break;
            case 2: stringLiteral = token; break;
            case 3: property = token; break;
            case 4: name = token; break;
            case 5: equals = token; break;
            case 6: ASSERT(false); break;
        }
    }
};

// ----- CONSTRAINTS -----

struct ConstraintItemSyntax : public SyntaxNode {

    ConstraintItemSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct DistWeightSyntax : public SyntaxNode {
    Token op;
    ExpressionSyntax& expr;

    DistWeightSyntax(Token op, ExpressionSyntax& expr) :
        SyntaxNode(SyntaxKind::DistWeight), op(op), expr(expr)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return op;
            case 1: return &expr;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: op = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct DistItemSyntax : public SyntaxNode {
    ExpressionSyntax& range;
    DistWeightSyntax* weight;

    DistItemSyntax(ExpressionSyntax& range, DistWeightSyntax* weight) :
        SyntaxNode(SyntaxKind::DistItem), range(range), weight(weight)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &range;
            case 1: return weight;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
        }
        (void)token;
    }
};

struct DistConstraintListSyntax : public SyntaxNode {
    Token dist;
    Token openBrace;
    SeparatedSyntaxList<DistItemSyntax> items;
    Token closeBrace;

    DistConstraintListSyntax(Token dist, Token openBrace, SeparatedSyntaxList<DistItemSyntax> items, Token closeBrace) :
        SyntaxNode(SyntaxKind::DistConstraintList), dist(dist), openBrace(openBrace), items(items), closeBrace(closeBrace)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return dist;
            case 1: return openBrace;
            case 2: return &items;
            case 3: return closeBrace;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: dist = token; break;
            case 1: openBrace = token; break;
            case 2: ASSERT(false); break;
            case 3: closeBrace = token; break;
        }
    }
};

struct ExpressionOrDistSyntax : public ExpressionSyntax {
    ExpressionSyntax& expr;
    DistConstraintListSyntax& distribution;

    ExpressionOrDistSyntax(ExpressionSyntax& expr, DistConstraintListSyntax& distribution) :
        ExpressionSyntax(SyntaxKind::ExpressionOrDist), expr(expr), distribution(distribution)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &expr;
            case 1: return &distribution;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
        }
        (void)token;
    }
};

struct ExpressionConstraintSyntax : public ConstraintItemSyntax {
    Token soft;
    ExpressionSyntax& expr;
    Token semi;

    ExpressionConstraintSyntax(Token soft, ExpressionSyntax& expr, Token semi) :
        ConstraintItemSyntax(SyntaxKind::ExpressionConstraint), soft(soft), expr(expr), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return soft;
            case 1: return &expr;
            case 2: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: soft = token; break;
            case 1: ASSERT(false); break;
            case 2: semi = token; break;
        }
    }
};

struct UniquenessConstraintSyntax : public ConstraintItemSyntax {
    Token unique;
    OpenRangeListSyntax& ranges;
    Token semi;

    UniquenessConstraintSyntax(Token unique, OpenRangeListSyntax& ranges, Token semi) :
        ConstraintItemSyntax(SyntaxKind::UniquenessConstraint), unique(unique), ranges(ranges), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return unique;
            case 1: return &ranges;
            case 2: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: unique = token; break;
            case 1: ASSERT(false); break;
            case 2: semi = token; break;
        }
    }
};

struct ImplicationConstraintSyntax : public ConstraintItemSyntax {
    ExpressionSyntax& left;
    Token arrow;
    ConstraintItemSyntax& constraints;

    ImplicationConstraintSyntax(ExpressionSyntax& left, Token arrow, ConstraintItemSyntax& constraints) :
        ConstraintItemSyntax(SyntaxKind::ImplicationConstraint), left(left), arrow(arrow), constraints(constraints)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &left;
            case 1: return arrow;
            case 2: return &constraints;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: arrow = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct ElseConstraintClauseSyntax : public SyntaxNode {
    Token elseKeyword;
    ConstraintItemSyntax& constraints;

    ElseConstraintClauseSyntax(Token elseKeyword, ConstraintItemSyntax& constraints) :
        SyntaxNode(SyntaxKind::ElseConstraintClause), elseKeyword(elseKeyword), constraints(constraints)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return elseKeyword;
            case 1: return &constraints;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: elseKeyword = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct ConditionalConstraintSyntax : public ConstraintItemSyntax {
    Token ifKeyword;
    Token openParen;
    ExpressionSyntax& condition;
    Token closeParen;
    ConstraintItemSyntax& constraints;
    ElseConstraintClauseSyntax* elseClause;

    ConditionalConstraintSyntax(Token ifKeyword, Token openParen, ExpressionSyntax& condition, Token closeParen, ConstraintItemSyntax& constraints, ElseConstraintClauseSyntax* elseClause) :
        ConstraintItemSyntax(SyntaxKind::ConditionalConstraint), ifKeyword(ifKeyword), openParen(openParen), condition(condition), closeParen(closeParen), constraints(constraints), elseClause(elseClause)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return ifKeyword;
            case 1: return openParen;
            case 2: return &condition;
            case 3: return closeParen;
            case 4: return &constraints;
            case 5: return elseClause;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ifKeyword = token; break;
            case 1: openParen = token; break;
            case 2: ASSERT(false); break;
            case 3: closeParen = token; break;
            case 4: ASSERT(false); break;
            case 5: ASSERT(false); break;
        }
    }
};

struct LoopConstraintSyntax : public ConstraintItemSyntax {
    Token foreachKeyword;
    ForeachLoopListSyntax& loopList;
    ConstraintItemSyntax& constraints;

    LoopConstraintSyntax(Token foreachKeyword, ForeachLoopListSyntax& loopList, ConstraintItemSyntax& constraints) :
        ConstraintItemSyntax(SyntaxKind::LoopConstraint), foreachKeyword(foreachKeyword), loopList(loopList), constraints(constraints)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return foreachKeyword;
            case 1: return &loopList;
            case 2: return &constraints;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: foreachKeyword = token; break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
        }
    }
};

struct DisableConstraintSyntax : public ConstraintItemSyntax {
    Token disable;
    Token soft;
    NameSyntax& name;
    Token semi;

    DisableConstraintSyntax(Token disable, Token soft, NameSyntax& name, Token semi) :
        ConstraintItemSyntax(SyntaxKind::DisableConstraint), disable(disable), soft(soft), name(name), semi(semi)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return disable;
            case 1: return soft;
            case 2: return &name;
            case 3: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: disable = token; break;
            case 1: soft = token; break;
            case 2: ASSERT(false); break;
            case 3: semi = token; break;
        }
    }
};

struct SolveBeforeConstraintSyntax : public ConstraintItemSyntax {
    Token solve;
    SeparatedSyntaxList<ExpressionSyntax> beforeExpr;
    Token before;
    SeparatedSyntaxList<ExpressionSyntax> afterExpr;
    Token semi;

    SolveBeforeConstraintSyntax(Token solve, SeparatedSyntaxList<ExpressionSyntax> beforeExpr, Token before, SeparatedSyntaxList<ExpressionSyntax> afterExpr, Token semi) :
        ConstraintItemSyntax(SyntaxKind::SolveBeforeConstraint), solve(solve), beforeExpr(beforeExpr), before(before), afterExpr(afterExpr), semi(semi)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return solve;
            case 1: return &beforeExpr;
            case 2: return before;
            case 3: return &afterExpr;
            case 4: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: solve = token; break;
            case 1: ASSERT(false); break;
            case 2: before = token; break;
            case 3: ASSERT(false); break;
            case 4: semi = token; break;
        }
    }
};

struct ConstraintBlockSyntax : public ConstraintItemSyntax {
    Token openBrace;
    SyntaxList<ConstraintItemSyntax> items;
    Token closeBrace;

    ConstraintBlockSyntax(Token openBrace, SyntaxList<ConstraintItemSyntax> items, Token closeBrace) :
        ConstraintItemSyntax(SyntaxKind::ConstraintBlock), openBrace(openBrace), items(items), closeBrace(closeBrace)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return &items;
            case 2: return closeBrace;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openBrace = token; break;
            case 1: ASSERT(false); break;
            case 2: closeBrace = token; break;
        }
    }
};

struct ConstraintPrototypeSyntax : public MemberSyntax {
    TokenList qualifiers;
    Token keyword;
    Token name;
    Token semi;

    ConstraintPrototypeSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, Token keyword, Token name, Token semi) :
        MemberSyntax(SyntaxKind::ConstraintPrototype, attributes), qualifiers(qualifiers), keyword(keyword), name(name), semi(semi)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &qualifiers;
            case 2: return keyword;
            case 3: return name;
            case 4: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: keyword = token; break;
            case 3: name = token; break;
            case 4: semi = token; break;
        }
    }
};

struct ConstraintDeclarationSyntax : public MemberSyntax {
    TokenList qualifiers;
    Token keyword;
    Token name;
    ConstraintBlockSyntax& block;

    ConstraintDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, Token keyword, Token name, ConstraintBlockSyntax& block) :
        MemberSyntax(SyntaxKind::ConstraintDeclaration, attributes), qualifiers(qualifiers), keyword(keyword), name(name), block(block)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &qualifiers;
            case 2: return keyword;
            case 3: return name;
            case 4: return &block;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: keyword = token; break;
            case 3: name = token; break;
            case 4: ASSERT(false); break;
        }
    }
};

struct WithClauseSyntax : public ExpressionSyntax {
    Token with;
    Token openParen;
    ExpressionSyntax& expr;
    Token closeParen;

    WithClauseSyntax(Token with, Token openParen, ExpressionSyntax& expr, Token closeParen) :
        ExpressionSyntax(SyntaxKind::WithClause), with(with), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return with;
            case 1: return openParen;
            case 2: return &expr;
            case 3: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: with = token; break;
            case 1: openParen = token; break;
            case 2: ASSERT(false); break;
            case 3: closeParen = token; break;
        }
    }
};

struct IdentifierListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<IdentifierNameSyntax> identifiers;
    Token closeParen;

    IdentifierListSyntax(Token openParen, SeparatedSyntaxList<IdentifierNameSyntax> identifiers, Token closeParen) :
        SyntaxNode(SyntaxKind::IdentifierList), openParen(openParen), identifiers(identifiers), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &identifiers;
            case 2: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openParen = token; break;
            case 1: ASSERT(false); break;
            case 2: closeParen = token; break;
        }
    }
};

struct RandomizeMethodWithClauseSyntax : public ExpressionSyntax {
    Token with;
    IdentifierListSyntax* names;
    ConstraintBlockSyntax& constraints;

    RandomizeMethodWithClauseSyntax(Token with, IdentifierListSyntax* names, ConstraintBlockSyntax& constraints) :
        ExpressionSyntax(SyntaxKind::RandomizeMethodWithClause), with(with), names(names), constraints(constraints)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return with;
            case 1: return names;
            case 2: return &constraints;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: with = token; break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
        }
    }
};

// ----- COVER GROUPS -----

struct WithFunctionSampleSyntax : public SyntaxNode {
    Token with;
    Token function;
    Token sample;
    AnsiPortListSyntax& portList;

    WithFunctionSampleSyntax(Token with, Token function, Token sample, AnsiPortListSyntax& portList) :
        SyntaxNode(SyntaxKind::WithFunctionSample), with(with), function(function), sample(sample), portList(portList)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return with;
            case 1: return function;
            case 2: return sample;
            case 3: return &portList;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: with = token; break;
            case 1: function = token; break;
            case 2: sample = token; break;
            case 3: ASSERT(false); break;
        }
    }
};

struct BlockEventExpressionSyntax : public SyntaxNode {

    BlockEventExpressionSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct BinaryBlockEventExpressionSyntax : public BlockEventExpressionSyntax {
    BlockEventExpressionSyntax& left;
    Token orKeyword;
    BlockEventExpressionSyntax& right;

    BinaryBlockEventExpressionSyntax(BlockEventExpressionSyntax& left, Token orKeyword, BlockEventExpressionSyntax& right) :
        BlockEventExpressionSyntax(SyntaxKind::BinaryBlockEventExpression), left(left), orKeyword(orKeyword), right(right)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &left;
            case 1: return orKeyword;
            case 2: return &right;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: orKeyword = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct PrimaryBlockEventExpressionSyntax : public BlockEventExpressionSyntax {
    Token keyword;
    NameSyntax& name;

    PrimaryBlockEventExpressionSyntax(Token keyword, NameSyntax& name) :
        BlockEventExpressionSyntax(SyntaxKind::PrimaryBlockEventExpression), keyword(keyword), name(name)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return keyword;
            case 1: return &name;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: keyword = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct BlockCoverageEventSyntax : public SyntaxNode {
    Token atat;
    Token openParen;
    BlockEventExpressionSyntax& expr;
    Token closeParen;

    BlockCoverageEventSyntax(Token atat, Token openParen, BlockEventExpressionSyntax& expr, Token closeParen) :
        SyntaxNode(SyntaxKind::BlockCoverageEvent), atat(atat), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return atat;
            case 1: return openParen;
            case 2: return &expr;
            case 3: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: atat = token; break;
            case 1: openParen = token; break;
            case 2: ASSERT(false); break;
            case 3: closeParen = token; break;
        }
    }
};

struct CovergroupDeclarationSyntax : public MemberSyntax {
    Token covergroup;
    Token name;
    AnsiPortListSyntax* portList;
    SyntaxNode* event;
    Token semi;
    SyntaxList<MemberSyntax> members;
    Token endgroup;
    NamedBlockClauseSyntax* endBlockName;

    CovergroupDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token covergroup, Token name, AnsiPortListSyntax* portList, SyntaxNode* event, Token semi, SyntaxList<MemberSyntax> members, Token endgroup, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(SyntaxKind::CovergroupDeclaration, attributes), covergroup(covergroup), name(name), portList(portList), event(event), semi(semi), members(members), endgroup(endgroup), endBlockName(endBlockName)
    {
        childCount += 8;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return covergroup;
            case 2: return name;
            case 3: return portList;
            case 4: return event;
            case 5: return semi;
            case 6: return &members;
            case 7: return endgroup;
            case 8: return endBlockName;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: covergroup = token; break;
            case 2: name = token; break;
            case 3: ASSERT(false); break;
            case 4: ASSERT(false); break;
            case 5: semi = token; break;
            case 6: ASSERT(false); break;
            case 7: endgroup = token; break;
            case 8: ASSERT(false); break;
        }
    }
};

struct CoverageOptionSyntax : public MemberSyntax {
    Token option;
    Token dot;
    Token name;
    Token equals;
    ExpressionSyntax& expr;
    Token semi;

    CoverageOptionSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token option, Token dot, Token name, Token equals, ExpressionSyntax& expr, Token semi) :
        MemberSyntax(SyntaxKind::CoverageOption, attributes), option(option), dot(dot), name(name), equals(equals), expr(expr), semi(semi)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return option;
            case 2: return dot;
            case 3: return name;
            case 4: return equals;
            case 5: return &expr;
            case 6: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: option = token; break;
            case 2: dot = token; break;
            case 3: name = token; break;
            case 4: equals = token; break;
            case 5: ASSERT(false); break;
            case 6: semi = token; break;
        }
    }
};

struct CoverpointSyntax : public MemberSyntax {
    DataTypeSyntax* type;
    NamedLabelSyntax* label;
    Token coverpoint;
    ExpressionSyntax& expr;
    Token openBrace;
    SyntaxList<MemberSyntax> members;
    Token closeBrace;
    Token emptySemi;

    CoverpointSyntax(SyntaxList<AttributeInstanceSyntax> attributes, DataTypeSyntax* type, NamedLabelSyntax* label, Token coverpoint, ExpressionSyntax& expr, Token openBrace, SyntaxList<MemberSyntax> members, Token closeBrace, Token emptySemi) :
        MemberSyntax(SyntaxKind::Coverpoint, attributes), type(type), label(label), coverpoint(coverpoint), expr(expr), openBrace(openBrace), members(members), closeBrace(closeBrace), emptySemi(emptySemi)
    {
        childCount += 8;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return type;
            case 2: return label;
            case 3: return coverpoint;
            case 4: return &expr;
            case 5: return openBrace;
            case 6: return &members;
            case 7: return closeBrace;
            case 8: return emptySemi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
            case 3: coverpoint = token; break;
            case 4: ASSERT(false); break;
            case 5: openBrace = token; break;
            case 6: ASSERT(false); break;
            case 7: closeBrace = token; break;
            case 8: emptySemi = token; break;
        }
    }
};

struct CoverageBinInitializerSyntax : public SyntaxNode {

    CoverageBinInitializerSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct DefaultCoverageBinInitializerSyntax : public CoverageBinInitializerSyntax {
    Token defaultKeyword;
    Token sequenceKeyword;

    DefaultCoverageBinInitializerSyntax(Token defaultKeyword, Token sequenceKeyword) :
        CoverageBinInitializerSyntax(SyntaxKind::DefaultCoverageBinInitializer), defaultKeyword(defaultKeyword), sequenceKeyword(sequenceKeyword)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return defaultKeyword;
            case 1: return sequenceKeyword;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: defaultKeyword = token; break;
            case 1: sequenceKeyword = token; break;
        }
    }
};

struct ExpressionCoverageBinInitializerSyntax : public CoverageBinInitializerSyntax {
    ExpressionSyntax& expr;
    WithClauseSyntax* withClause;

    ExpressionCoverageBinInitializerSyntax(ExpressionSyntax& expr, WithClauseSyntax* withClause) :
        CoverageBinInitializerSyntax(SyntaxKind::ExpressionCoverageBinInitializer), expr(expr), withClause(withClause)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &expr;
            case 1: return withClause;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
        }
        (void)token;
    }
};

struct RangeCoverageBinInitializerSyntax : public CoverageBinInitializerSyntax {
    OpenRangeListSyntax& ranges;
    WithClauseSyntax* withClause;

    RangeCoverageBinInitializerSyntax(OpenRangeListSyntax& ranges, WithClauseSyntax* withClause) :
        CoverageBinInitializerSyntax(SyntaxKind::RangeCoverageBinInitializer), ranges(ranges), withClause(withClause)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &ranges;
            case 1: return withClause;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
        }
        (void)token;
    }
};

struct IffClauseSyntax : public SyntaxNode {
    Token iff;
    Token openParen;
    ExpressionSyntax& expr;
    Token closeParen;

    IffClauseSyntax(Token iff, Token openParen, ExpressionSyntax& expr, Token closeParen) :
        SyntaxNode(SyntaxKind::IffClause), iff(iff), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return iff;
            case 1: return openParen;
            case 2: return &expr;
            case 3: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: iff = token; break;
            case 1: openParen = token; break;
            case 2: ASSERT(false); break;
            case 3: closeParen = token; break;
        }
    }
};

struct CoverageBinsSyntax : public MemberSyntax {
    Token wildcard;
    Token keyword;
    Token name;
    ElementSelectSyntax* selector;
    Token equals;
    CoverageBinInitializerSyntax& initializer;
    IffClauseSyntax* iff;
    Token semi;

    CoverageBinsSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token wildcard, Token keyword, Token name, ElementSelectSyntax* selector, Token equals, CoverageBinInitializerSyntax& initializer, IffClauseSyntax* iff, Token semi) :
        MemberSyntax(SyntaxKind::CoverageBins, attributes), wildcard(wildcard), keyword(keyword), name(name), selector(selector), equals(equals), initializer(initializer), iff(iff), semi(semi)
    {
        childCount += 8;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return wildcard;
            case 2: return keyword;
            case 3: return name;
            case 4: return selector;
            case 5: return equals;
            case 6: return &initializer;
            case 7: return iff;
            case 8: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: wildcard = token; break;
            case 2: keyword = token; break;
            case 3: name = token; break;
            case 4: ASSERT(false); break;
            case 5: equals = token; break;
            case 6: ASSERT(false); break;
            case 7: ASSERT(false); break;
            case 8: semi = token; break;
        }
    }
};

// ----- TOP LEVEL -----

struct CompilationUnitSyntax : public SyntaxNode {
    SyntaxList<MemberSyntax> members;
    Token endOfFile;

    CompilationUnitSyntax(SyntaxList<MemberSyntax> members, Token endOfFile) :
        SyntaxNode(SyntaxKind::CompilationUnit), members(members), endOfFile(endOfFile)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &members;
            case 1: return endOfFile;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: endOfFile = token; break;
        }
    }
};

// ----- DIRECTIVES -----

struct DirectiveSyntax : public SyntaxNode {
    Token directive;

    DirectiveSyntax(SyntaxKind kind, Token directive) :
        SyntaxNode(kind), directive(directive)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override {
        switch (index) {
            case 0: return directive;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override {
        switch (index) {
            case 0: directive = token; break;
        }
    }
};

struct SimpleDirectiveSyntax : public DirectiveSyntax {
    Token endOfDirective;

    SimpleDirectiveSyntax(SyntaxKind kind, Token directive, Token endOfDirective) :
        DirectiveSyntax(kind, directive), endOfDirective(endOfDirective)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return directive;
            case 1: return endOfDirective;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: directive = token; break;
            case 1: endOfDirective = token; break;
        }
    }
};

struct IncludeDirectiveSyntax : public DirectiveSyntax {
    Token fileName;
    Token endOfDirective;

    IncludeDirectiveSyntax(Token directive, Token fileName, Token endOfDirective) :
        DirectiveSyntax(SyntaxKind::IncludeDirective, directive), fileName(fileName), endOfDirective(endOfDirective)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return directive;
            case 1: return fileName;
            case 2: return endOfDirective;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: directive = token; break;
            case 1: fileName = token; break;
            case 2: endOfDirective = token; break;
        }
    }
};

struct ConditionalBranchDirectiveSyntax : public DirectiveSyntax {
    Token name;
    Token endOfDirective;
    TokenList disabledTokens;

    ConditionalBranchDirectiveSyntax(SyntaxKind kind, Token directive, Token name, Token endOfDirective, TokenList disabledTokens) :
        DirectiveSyntax(kind, directive), name(name), endOfDirective(endOfDirective), disabledTokens(disabledTokens)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return directive;
            case 1: return name;
            case 2: return endOfDirective;
            case 3: return &disabledTokens;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: directive = token; break;
            case 1: name = token; break;
            case 2: endOfDirective = token; break;
            case 3: ASSERT(false); break;
        }
    }
};

struct UnconditionalBranchDirectiveSyntax : public DirectiveSyntax {
    Token endOfDirective;
    TokenList disabledTokens;

    UnconditionalBranchDirectiveSyntax(SyntaxKind kind, Token directive, Token endOfDirective, TokenList disabledTokens) :
        DirectiveSyntax(kind, directive), endOfDirective(endOfDirective), disabledTokens(disabledTokens)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return directive;
            case 1: return endOfDirective;
            case 2: return &disabledTokens;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: directive = token; break;
            case 1: endOfDirective = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct MacroArgumentDefaultSyntax : public SyntaxNode {
    Token equals;
    TokenList tokens;

    MacroArgumentDefaultSyntax(Token equals, TokenList tokens) :
        SyntaxNode(SyntaxKind::MacroArgumentDefault), equals(equals), tokens(tokens)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return equals;
            case 1: return &tokens;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: equals = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct MacroFormalArgumentSyntax : public SyntaxNode {
    Token name;
    MacroArgumentDefaultSyntax* defaultValue;

    MacroFormalArgumentSyntax(Token name, MacroArgumentDefaultSyntax* defaultValue) :
        SyntaxNode(SyntaxKind::MacroFormalArgument), name(name), defaultValue(defaultValue)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return name;
            case 1: return defaultValue;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: name = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct MacroFormalArgumentListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<MacroFormalArgumentSyntax> args;
    Token closeParen;

    MacroFormalArgumentListSyntax(Token openParen, SeparatedSyntaxList<MacroFormalArgumentSyntax> args, Token closeParen) :
        SyntaxNode(SyntaxKind::MacroFormalArgumentList), openParen(openParen), args(args), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &args;
            case 2: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openParen = token; break;
            case 1: ASSERT(false); break;
            case 2: closeParen = token; break;
        }
    }
};

struct DefineDirectiveSyntax : public DirectiveSyntax {
    Token name;
    MacroFormalArgumentListSyntax* formalArguments;
    TokenList body;
    Token endOfDirective;

    DefineDirectiveSyntax(Token directive, Token name, MacroFormalArgumentListSyntax* formalArguments, TokenList body, Token endOfDirective) :
        DirectiveSyntax(SyntaxKind::DefineDirective, directive), name(name), formalArguments(formalArguments), body(body), endOfDirective(endOfDirective)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return directive;
            case 1: return name;
            case 2: return formalArguments;
            case 3: return &body;
            case 4: return endOfDirective;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: directive = token; break;
            case 1: name = token; break;
            case 2: ASSERT(false); break;
            case 3: ASSERT(false); break;
            case 4: endOfDirective = token; break;
        }
    }
};

struct MacroActualArgumentSyntax : public SyntaxNode {
    TokenList tokens;

    MacroActualArgumentSyntax(TokenList tokens) :
        SyntaxNode(SyntaxKind::MacroActualArgument), tokens(tokens)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &tokens;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
        }
        (void)token;
    }
};

struct MacroActualArgumentListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<MacroActualArgumentSyntax> args;
    Token closeParen;

    MacroActualArgumentListSyntax(Token openParen, SeparatedSyntaxList<MacroActualArgumentSyntax> args, Token closeParen) :
        SyntaxNode(SyntaxKind::MacroActualArgumentList), openParen(openParen), args(args), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &args;
            case 2: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openParen = token; break;
            case 1: ASSERT(false); break;
            case 2: closeParen = token; break;
        }
    }
};

struct MacroUsageSyntax : public DirectiveSyntax {
    MacroActualArgumentListSyntax* args;

    MacroUsageSyntax(Token directive, MacroActualArgumentListSyntax* args) :
        DirectiveSyntax(SyntaxKind::MacroUsage, directive), args(args)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return directive;
            case 1: return args;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: directive = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct TimescaleDirectiveSyntax : public DirectiveSyntax {
    Token timeUnit;
    Token timeUnitUnit;
    Token slash;
    Token timePrecision;
    Token timePrecisionUnit;
    Token endOfDirective;

    TimescaleDirectiveSyntax(Token directive, Token timeUnit, Token timeUnitUnit, Token slash, Token timePrecision, Token timePrecisionUnit, Token endOfDirective) :
        DirectiveSyntax(SyntaxKind::TimescaleDirective, directive), timeUnit(timeUnit), timeUnitUnit(timeUnitUnit), slash(slash), timePrecision(timePrecision), timePrecisionUnit(timePrecisionUnit), endOfDirective(endOfDirective)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return directive;
            case 1: return timeUnit;
            case 2: return timeUnitUnit;
            case 3: return slash;
            case 4: return timePrecision;
            case 5: return timePrecisionUnit;
            case 6: return endOfDirective;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: directive = token; break;
            case 1: timeUnit = token; break;
            case 2: timeUnitUnit = token; break;
            case 3: slash = token; break;
            case 4: timePrecision = token; break;
            case 5: timePrecisionUnit = token; break;
            case 6: endOfDirective = token; break;
        }
    }
};

struct DefaultNetTypeDirectiveSyntax : public DirectiveSyntax {
    Token netType;
    Token endOfDirective;

    DefaultNetTypeDirectiveSyntax(Token directive, Token netType, Token endOfDirective) :
        DirectiveSyntax(SyntaxKind::DefaultNetTypeDirective, directive), netType(netType), endOfDirective(endOfDirective)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return directive;
            case 1: return netType;
            case 2: return endOfDirective;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: directive = token; break;
            case 1: netType = token; break;
            case 2: endOfDirective = token; break;
        }
    }
};

struct LineDirectiveSyntax : public DirectiveSyntax {
    Token lineNumber;
    Token fileName;
    Token level;
    Token endOfDirective;

    LineDirectiveSyntax(Token directive, Token lineNumber, Token fileName, Token level, Token endOfDirective) :
        DirectiveSyntax(SyntaxKind::LineDirective, directive), lineNumber(lineNumber), fileName(fileName), level(level), endOfDirective(endOfDirective)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return directive;
            case 1: return lineNumber;
            case 2: return fileName;
            case 3: return level;
            case 4: return endOfDirective;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: directive = token; break;
            case 1: lineNumber = token; break;
            case 2: fileName = token; break;
            case 3: level = token; break;
            case 4: endOfDirective = token; break;
        }
    }
};

struct UndefDirectiveSyntax : public DirectiveSyntax {
    Token name;
    Token endOfDirective;

    UndefDirectiveSyntax(Token directive, Token name, Token endOfDirective) :
        DirectiveSyntax(SyntaxKind::UndefDirective, directive), name(name), endOfDirective(endOfDirective)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return directive;
            case 1: return name;
            case 2: return endOfDirective;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: directive = token; break;
            case 1: name = token; break;
            case 2: endOfDirective = token; break;
        }
    }
};

struct BeginKeywordsDirectiveSyntax : public DirectiveSyntax {
    Token versionSpecifier;
    Token endOfDirective;

    BeginKeywordsDirectiveSyntax(Token directive, Token versionSpecifier, Token endOfDirective) :
        DirectiveSyntax(SyntaxKind::BeginKeywordsDirective, directive), versionSpecifier(versionSpecifier), endOfDirective(endOfDirective)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return directive;
            case 1: return versionSpecifier;
            case 2: return endOfDirective;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: directive = token; break;
            case 1: versionSpecifier = token; break;
            case 2: endOfDirective = token; break;
        }
    }
};

template<typename T>
void dispatchVisitor(T& v, const SyntaxNode* node) {
    if (!node) return;
    switch (node->kind) {
        case SyntaxKind::Unknown: break;
        case SyntaxKind::List: v.visitDefault(*node); break;
        case SyntaxKind::UnionType: SyntaxNode::dispatch(v, *(const StructUnionTypeSyntax*)node); break;
        case SyntaxKind::LogicalOrExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ClockingDirection: SyntaxNode::dispatch(v, *(const ClockingDirectionSyntax*)node); break;
        case SyntaxKind::LogicalShiftRightExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::NetPortHeader: SyntaxNode::dispatch(v, *(const NetPortHeaderSyntax*)node); break;
        case SyntaxKind::QueueDimensionSpecifier: SyntaxNode::dispatch(v, *(const QueueDimensionSpecifierSyntax*)node); break;
        case SyntaxKind::ConditionalStatement: SyntaxNode::dispatch(v, *(const ConditionalStatementSyntax*)node); break;
        case SyntaxKind::SUntilPropertyExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ArithmeticShiftLeftExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::UnconnectedDriveDirective: SyntaxNode::dispatch(v, *(const SimpleDirectiveSyntax*)node); break;
        case SyntaxKind::EndCellDefineDirective: SyntaxNode::dispatch(v, *(const SimpleDirectiveSyntax*)node); break;
        case SyntaxKind::UnaryBitwiseNandExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::NamedStructurePatternMember: SyntaxNode::dispatch(v, *(const NamedStructurePatternMemberSyntax*)node); break;
        case SyntaxKind::VirtualInterfaceType: SyntaxNode::dispatch(v, *(const VirtualInterfaceTypeSyntax*)node); break;
        case SyntaxKind::OrderedArgument: SyntaxNode::dispatch(v, *(const OrderedArgumentSyntax*)node); break;
        case SyntaxKind::SignalEventExpression: SyntaxNode::dispatch(v, *(const SignalEventExpressionSyntax*)node); break;
        case SyntaxKind::FunctionPortList: SyntaxNode::dispatch(v, *(const FunctionPortListSyntax*)node); break;
        case SyntaxKind::ExpressionOrDist: SyntaxNode::dispatch(v, *(const ExpressionOrDistSyntax*)node); break;
        case SyntaxKind::DescendingRangeSelect: SyntaxNode::dispatch(v, *(const RangeSelectSyntax*)node); break;
        case SyntaxKind::CoverageBins: SyntaxNode::dispatch(v, *(const CoverageBinsSyntax*)node); break;
        case SyntaxKind::UndefineAllDirective: SyntaxNode::dispatch(v, *(const SimpleDirectiveSyntax*)node); break;
        case SyntaxKind::VariablePortHeader: SyntaxNode::dispatch(v, *(const VariablePortHeaderSyntax*)node); break;
        case SyntaxKind::CHandleType: SyntaxNode::dispatch(v, *(const KeywordTypeSyntax*)node); break;
        case SyntaxKind::SolveBeforeConstraint: SyntaxNode::dispatch(v, *(const SolveBeforeConstraintSyntax*)node); break;
        case SyntaxKind::UnaryBitwiseNorExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::InitialBlock: SyntaxNode::dispatch(v, *(const ProceduralBlockSyntax*)node); break;
        case SyntaxKind::DefaultCoverageBinInitializer: SyntaxNode::dispatch(v, *(const DefaultCoverageBinInitializerSyntax*)node); break;
        case SyntaxKind::BeginKeywordsDirective: SyntaxNode::dispatch(v, *(const BeginKeywordsDirectiveSyntax*)node); break;
        case SyntaxKind::NextTimePropertyExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::PropertySpec: SyntaxNode::dispatch(v, *(const PropertySpecSyntax*)node); break;
        case SyntaxKind::ImplementsClause: SyntaxNode::dispatch(v, *(const ImplementsClauseSyntax*)node); break;
        case SyntaxKind::SimpleAssignmentPattern: SyntaxNode::dispatch(v, *(const SimpleAssignmentPatternSyntax*)node); break;
        case SyntaxKind::ScopedName: SyntaxNode::dispatch(v, *(const ScopedNameSyntax*)node); break;
        case SyntaxKind::ParenthesizedExpression: SyntaxNode::dispatch(v, *(const ParenthesizedExpressionSyntax*)node); break;
        case SyntaxKind::LogicalShiftLeftExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::IfNDefDirective: SyntaxNode::dispatch(v, *(const ConditionalBranchDirectiveSyntax*)node); break;
        case SyntaxKind::EmptyMember: SyntaxNode::dispatch(v, *(const EmptyMemberSyntax*)node); break;
        case SyntaxKind::BlockCoverageEvent: SyntaxNode::dispatch(v, *(const BlockCoverageEventSyntax*)node); break;
        case SyntaxKind::TimescaleDirective: SyntaxNode::dispatch(v, *(const TimescaleDirectiveSyntax*)node); break;
        case SyntaxKind::SyncRejectOnPropertyExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::LessThanEqualExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::TaggedPattern: SyntaxNode::dispatch(v, *(const TaggedPatternSyntax*)node); break;
        case SyntaxKind::Untyped: SyntaxNode::dispatch(v, *(const KeywordTypeSyntax*)node); break;
        case SyntaxKind::ParameterDeclarationStatement: SyntaxNode::dispatch(v, *(const ParameterDeclarationStatementSyntax*)node); break;
        case SyntaxKind::OneStepLiteralExpression: SyntaxNode::dispatch(v, *(const LiteralExpressionSyntax*)node); break;
        case SyntaxKind::MacroActualArgument: SyntaxNode::dispatch(v, *(const MacroActualArgumentSyntax*)node); break;
        case SyntaxKind::ForVariableDeclaration: SyntaxNode::dispatch(v, *(const ForVariableDeclarationSyntax*)node); break;
        case SyntaxKind::WildcardInequalityExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::MatchesClause: SyntaxNode::dispatch(v, *(const MatchesClauseSyntax*)node); break;
        case SyntaxKind::MacroFormalArgument: SyntaxNode::dispatch(v, *(const MacroFormalArgumentSyntax*)node); break;
        case SyntaxKind::LogicalRightShiftAssignmentExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::WaitForkStatement: SyntaxNode::dispatch(v, *(const WaitForkStatementSyntax*)node); break;
        case SyntaxKind::ParenImplicitEventControl: SyntaxNode::dispatch(v, *(const ParenImplicitEventControlSyntax*)node); break;
        case SyntaxKind::LoopStatement: SyntaxNode::dispatch(v, *(const LoopStatementSyntax*)node); break;
        case SyntaxKind::InvocationExpression: SyntaxNode::dispatch(v, *(const InvocationExpressionSyntax*)node); break;
        case SyntaxKind::ElseConstraintClause: SyntaxNode::dispatch(v, *(const ElseConstraintClauseSyntax*)node); break;
        case SyntaxKind::ParameterValueAssignment: SyntaxNode::dispatch(v, *(const ParameterValueAssignmentSyntax*)node); break;
        case SyntaxKind::NonOverlappedImplicationPropertyExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::RangeCoverageBinInitializer: SyntaxNode::dispatch(v, *(const RangeCoverageBinInitializerSyntax*)node); break;
        case SyntaxKind::NonOverlappedFollowedByPropertyExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::PostdecrementExpression: SyntaxNode::dispatch(v, *(const PostfixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::ElementSelect: SyntaxNode::dispatch(v, *(const ElementSelectSyntax*)node); break;
        case SyntaxKind::SequenceType: SyntaxNode::dispatch(v, *(const KeywordTypeSyntax*)node); break;
        case SyntaxKind::DPIImportExport: SyntaxNode::dispatch(v, *(const DPIImportExportSyntax*)node); break;
        case SyntaxKind::UntilWithPropertyExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::SuperHandle: SyntaxNode::dispatch(v, *(const KeywordNameSyntax*)node); break;
        case SyntaxKind::ArrayUniqueMethod: SyntaxNode::dispatch(v, *(const KeywordNameSyntax*)node); break;
        case SyntaxKind::NamedType: SyntaxNode::dispatch(v, *(const NamedTypeSyntax*)node); break;
        case SyntaxKind::LessThanExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::RangeDimensionSpecifier: SyntaxNode::dispatch(v, *(const RangeDimensionSpecifierSyntax*)node); break;
        case SyntaxKind::OpenRangeList: SyntaxNode::dispatch(v, *(const OpenRangeListSyntax*)node); break;
        case SyntaxKind::UnarySequenceDelayExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::DotMemberClause: SyntaxNode::dispatch(v, *(const DotMemberClauseSyntax*)node); break;
        case SyntaxKind::DefParamAssignment: SyntaxNode::dispatch(v, *(const DefParamAssignmentSyntax*)node); break;
        case SyntaxKind::EqualsValueClause: SyntaxNode::dispatch(v, *(const EqualsValueClauseSyntax*)node); break;
        case SyntaxKind::BinaryBlockEventExpression: SyntaxNode::dispatch(v, *(const BinaryBlockEventExpressionSyntax*)node); break;
        case SyntaxKind::UnaryBitwiseXorExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::DefineDirective: SyntaxNode::dispatch(v, *(const DefineDirectiveSyntax*)node); break;
        case SyntaxKind::NewExpression: SyntaxNode::dispatch(v, *(const NewExpressionSyntax*)node); break;
        case SyntaxKind::ModuleDeclaration: SyntaxNode::dispatch(v, *(const ModuleDeclarationSyntax*)node); break;
        case SyntaxKind::CaseInequalityExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::SEventuallyPropertyExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::InterfacePortHeader: SyntaxNode::dispatch(v, *(const InterfacePortHeaderSyntax*)node); break;
        case SyntaxKind::IdentifierSelectName: SyntaxNode::dispatch(v, *(const IdentifierSelectNameSyntax*)node); break;
        case SyntaxKind::ConcurrentAssertionMember: SyntaxNode::dispatch(v, *(const ConcurrentAssertionMemberSyntax*)node); break;
        case SyntaxKind::RandCaseItem: SyntaxNode::dispatch(v, *(const RandCaseItemSyntax*)node); break;
        case SyntaxKind::SAlwaysPropertyExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::AndAssignmentExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ConcatenationExpression: SyntaxNode::dispatch(v, *(const ConcatenationExpressionSyntax*)node); break;
        case SyntaxKind::RejectOnPropertyExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::IntegerLiteralExpression: SyntaxNode::dispatch(v, *(const LiteralExpressionSyntax*)node); break;
        case SyntaxKind::GreaterThanEqualExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::VarDataType: SyntaxNode::dispatch(v, *(const VarDataTypeSyntax*)node); break;
        case SyntaxKind::ShortIntType: SyntaxNode::dispatch(v, *(const IntegerTypeSyntax*)node); break;
        case SyntaxKind::ParameterDeclaration: SyntaxNode::dispatch(v, *(const ParameterDeclarationSyntax*)node); break;
        case SyntaxKind::ImmediateCoverStatement: SyntaxNode::dispatch(v, *(const ImmediateAssertionStatementSyntax*)node); break;
        case SyntaxKind::GenerateBlock: SyntaxNode::dispatch(v, *(const GenerateBlockSyntax*)node); break;
        case SyntaxKind::TypeType: SyntaxNode::dispatch(v, *(const KeywordTypeSyntax*)node); break;
        case SyntaxKind::ForLoopStatement: SyntaxNode::dispatch(v, *(const ForLoopStatementSyntax*)node); break;
        case SyntaxKind::WildcardLiteralExpression: SyntaxNode::dispatch(v, *(const LiteralExpressionSyntax*)node); break;
        case SyntaxKind::ProceduralDeassignStatement: SyntaxNode::dispatch(v, *(const ProceduralDeassignStatementSyntax*)node); break;
        case SyntaxKind::VariableDeclarator: SyntaxNode::dispatch(v, *(const VariableDeclaratorSyntax*)node); break;
        case SyntaxKind::NullLiteralExpression: SyntaxNode::dispatch(v, *(const LiteralExpressionSyntax*)node); break;
        case SyntaxKind::BinarySequenceDelayExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::EventControl: SyntaxNode::dispatch(v, *(const EventControlSyntax*)node); break;
        case SyntaxKind::DistConstraintList: SyntaxNode::dispatch(v, *(const DistConstraintListSyntax*)node); break;
        case SyntaxKind::ProceduralAssignStatement: SyntaxNode::dispatch(v, *(const ProceduralAssignStatementSyntax*)node); break;
        case SyntaxKind::ModuleHeader: SyntaxNode::dispatch(v, *(const ModuleHeaderSyntax*)node); break;
        case SyntaxKind::BinaryEventExpression: SyntaxNode::dispatch(v, *(const BinaryEventExpressionSyntax*)node); break;
        case SyntaxKind::LogicalImplicationExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ParenthesizedEventExpression: SyntaxNode::dispatch(v, *(const ParenthesizedEventExpressionSyntax*)node); break;
        case SyntaxKind::ArithmeticShiftRightExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::UnaryBitwiseNotExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::SNextTimePropertyExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::PackageImportDeclaration: SyntaxNode::dispatch(v, *(const PackageImportDeclarationSyntax*)node); break;
        case SyntaxKind::NoUnconnectedDriveDirective: SyntaxNode::dispatch(v, *(const SimpleDirectiveSyntax*)node); break;
        case SyntaxKind::SequentialBlockStatement: SyntaxNode::dispatch(v, *(const BlockStatementSyntax*)node); break;
        case SyntaxKind::MultiplyAssignmentExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::FunctionPrototype: SyntaxNode::dispatch(v, *(const FunctionPrototypeSyntax*)node); break;
        case SyntaxKind::DisableIff: SyntaxNode::dispatch(v, *(const DisableIffSyntax*)node); break;
        case SyntaxKind::ElseClause: SyntaxNode::dispatch(v, *(const ElseClauseSyntax*)node); break;
        case SyntaxKind::CaseEqualityExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::BinaryXnorExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::OrSequenceExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::BitSelect: SyntaxNode::dispatch(v, *(const BitSelectSyntax*)node); break;
        case SyntaxKind::DataDeclaration: SyntaxNode::dispatch(v, *(const DataDeclarationSyntax*)node); break;
        case SyntaxKind::UndefDirective: SyntaxNode::dispatch(v, *(const UndefDirectiveSyntax*)node); break;
        case SyntaxKind::ParameterPortList: SyntaxNode::dispatch(v, *(const ParameterPortListSyntax*)node); break;
        case SyntaxKind::ColonExpressionClause: SyntaxNode::dispatch(v, *(const ColonExpressionClauseSyntax*)node); break;
        case SyntaxKind::TimeUnitsDeclaration: SyntaxNode::dispatch(v, *(const TimeUnitsDeclarationSyntax*)node); break;
        case SyntaxKind::TypedefInterfaceClassDeclaration: SyntaxNode::dispatch(v, *(const TypedefInterfaceClassDeclarationSyntax*)node); break;
        case SyntaxKind::EqualityExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::CovergroupDeclaration: SyntaxNode::dispatch(v, *(const CovergroupDeclarationSyntax*)node); break;
        case SyntaxKind::AddAssignmentExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::MacroUsage: SyntaxNode::dispatch(v, *(const MacroUsageSyntax*)node); break;
        case SyntaxKind::WithinSequenceExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ExpressionConstraint: SyntaxNode::dispatch(v, *(const ExpressionConstraintSyntax*)node); break;
        case SyntaxKind::ClassMethodPrototype: SyntaxNode::dispatch(v, *(const ClassMethodPrototypeSyntax*)node); break;
        case SyntaxKind::UnaryBitwiseAndExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::EndKeywordsDirective: SyntaxNode::dispatch(v, *(const SimpleDirectiveSyntax*)node); break;
        case SyntaxKind::OrAssignmentExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::InsideExpression: SyntaxNode::dispatch(v, *(const InsideExpressionSyntax*)node); break;
        case SyntaxKind::DivideExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::AssertionItemPort: SyntaxNode::dispatch(v, *(const AssertionItemPortSyntax*)node); break;
        case SyntaxKind::RegType: SyntaxNode::dispatch(v, *(const IntegerTypeSyntax*)node); break;
        case SyntaxKind::CoverSequenceStatement: SyntaxNode::dispatch(v, *(const ConcurrentAssertionStatementSyntax*)node); break;
        case SyntaxKind::UnaryNotPropertyExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::ImpliesPropertyExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::PackageImportItem: SyntaxNode::dispatch(v, *(const PackageImportItemSyntax*)node); break;
        case SyntaxKind::UnaryPreincrementExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::ConditionalPredicate: SyntaxNode::dispatch(v, *(const ConditionalPredicateSyntax*)node); break;
        case SyntaxKind::EmptyStatement: SyntaxNode::dispatch(v, *(const EmptyStatementSyntax*)node); break;
        case SyntaxKind::ForeverStatement: SyntaxNode::dispatch(v, *(const ForeverStatementSyntax*)node); break;
        case SyntaxKind::ConditionalExpression: SyntaxNode::dispatch(v, *(const ConditionalExpressionSyntax*)node); break;
        case SyntaxKind::BinaryOrExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::DivideAssignmentExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::CellDefineDirective: SyntaxNode::dispatch(v, *(const SimpleDirectiveSyntax*)node); break;
        case SyntaxKind::RealTimeType: SyntaxNode::dispatch(v, *(const KeywordTypeSyntax*)node); break;
        case SyntaxKind::IfGenerate: SyntaxNode::dispatch(v, *(const IfGenerateSyntax*)node); break;
        case SyntaxKind::LogicalEquivalenceExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::SystemName: SyntaxNode::dispatch(v, *(const KeywordNameSyntax*)node); break;
        case SyntaxKind::ModAssignmentExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::DistItem: SyntaxNode::dispatch(v, *(const DistItemSyntax*)node); break;
        case SyntaxKind::TaskDeclaration: SyntaxNode::dispatch(v, *(const FunctionDeclarationSyntax*)node); break;
        case SyntaxKind::RealType: SyntaxNode::dispatch(v, *(const KeywordTypeSyntax*)node); break;
        case SyntaxKind::WildcardDimensionSpecifier: SyntaxNode::dispatch(v, *(const WildcardDimensionSpecifierSyntax*)node); break;
        case SyntaxKind::WildcardPattern: SyntaxNode::dispatch(v, *(const WildcardPatternSyntax*)node); break;
        case SyntaxKind::DeferredAssertion: SyntaxNode::dispatch(v, *(const DeferredAssertionSyntax*)node); break;
        case SyntaxKind::DividerClause: SyntaxNode::dispatch(v, *(const DividerClauseSyntax*)node); break;
        case SyntaxKind::PatternCaseItem: SyntaxNode::dispatch(v, *(const PatternCaseItemSyntax*)node); break;
        case SyntaxKind::WildcardPortConnection: SyntaxNode::dispatch(v, *(const WildcardPortConnectionSyntax*)node); break;
        case SyntaxKind::ImplicationConstraint: SyntaxNode::dispatch(v, *(const ImplicationConstraintSyntax*)node); break;
        case SyntaxKind::IffClause: SyntaxNode::dispatch(v, *(const IffClauseSyntax*)node); break;
        case SyntaxKind::ExtendsClause: SyntaxNode::dispatch(v, *(const ExtendsClauseSyntax*)node); break;
        case SyntaxKind::StructType: SyntaxNode::dispatch(v, *(const StructUnionTypeSyntax*)node); break;
        case SyntaxKind::ShortRealType: SyntaxNode::dispatch(v, *(const KeywordTypeSyntax*)node); break;
        case SyntaxKind::EmptyIdentifierName: SyntaxNode::dispatch(v, *(const EmptyIdentifierNameSyntax*)node); break;
        case SyntaxKind::LongIntType: SyntaxNode::dispatch(v, *(const IntegerTypeSyntax*)node); break;
        case SyntaxKind::ArrayAndMethod: SyntaxNode::dispatch(v, *(const KeywordNameSyntax*)node); break;
        case SyntaxKind::AddExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ChargeStrength: SyntaxNode::dispatch(v, *(const ChargeStrengthSyntax*)node); break;
        case SyntaxKind::LogicType: SyntaxNode::dispatch(v, *(const IntegerTypeSyntax*)node); break;
        case SyntaxKind::StreamExpressionWithRange: SyntaxNode::dispatch(v, *(const StreamExpressionWithRange*)node); break;
        case SyntaxKind::MacroArgumentDefault: SyntaxNode::dispatch(v, *(const MacroArgumentDefaultSyntax*)node); break;
        case SyntaxKind::CoverPropertyStatement: SyntaxNode::dispatch(v, *(const ConcurrentAssertionStatementSyntax*)node); break;
        case SyntaxKind::IffPropertyExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ExpressionStatement: SyntaxNode::dispatch(v, *(const ExpressionStatementSyntax*)node); break;
        case SyntaxKind::ConditionalPattern: SyntaxNode::dispatch(v, *(const ConditionalPatternSyntax*)node); break;
        case SyntaxKind::PortDeclaration: SyntaxNode::dispatch(v, *(const PortDeclarationSyntax*)node); break;
        case SyntaxKind::LogicalAndExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::EventType: SyntaxNode::dispatch(v, *(const KeywordTypeSyntax*)node); break;
        case SyntaxKind::AssignmentPatternExpression: SyntaxNode::dispatch(v, *(const AssignmentPatternExpressionSyntax*)node); break;
        case SyntaxKind::ClassDeclaration: SyntaxNode::dispatch(v, *(const ClassDeclarationSyntax*)node); break;
        case SyntaxKind::InterfaceDeclaration: SyntaxNode::dispatch(v, *(const ModuleDeclarationSyntax*)node); break;
        case SyntaxKind::OrderedPortConnection: SyntaxNode::dispatch(v, *(const OrderedPortConnectionSyntax*)node); break;
        case SyntaxKind::LocalScope: SyntaxNode::dispatch(v, *(const KeywordNameSyntax*)node); break;
        case SyntaxKind::SignedCastExpression: SyntaxNode::dispatch(v, *(const SignedCastExpressionSyntax*)node); break;
        case SyntaxKind::VariablePattern: SyntaxNode::dispatch(v, *(const VariablePatternSyntax*)node); break;
        case SyntaxKind::TypedefDeclaration: SyntaxNode::dispatch(v, *(const TypedefDeclarationSyntax*)node); break;
        case SyntaxKind::AcceptOnPropertyExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::LineDirective: SyntaxNode::dispatch(v, *(const LineDirectiveSyntax*)node); break;
        case SyntaxKind::EndIfDirective: SyntaxNode::dispatch(v, *(const UnconditionalBranchDirectiveSyntax*)node); break;
        case SyntaxKind::BinaryXorExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ImmediateAssertionMember: SyntaxNode::dispatch(v, *(const ImmediateAssertionMemberSyntax*)node); break;
        case SyntaxKind::CompilationUnit: SyntaxNode::dispatch(v, *(const CompilationUnitSyntax*)node); break;
        case SyntaxKind::IntersectSequenceExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::TimeLiteralExpression: SyntaxNode::dispatch(v, *(const LiteralExpressionSyntax*)node); break;
        case SyntaxKind::WithClause: SyntaxNode::dispatch(v, *(const WithClauseSyntax*)node); break;
        case SyntaxKind::AssumePropertyStatement: SyntaxNode::dispatch(v, *(const ConcurrentAssertionStatementSyntax*)node); break;
        case SyntaxKind::WithFunctionSample: SyntaxNode::dispatch(v, *(const WithFunctionSampleSyntax*)node); break;
        case SyntaxKind::FinalBlock: SyntaxNode::dispatch(v, *(const ProceduralBlockSyntax*)node); break;
        case SyntaxKind::EventControlWithExpression: SyntaxNode::dispatch(v, *(const EventControlWithExpressionSyntax*)node); break;
        case SyntaxKind::SUntilWithPropertyExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::DefaultPatternKeyExpression: SyntaxNode::dispatch(v, *(const LiteralExpressionSyntax*)node); break;
        case SyntaxKind::UnaryPredecrementExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::ImmediateAssertStatement: SyntaxNode::dispatch(v, *(const ImmediateAssertionStatementSyntax*)node); break;
        case SyntaxKind::ImmediateAssumeStatement: SyntaxNode::dispatch(v, *(const ImmediateAssertionStatementSyntax*)node); break;
        case SyntaxKind::RealLiteralExpression: SyntaxNode::dispatch(v, *(const LiteralExpressionSyntax*)node); break;
        case SyntaxKind::ElementSelectExpression: SyntaxNode::dispatch(v, *(const ElementSelectExpressionSyntax*)node); break;
        case SyntaxKind::ActionBlock: SyntaxNode::dispatch(v, *(const ActionBlockSyntax*)node); break;
        case SyntaxKind::ModExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ProgramDeclaration: SyntaxNode::dispatch(v, *(const ModuleDeclarationSyntax*)node); break;
        case SyntaxKind::NamedBlockClause: SyntaxNode::dispatch(v, *(const NamedBlockClauseSyntax*)node); break;
        case SyntaxKind::ParallelBlockStatement: SyntaxNode::dispatch(v, *(const BlockStatementSyntax*)node); break;
        case SyntaxKind::IncludeDirective: SyntaxNode::dispatch(v, *(const IncludeDirectiveSyntax*)node); break;
        case SyntaxKind::AttributeInstance: SyntaxNode::dispatch(v, *(const AttributeInstanceSyntax*)node); break;
        case SyntaxKind::AlwaysBlock: SyntaxNode::dispatch(v, *(const ProceduralBlockSyntax*)node); break;
        case SyntaxKind::ReplicatedAssignmentPattern: SyntaxNode::dispatch(v, *(const ReplicatedAssignmentPatternSyntax*)node); break;
        case SyntaxKind::JumpStatement: SyntaxNode::dispatch(v, *(const JumpStatementSyntax*)node); break;
        case SyntaxKind::NonblockingEventTriggerStatement: SyntaxNode::dispatch(v, *(const EventTriggerStatementSyntax*)node); break;
        case SyntaxKind::GreaterThanExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::UnaryBitwiseXnorExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::SubtractAssignmentExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::AttributeSpec: SyntaxNode::dispatch(v, *(const AttributeSpecSyntax*)node); break;
        case SyntaxKind::OrderedStructurePatternMember: SyntaxNode::dispatch(v, *(const OrderedStructurePatternMemberSyntax*)node); break;
        case SyntaxKind::ModportDeclaration: SyntaxNode::dispatch(v, *(const ModportDeclarationSyntax*)node); break;
        case SyntaxKind::RandCaseStatement: SyntaxNode::dispatch(v, *(const RandCaseStatementSyntax*)node); break;
        case SyntaxKind::WildcardEqualityExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ExplicitNonAnsiPort: SyntaxNode::dispatch(v, *(const ExplicitNonAnsiPortSyntax*)node); break;
        case SyntaxKind::StringLiteralExpression: SyntaxNode::dispatch(v, *(const LiteralExpressionSyntax*)node); break;
        case SyntaxKind::AlwaysCombBlock: SyntaxNode::dispatch(v, *(const ProceduralBlockSyntax*)node); break;
        case SyntaxKind::IdentifierList: SyntaxNode::dispatch(v, *(const IdentifierListSyntax*)node); break;
        case SyntaxKind::AlwaysLatchBlock: SyntaxNode::dispatch(v, *(const ProceduralBlockSyntax*)node); break;
        case SyntaxKind::MacroActualArgumentList: SyntaxNode::dispatch(v, *(const MacroActualArgumentListSyntax*)node); break;
        case SyntaxKind::CaseGenerate: SyntaxNode::dispatch(v, *(const CaseGenerateSyntax*)node); break;
        case SyntaxKind::AndSequenceExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ForeachLoopStatement: SyntaxNode::dispatch(v, *(const ForeachLoopStatementSyntax*)node); break;
        case SyntaxKind::RepeatedEventControl: SyntaxNode::dispatch(v, *(const RepeatedEventControlSyntax*)node); break;
        case SyntaxKind::ThisHandle: SyntaxNode::dispatch(v, *(const KeywordNameSyntax*)node); break;
        case SyntaxKind::InterconnectPortHeader: SyntaxNode::dispatch(v, *(const InterconnectPortHeaderSyntax*)node); break;
        case SyntaxKind::FunctionDeclaration: SyntaxNode::dispatch(v, *(const FunctionDeclarationSyntax*)node); break;
        case SyntaxKind::ImplicitNonAnsiPort: SyntaxNode::dispatch(v, *(const ImplicitNonAnsiPortSyntax*)node); break;
        case SyntaxKind::ConstraintPrototype: SyntaxNode::dispatch(v, *(const ConstraintPrototypeSyntax*)node); break;
        case SyntaxKind::NewArrayExpression: SyntaxNode::dispatch(v, *(const NewArrayExpressionSyntax*)node); break;
        case SyntaxKind::PackageHeader: SyntaxNode::dispatch(v, *(const ModuleHeaderSyntax*)node); break;
        case SyntaxKind::UntilPropertyExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::OverlappedFollowedByPropertyExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::CastExpression: SyntaxNode::dispatch(v, *(const CastExpressionSyntax*)node); break;
        case SyntaxKind::LetDeclaration: SyntaxNode::dispatch(v, *(const LetDeclarationSyntax*)node); break;
        case SyntaxKind::SubtractExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ConditionalConstraint: SyntaxNode::dispatch(v, *(const ConditionalConstraintSyntax*)node); break;
        case SyntaxKind::MultipleConcatenationExpression: SyntaxNode::dispatch(v, *(const MultipleConcatenationExpressionSyntax*)node); break;
        case SyntaxKind::UnaryLogicalNotExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::ImplicitType: SyntaxNode::dispatch(v, *(const ImplicitTypeSyntax*)node); break;
        case SyntaxKind::BlockingEventTriggerStatement: SyntaxNode::dispatch(v, *(const EventTriggerStatementSyntax*)node); break;
        case SyntaxKind::DisableStatement: SyntaxNode::dispatch(v, *(const DisableStatementSyntax*)node); break;
        case SyntaxKind::AscendingRangeSelect: SyntaxNode::dispatch(v, *(const RangeSelectSyntax*)node); break;
        case SyntaxKind::AlwaysPropertyExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::DoWhileStatement: SyntaxNode::dispatch(v, *(const DoWhileStatementSyntax*)node); break;
        case SyntaxKind::TypeReference: SyntaxNode::dispatch(v, *(const TypeReferenceSyntax*)node); break;
        case SyntaxKind::MacroFormalArgumentList: SyntaxNode::dispatch(v, *(const MacroFormalArgumentListSyntax*)node); break;
        case SyntaxKind::LoopGenerate: SyntaxNode::dispatch(v, *(const LoopGenerateSyntax*)node); break;
        case SyntaxKind::ProceduralReleaseStatement: SyntaxNode::dispatch(v, *(const ProceduralDeassignStatementSyntax*)node); break;
        case SyntaxKind::ResetAllDirective: SyntaxNode::dispatch(v, *(const SimpleDirectiveSyntax*)node); break;
        case SyntaxKind::NamedLabel: SyntaxNode::dispatch(v, *(const NamedLabelSyntax*)node); break;
        case SyntaxKind::ExpressionPattern: SyntaxNode::dispatch(v, *(const ExpressionPatternSyntax*)node); break;
        case SyntaxKind::DefaultNetTypeDirective: SyntaxNode::dispatch(v, *(const DefaultNetTypeDirectiveSyntax*)node); break;
        case SyntaxKind::StructuredAssignmentPattern: SyntaxNode::dispatch(v, *(const StructuredAssignmentPatternSyntax*)node); break;
        case SyntaxKind::LoopConstraint: SyntaxNode::dispatch(v, *(const LoopConstraintSyntax*)node); break;
        case SyntaxKind::DefaultCaseItem: SyntaxNode::dispatch(v, *(const DefaultCaseItemSyntax*)node); break;
        case SyntaxKind::MultiplyExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ThroughoutSequenceExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ElseDirective: SyntaxNode::dispatch(v, *(const UnconditionalBranchDirectiveSyntax*)node); break;
        case SyntaxKind::PackageDeclaration: SyntaxNode::dispatch(v, *(const ModuleDeclarationSyntax*)node); break;
        case SyntaxKind::ExpectPropertyStatement: SyntaxNode::dispatch(v, *(const ConcurrentAssertionStatementSyntax*)node); break;
        case SyntaxKind::ClockingDeclaration: SyntaxNode::dispatch(v, *(const ClockingDeclarationSyntax*)node); break;
        case SyntaxKind::StructUnionMember: SyntaxNode::dispatch(v, *(const StructUnionMemberSyntax*)node); break;
        case SyntaxKind::ConstraintBlock: SyntaxNode::dispatch(v, *(const ConstraintBlockSyntax*)node); break;
        case SyntaxKind::AssertionItemPortList: SyntaxNode::dispatch(v, *(const AssertionItemPortListSyntax*)node); break;
        case SyntaxKind::NewClassExpression: SyntaxNode::dispatch(v, *(const NewClassExpressionSyntax*)node); break;
        case SyntaxKind::UnaryBitwiseOrExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::ConstraintDeclaration: SyntaxNode::dispatch(v, *(const ConstraintDeclarationSyntax*)node); break;
        case SyntaxKind::ClassScope: SyntaxNode::dispatch(v, *(const ClassScopeSyntax*)node); break;
        case SyntaxKind::SimpleRangeSelect: SyntaxNode::dispatch(v, *(const RangeSelectSyntax*)node); break;
        case SyntaxKind::AssignmentPatternItem: SyntaxNode::dispatch(v, *(const AssignmentPatternItemSyntax*)node); break;
        case SyntaxKind::NonAnsiPortList: SyntaxNode::dispatch(v, *(const NonAnsiPortListSyntax*)node); break;
        case SyntaxKind::ElsIfDirective: SyntaxNode::dispatch(v, *(const ConditionalBranchDirectiveSyntax*)node); break;
        case SyntaxKind::AnsiPortList: SyntaxNode::dispatch(v, *(const AnsiPortListSyntax*)node); break;
        case SyntaxKind::ClassPropertyDeclaration: SyntaxNode::dispatch(v, *(const ClassPropertyDeclarationSyntax*)node); break;
        case SyntaxKind::UnarySequenceEventExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::ArrayOrMethod: SyntaxNode::dispatch(v, *(const KeywordNameSyntax*)node); break;
        case SyntaxKind::UnaryMinusExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::EventuallyPropertyExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::IfDefDirective: SyntaxNode::dispatch(v, *(const ConditionalBranchDirectiveSyntax*)node); break;
        case SyntaxKind::StreamingConcatenationExpression: SyntaxNode::dispatch(v, *(const StreamingConcatenationExpressionSyntax*)node); break;
        case SyntaxKind::CoverageOption: SyntaxNode::dispatch(v, *(const CoverageOptionSyntax*)node); break;
        case SyntaxKind::PropertySequenceDeclaration: SyntaxNode::dispatch(v, *(const PropertySequenceDeclarationSyntax*)node); break;
        case SyntaxKind::InterfaceHeader: SyntaxNode::dispatch(v, *(const ModuleHeaderSyntax*)node); break;
        case SyntaxKind::StreamExpression: SyntaxNode::dispatch(v, *(const StreamExpressionSyntax*)node); break;
        case SyntaxKind::IntegerType: SyntaxNode::dispatch(v, *(const IntegerTypeSyntax*)node); break;
        case SyntaxKind::NamedArgument: SyntaxNode::dispatch(v, *(const NamedArgumentSyntax*)node); break;
        case SyntaxKind::DelayControl: SyntaxNode::dispatch(v, *(const DelaySyntax*)node); break;
        case SyntaxKind::BinaryAndExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::EmptyQueueExpression: SyntaxNode::dispatch(v, *(const EmptyQueueExpressionSyntax*)node); break;
        case SyntaxKind::ClassMethodDeclaration: SyntaxNode::dispatch(v, *(const ClassMethodDeclarationSyntax*)node); break;
        case SyntaxKind::PrimaryBlockEventExpression: SyntaxNode::dispatch(v, *(const PrimaryBlockEventExpressionSyntax*)node); break;
        case SyntaxKind::MemberAccessExpression: SyntaxNode::dispatch(v, *(const MemberAccessExpressionSyntax*)node); break;
        case SyntaxKind::CycleDelay: SyntaxNode::dispatch(v, *(const DelaySyntax*)node); break;
        case SyntaxKind::AssertPropertyStatement: SyntaxNode::dispatch(v, *(const ConcurrentAssertionStatementSyntax*)node); break;
        case SyntaxKind::ConstructorName: SyntaxNode::dispatch(v, *(const KeywordNameSyntax*)node); break;
        case SyntaxKind::XorAssignmentExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ContinuousAssign: SyntaxNode::dispatch(v, *(const ContinuousAssignSyntax*)node); break;
        case SyntaxKind::Coverpoint: SyntaxNode::dispatch(v, *(const CoverpointSyntax*)node); break;
        case SyntaxKind::AssignmentExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::WildcardPortList: SyntaxNode::dispatch(v, *(const WildcardPortListSyntax*)node); break;
        case SyntaxKind::UnbasedUnsizedLiteralExpression: SyntaxNode::dispatch(v, *(const LiteralExpressionSyntax*)node); break;
        case SyntaxKind::FunctionPort: SyntaxNode::dispatch(v, *(const FunctionPortSyntax*)node); break;
        case SyntaxKind::GenerateRegion: SyntaxNode::dispatch(v, *(const GenerateRegionSyntax*)node); break;
        case SyntaxKind::PragmaDirective: SyntaxNode::dispatch(v, *(const SimpleDirectiveSyntax*)node); break;
        case SyntaxKind::DefParam: SyntaxNode::dispatch(v, *(const DefParamSyntax*)node); break;
        case SyntaxKind::EmptyArgument: SyntaxNode::dispatch(v, *(const EmptyArgumentSyntax*)node); break;
        case SyntaxKind::PropertyType: SyntaxNode::dispatch(v, *(const KeywordTypeSyntax*)node); break;
        case SyntaxKind::ClockingItem: SyntaxNode::dispatch(v, *(const ClockingItemSyntax*)node); break;
        case SyntaxKind::DisableForkStatement: SyntaxNode::dispatch(v, *(const DisableForkStatementSyntax*)node); break;
        case SyntaxKind::BadExpression: SyntaxNode::dispatch(v, *(const BadExpressionSyntax*)node); break;
        case SyntaxKind::ImplicitAnsiPort: SyntaxNode::dispatch(v, *(const ImplicitAnsiPortSyntax*)node); break;
        case SyntaxKind::TimingControlExpression: SyntaxNode::dispatch(v, *(const TimingControlExpressionSyntax*)node); break;
        case SyntaxKind::VariableDimension: SyntaxNode::dispatch(v, *(const VariableDimensionSyntax*)node); break;
        case SyntaxKind::ClassName: SyntaxNode::dispatch(v, *(const ClassNameSyntax*)node); break;
        case SyntaxKind::ProceduralForceStatement: SyntaxNode::dispatch(v, *(const ProceduralAssignStatementSyntax*)node); break;
        case SyntaxKind::ForeachLoopList: SyntaxNode::dispatch(v, *(const ForeachLoopListSyntax*)node); break;
        case SyntaxKind::IdentifierName: SyntaxNode::dispatch(v, *(const IdentifierNameSyntax*)node); break;
        case SyntaxKind::TimingControlExpressionConcatenation: SyntaxNode::dispatch(v, *(const TimingControlExpressionConcatenationSyntax*)node); break;
        case SyntaxKind::ByteType: SyntaxNode::dispatch(v, *(const IntegerTypeSyntax*)node); break;
        case SyntaxKind::MinTypMaxExpression: SyntaxNode::dispatch(v, *(const MinTypMaxExpressionSyntax*)node); break;
        case SyntaxKind::DisableConstraint: SyntaxNode::dispatch(v, *(const DisableConstraintSyntax*)node); break;
        case SyntaxKind::WaitOrderStatement: SyntaxNode::dispatch(v, *(const WaitOrderStatementSyntax*)node); break;
        case SyntaxKind::ModportItem: SyntaxNode::dispatch(v, *(const ModportItemSyntax*)node); break;
        case SyntaxKind::VoidType: SyntaxNode::dispatch(v, *(const KeywordTypeSyntax*)node); break;
        case SyntaxKind::TimeType: SyntaxNode::dispatch(v, *(const IntegerTypeSyntax*)node); break;
        case SyntaxKind::InequalityExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::AlwaysFFBlock: SyntaxNode::dispatch(v, *(const ProceduralBlockSyntax*)node); break;
        case SyntaxKind::NamedPortConnection: SyntaxNode::dispatch(v, *(const NamedPortConnectionSyntax*)node); break;
        case SyntaxKind::ShortcutCycleDelayRange: SyntaxNode::dispatch(v, *(const ShortcutCycleDelayRangeSyntax*)node); break;
        case SyntaxKind::HierarchicalInstance: SyntaxNode::dispatch(v, *(const HierarchicalInstanceSyntax*)node); break;
        case SyntaxKind::WaitStatement: SyntaxNode::dispatch(v, *(const WaitStatementSyntax*)node); break;
        case SyntaxKind::CaseStatement: SyntaxNode::dispatch(v, *(const CaseStatementSyntax*)node); break;
        case SyntaxKind::OverlappedImplicationPropertyExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::GenvarDeclaration: SyntaxNode::dispatch(v, *(const GenvarDeclarationSyntax*)node); break;
        case SyntaxKind::ExternModule: SyntaxNode::dispatch(v, *(const ExternModuleSyntax*)node); break;
        case SyntaxKind::TimingControlStatement: SyntaxNode::dispatch(v, *(const TimingControlStatementSyntax*)node); break;
        case SyntaxKind::RandomizeMethodWithClause: SyntaxNode::dispatch(v, *(const RandomizeMethodWithClauseSyntax*)node); break;
        case SyntaxKind::ImplicitEventControl: SyntaxNode::dispatch(v, *(const ImplicitEventControlSyntax*)node); break;
        case SyntaxKind::StandardCaseItem: SyntaxNode::dispatch(v, *(const StandardCaseItemSyntax*)node); break;
        case SyntaxKind::ProgramHeader: SyntaxNode::dispatch(v, *(const ModuleHeaderSyntax*)node); break;
        case SyntaxKind::PowerExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::DataTypeDimensionSpecifier: SyntaxNode::dispatch(v, *(const DataTypeDimensionSpecifierSyntax*)node); break;
        case SyntaxKind::UnaryPlusExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::ClockingSkew: SyntaxNode::dispatch(v, *(const ClockingSkewSyntax*)node); break;
        case SyntaxKind::ArgumentList: SyntaxNode::dispatch(v, *(const ArgumentListSyntax*)node); break;
        case SyntaxKind::IntType: SyntaxNode::dispatch(v, *(const IntegerTypeSyntax*)node); break;
        case SyntaxKind::DriveStrength: SyntaxNode::dispatch(v, *(const DriveStrengthSyntax*)node); break;
        case SyntaxKind::ExpressionCoverageBinInitializer: SyntaxNode::dispatch(v, *(const ExpressionCoverageBinInitializerSyntax*)node); break;
        case SyntaxKind::RestrictPropertyStatement: SyntaxNode::dispatch(v, *(const ConcurrentAssertionStatementSyntax*)node); break;
        case SyntaxKind::IntegerVectorExpression: SyntaxNode::dispatch(v, *(const IntegerVectorExpressionSyntax*)node); break;
        case SyntaxKind::UnitScope: SyntaxNode::dispatch(v, *(const KeywordNameSyntax*)node); break;
        case SyntaxKind::SyncAcceptOnPropertyExpression: SyntaxNode::dispatch(v, *(const PrefixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::NonblockingAssignmentExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::HierarchyInstantiation: SyntaxNode::dispatch(v, *(const HierarchyInstantiationSyntax*)node); break;
        case SyntaxKind::ArithmeticRightShiftAssignmentExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::TypedefKeywordDeclaration: SyntaxNode::dispatch(v, *(const TypedefKeywordDeclarationSyntax*)node); break;
        case SyntaxKind::UniquenessConstraint: SyntaxNode::dispatch(v, *(const UniquenessConstraintSyntax*)node); break;
        case SyntaxKind::StringType: SyntaxNode::dispatch(v, *(const KeywordTypeSyntax*)node); break;
        case SyntaxKind::NetDeclaration: SyntaxNode::dispatch(v, *(const NetDeclarationSyntax*)node); break;
        case SyntaxKind::TaggedUnionExpression: SyntaxNode::dispatch(v, *(const TaggedUnionExpressionSyntax*)node); break;
        case SyntaxKind::ReturnStatement: SyntaxNode::dispatch(v, *(const ReturnStatementSyntax*)node); break;
        case SyntaxKind::LogicalLeftShiftAssignmentExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::ArrayXorMethod: SyntaxNode::dispatch(v, *(const KeywordNameSyntax*)node); break;
        case SyntaxKind::ExplicitAnsiPort: SyntaxNode::dispatch(v, *(const ExplicitAnsiPortSyntax*)node); break;
        case SyntaxKind::DistWeight: SyntaxNode::dispatch(v, *(const DistWeightSyntax*)node); break;
        case SyntaxKind::PostincrementExpression: SyntaxNode::dispatch(v, *(const PostfixUnaryExpressionSyntax*)node); break;
        case SyntaxKind::EnumType: SyntaxNode::dispatch(v, *(const EnumTypeSyntax*)node); break;
        case SyntaxKind::StructurePattern: SyntaxNode::dispatch(v, *(const StructurePatternSyntax*)node); break;
        case SyntaxKind::BitType: SyntaxNode::dispatch(v, *(const IntegerTypeSyntax*)node); break;
        case SyntaxKind::ArithmeticLeftShiftAssignmentExpression: SyntaxNode::dispatch(v, *(const BinaryExpressionSyntax*)node); break;
        case SyntaxKind::RootScope: SyntaxNode::dispatch(v, *(const KeywordNameSyntax*)node); break;
    }
}

}