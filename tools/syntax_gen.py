# This script generates C++ source for parse tree syntax nodes from a data file.

import os

def main():
	ourdir = os.path.dirname(os.path.realpath(__file__))
	inf = open(os.path.join(ourdir, "syntax.txt"))
	outf = open(os.path.join(ourdir, "../include/AllSyntax.h"), 'w')

	outf.write('''#pragma once

#include "SyntaxNode.h"
#include "Token.h"

// This file contains all parse tree syntax nodes.
// It is auto-generated by the syntax_gen.py script under the tools/ directory.

namespace slang {

''')

	currtype = None
	alltypes = {}

	for line in [x.strip('\n') for x in inf]:
		if line.startswith('//'):
			outf.write(line)
			outf.write('\n\n')
		elif len(line) == 0 or (currtype is not None and line == 'empty'):
			if currtype is not None:
				generate(outf, currtype_name, tags, currtype, alltypes)
			currtype = None
		elif currtype is not None:
			p = line.split(' ')
			if len(p) != 2:
				raise Exception("Two elements per member please.")
			currtype.append(p)
		elif line.startswith('forward '):
			outf.write('struct {};\n'.format(line[8:]))
		else:
			p = line.split(' ')
			currtype_name = p[0]
			tags = p[1:] if len(p) > 1 else None
			currtype = []

	if currtype:
		generate(outf, currtype_name, tags, currtype, alltypes)		
	outf.write('}')

def generate(outf, name, tags, members, alltypes):
	tagdict = {}
	if tags:
		for t in tags:
			p = t.split('=')
			tagdict[p[0]] = p[1]

	base = tagdict['base'] if 'base' in tagdict else 'SyntaxNode'
	outf.write('struct {} : public {} {{\n'.format(name, base))

	pointerMembers = set()
	processed_members = []
	baseInitializers = ''
	combined = members
	if base != 'SyntaxNode':
		processed_members.extend(alltypes[base][0])
		pointerMembers.union(alltypes[base][2])
		baseInitializers = ', '.join([x[1] for x in alltypes[base][1]])
		if baseInitializers:
			baseInitializers = ', ' + baseInitializers
		combined = alltypes[base][1] + members

	for m in members:
		if m[0] == 'token':
			typename = 'Token*'
		elif m[0] == 'tokenlist':
			typename = 'TokenList'
			pointerMembers.add(m[1])
		elif m[0].startswith('list<'):
			typename = 'SyntaxList<' + m[0][5:]
			pointerMembers.add(m[1])
		elif m[0].startswith('separated_list<'):
			typename = 'SeparatedSyntaxList<' + m[0][15:]
			pointerMembers.add(m[1])
		else:
			typename = m[0] + '*'

		l = '{} {}'.format(typename, m[1])
		processed_members.append(l)
		outf.write('    {};\n'.format(l))

	alltypes[name] = (processed_members, members, pointerMembers)

	kindArg = 'SyntaxKind kind' if 'kind' not in tagdict else ''
	kindValue = 'kind' if 'kind' not in tagdict else 'SyntaxKind::' + tagdict['kind']

	if kindArg and len(processed_members) > 0:
		kindArg += ', '

	initializers = ', '.join(['{0}({0})'.format(x[1]) for x in members])
	if initializers:
		initializers = ', ' + initializers

	final = ' final'
	if 'final' in tagdict and tagdict['final'] == 'false':
		final = ''

	outf.write('\n')
	outf.write('    {}({}{}) :\n'.format(name, kindArg, ', '.join(processed_members)))
	outf.write('        {}({}{}){}\n'.format(base, kindValue, baseInitializers, initializers))
	outf.write('    {\n')

	if len(members) == 0:
		outf.write('    }\n')
	else:
		outf.write('        childCount += {};\n'.format(len(members)))
		outf.write('    }\n')
		outf.write('\nprotected:\n')
		outf.write('    TokenOrSyntax getChild(uint32_t index) override{} {{\n'.format(final))
		outf.write('        switch(index) {\n')

		index = 0
		for m in combined:
			addr = '&' if m[1] in pointerMembers else ''
			outf.write('            case {}: return {}{};\n'.format(index, addr, m[1]))
			index += 1

		outf.write('            default: return nullptr;\n')
		outf.write('        }\n')
		outf.write('    }\n')

	outf.write('};\n\n')

if __name__ == "__main__":
	main()