//------------------------------------------------------------------------------
// AllSyntax.h
// All generated syntax node data structures.
//
// File is under the MIT license; see LICENSE for details.
//------------------------------------------------------------------------------
#pragma once

#include "SyntaxNode.h"
#include "Token.h"

// This file contains all parse tree syntax nodes.
// It is auto-generated by the syntax_gen.py script under the tools/ directory.

namespace slang {

struct ExpressionSyntax : public SyntaxNode {

    ExpressionSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct DataTypeSyntax : public ExpressionSyntax {

    DataTypeSyntax(SyntaxKind kind) :
        ExpressionSyntax(kind)
    {
    }
};

// ----- ATTRIBUTES -----

struct EqualsValueClauseSyntax : public SyntaxNode {
    Token equals;
    ExpressionSyntax* expr;

    EqualsValueClauseSyntax(Token equals, ExpressionSyntax* expr) :
        SyntaxNode(SyntaxKind::EqualsValueClause), equals(equals), expr(expr)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return equals;
            case 1: return expr;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: equals = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct AttributeSpecSyntax : public SyntaxNode {
    Token name;
    EqualsValueClauseSyntax* value;

    AttributeSpecSyntax(Token name, EqualsValueClauseSyntax* value) :
        SyntaxNode(SyntaxKind::AttributeSpec), name(name), value(value)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return name;
            case 1: return value;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: name = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct AttributeInstanceSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<AttributeSpecSyntax> specs;
    Token closeParen;

    AttributeInstanceSyntax(Token openParen, SeparatedSyntaxList<AttributeSpecSyntax> specs, Token closeParen) :
        SyntaxNode(SyntaxKind::AttributeInstance), openParen(openParen), specs(specs), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &specs;
            case 2: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openParen = token; break;
            case 1: ASSERT(false); break;
            case 2: closeParen = token; break;
        }
    }
};

struct NamedLabelSyntax : public SyntaxNode {
    Token name;
    Token colon;

    NamedLabelSyntax(Token name, Token colon) :
        SyntaxNode(SyntaxKind::NamedLabel), name(name), colon(colon)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return name;
            case 1: return colon;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: name = token; break;
            case 1: colon = token; break;
        }
    }
};

struct StatementSyntax : public SyntaxNode {
    NamedLabelSyntax* label;
    SyntaxList<AttributeInstanceSyntax> attributes;

    StatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes) :
        SyntaxNode(kind), label(label), attributes(attributes)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
        }
        (void)token;
    }
};

struct MemberSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;

    MemberSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes) :
        SyntaxNode(kind), attributes(attributes)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override {
        switch (index) {
            case 0: return &attributes;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override {
        switch (index) {
            case 0: ASSERT(false); break;
        }
        (void)token;
    }
};

// ----- ARGUMENTS -----

struct ArgumentSyntax : public SyntaxNode {

    ArgumentSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct OrderedArgumentSyntax : public ArgumentSyntax {
    ExpressionSyntax* expr;

    OrderedArgumentSyntax(ExpressionSyntax* expr) :
        ArgumentSyntax(SyntaxKind::OrderedArgument), expr(expr)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return expr;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
        }
        (void)token;
    }
};

struct NamedArgumentSyntax : public ArgumentSyntax {
    Token dot;
    Token name;
    Token openParen;
    ExpressionSyntax* expr;
    Token closeParen;

    NamedArgumentSyntax(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) :
        ArgumentSyntax(SyntaxKind::NamedArgument), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return dot;
            case 1: return name;
            case 2: return openParen;
            case 3: return expr;
            case 4: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: dot = token; break;
            case 1: name = token; break;
            case 2: openParen = token; break;
            case 3: ASSERT(false); break;
            case 4: closeParen = token; break;
        }
    }
};

struct ArgumentListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<ArgumentSyntax> parameters;
    Token closeParen;

    ArgumentListSyntax(Token openParen, SeparatedSyntaxList<ArgumentSyntax> parameters, Token closeParen) :
        SyntaxNode(SyntaxKind::ArgumentList), openParen(openParen), parameters(parameters), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &parameters;
            case 2: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openParen = token; break;
            case 1: ASSERT(false); break;
            case 2: closeParen = token; break;
        }
    }
};

struct ParameterValueAssignmentSyntax : public SyntaxNode {
    Token hash;
    ArgumentListSyntax* parameters;

    ParameterValueAssignmentSyntax(Token hash, ArgumentListSyntax* parameters) :
        SyntaxNode(SyntaxKind::ParameterValueAssignment), hash(hash), parameters(parameters)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return hash;
            case 1: return parameters;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: hash = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

// ----- PATTERNS -----

struct PatternSyntax : public SyntaxNode {

    PatternSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct VariablePatternSyntax : public PatternSyntax {
    Token dot;
    Token variableName;

    VariablePatternSyntax(Token dot, Token variableName) :
        PatternSyntax(SyntaxKind::VariablePattern), dot(dot), variableName(variableName)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return dot;
            case 1: return variableName;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: dot = token; break;
            case 1: variableName = token; break;
        }
    }
};

struct WildcardPatternSyntax : public PatternSyntax {
    Token dotStar;

    WildcardPatternSyntax(Token dotStar) :
        PatternSyntax(SyntaxKind::WildcardPattern), dotStar(dotStar)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return dotStar;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: dotStar = token; break;
        }
    }
};

struct ExpressionPatternSyntax : public PatternSyntax {
    ExpressionSyntax* expr;

    ExpressionPatternSyntax(ExpressionSyntax* expr) :
        PatternSyntax(SyntaxKind::ExpressionPattern), expr(expr)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return expr;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
        }
        (void)token;
    }
};

struct TaggedPatternSyntax : public PatternSyntax {
    Token tagged;
    Token memberName;
    PatternSyntax* pattern;

    TaggedPatternSyntax(Token tagged, Token memberName, PatternSyntax* pattern) :
        PatternSyntax(SyntaxKind::TaggedPattern), tagged(tagged), memberName(memberName), pattern(pattern)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return tagged;
            case 1: return memberName;
            case 2: return pattern;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: tagged = token; break;
            case 1: memberName = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct StructurePatternMemberSyntax : public SyntaxNode {

    StructurePatternMemberSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct OrderedStructurePatternMemberSyntax : public StructurePatternMemberSyntax {
    PatternSyntax* pattern;

    OrderedStructurePatternMemberSyntax(PatternSyntax* pattern) :
        StructurePatternMemberSyntax(SyntaxKind::OrderedStructurePatternMember), pattern(pattern)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return pattern;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
        }
        (void)token;
    }
};

struct NamedStructurePatternMemberSyntax : public StructurePatternMemberSyntax {
    Token name;
    Token colon;
    PatternSyntax* pattern;

    NamedStructurePatternMemberSyntax(Token name, Token colon, PatternSyntax* pattern) :
        StructurePatternMemberSyntax(SyntaxKind::NamedStructurePatternMember), name(name), colon(colon), pattern(pattern)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return name;
            case 1: return colon;
            case 2: return pattern;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: name = token; break;
            case 1: colon = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct StructurePatternSyntax : public PatternSyntax {
    Token openBrace;
    SeparatedSyntaxList<StructurePatternMemberSyntax> members;
    Token closeBrace;

    StructurePatternSyntax(Token openBrace, SeparatedSyntaxList<StructurePatternMemberSyntax> members, Token closeBrace) :
        PatternSyntax(SyntaxKind::StructurePattern), openBrace(openBrace), members(members), closeBrace(closeBrace)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return &members;
            case 2: return closeBrace;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openBrace = token; break;
            case 1: ASSERT(false); break;
            case 2: closeBrace = token; break;
        }
    }
};

struct MatchesClauseSyntax : public SyntaxNode {
    Token matchesKeyword;
    PatternSyntax* pattern;

    MatchesClauseSyntax(Token matchesKeyword, PatternSyntax* pattern) :
        SyntaxNode(SyntaxKind::MatchesClause), matchesKeyword(matchesKeyword), pattern(pattern)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return matchesKeyword;
            case 1: return pattern;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: matchesKeyword = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct ConditionalPatternSyntax : public SyntaxNode {
    ExpressionSyntax* expr;
    MatchesClauseSyntax* matchesClause;

    ConditionalPatternSyntax(ExpressionSyntax* expr, MatchesClauseSyntax* matchesClause) :
        SyntaxNode(SyntaxKind::ConditionalPattern), expr(expr), matchesClause(matchesClause)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return expr;
            case 1: return matchesClause;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
        }
        (void)token;
    }
};

struct ConditionalPredicateSyntax : public SyntaxNode {
    SeparatedSyntaxList<ConditionalPatternSyntax> conditions;

    ConditionalPredicateSyntax(SeparatedSyntaxList<ConditionalPatternSyntax> conditions) :
        SyntaxNode(SyntaxKind::ConditionalPredicate), conditions(conditions)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &conditions;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
        }
        (void)token;
    }
};

struct AssignmentPatternSyntax : public SyntaxNode {

    AssignmentPatternSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct SimpleAssignmentPatternSyntax : public AssignmentPatternSyntax {
    Token openBrace;
    SeparatedSyntaxList<ExpressionSyntax> items;
    Token closeBrace;

    SimpleAssignmentPatternSyntax(Token openBrace, SeparatedSyntaxList<ExpressionSyntax> items, Token closeBrace) :
        AssignmentPatternSyntax(SyntaxKind::SimpleAssignmentPattern), openBrace(openBrace), items(items), closeBrace(closeBrace)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return &items;
            case 2: return closeBrace;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openBrace = token; break;
            case 1: ASSERT(false); break;
            case 2: closeBrace = token; break;
        }
    }
};

struct AssignmentPatternItemSyntax : public SyntaxNode {
    ExpressionSyntax* key;
    Token colon;
    ExpressionSyntax* expr;

    AssignmentPatternItemSyntax(ExpressionSyntax* key, Token colon, ExpressionSyntax* expr) :
        SyntaxNode(SyntaxKind::AssignmentPatternItem), key(key), colon(colon), expr(expr)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return key;
            case 1: return colon;
            case 2: return expr;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: colon = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct StructuredAssignmentPatternSyntax : public AssignmentPatternSyntax {
    Token openBrace;
    SeparatedSyntaxList<AssignmentPatternItemSyntax> items;
    Token closeBrace;

    StructuredAssignmentPatternSyntax(Token openBrace, SeparatedSyntaxList<AssignmentPatternItemSyntax> items, Token closeBrace) :
        AssignmentPatternSyntax(SyntaxKind::StructuredAssignmentPattern), openBrace(openBrace), items(items), closeBrace(closeBrace)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return &items;
            case 2: return closeBrace;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openBrace = token; break;
            case 1: ASSERT(false); break;
            case 2: closeBrace = token; break;
        }
    }
};

struct ReplicatedAssignmentPatternSyntax : public AssignmentPatternSyntax {
    Token openBrace;
    ExpressionSyntax* countExpr;
    Token innerOpenBrace;
    SeparatedSyntaxList<ExpressionSyntax> items;
    Token innerCloseBrace;
    Token closeBrace;

    ReplicatedAssignmentPatternSyntax(Token openBrace, ExpressionSyntax* countExpr, Token innerOpenBrace, SeparatedSyntaxList<ExpressionSyntax> items, Token innerCloseBrace, Token closeBrace) :
        AssignmentPatternSyntax(SyntaxKind::ReplicatedAssignmentPattern), openBrace(openBrace), countExpr(countExpr), innerOpenBrace(innerOpenBrace), items(items), innerCloseBrace(innerCloseBrace), closeBrace(closeBrace)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return countExpr;
            case 2: return innerOpenBrace;
            case 3: return &items;
            case 4: return innerCloseBrace;
            case 5: return closeBrace;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openBrace = token; break;
            case 1: ASSERT(false); break;
            case 2: innerOpenBrace = token; break;
            case 3: ASSERT(false); break;
            case 4: innerCloseBrace = token; break;
            case 5: closeBrace = token; break;
        }
    }
};

// ----- EXPRESSIONS -----

struct BadExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax* expr;

    BadExpressionSyntax(ExpressionSyntax* expr) :
        ExpressionSyntax(SyntaxKind::BadExpression), expr(expr)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return expr;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
        }
        (void)token;
    }
};

struct PrimaryExpressionSyntax : public ExpressionSyntax {

    PrimaryExpressionSyntax(SyntaxKind kind) :
        ExpressionSyntax(kind)
    {
    }
};

struct PrefixUnaryExpressionSyntax : public ExpressionSyntax {
    Token operatorToken;
    SyntaxList<AttributeInstanceSyntax> attributes;
    ExpressionSyntax* operand;

    PrefixUnaryExpressionSyntax(SyntaxKind kind, Token operatorToken, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax* operand) :
        ExpressionSyntax(kind), operatorToken(operatorToken), attributes(attributes), operand(operand)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return operatorToken;
            case 1: return &attributes;
            case 2: return operand;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: operatorToken = token; break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
        }
    }
};

struct PostfixUnaryExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax* operand;
    SyntaxList<AttributeInstanceSyntax> attributes;
    Token operatorToken;

    PostfixUnaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax* operand, SyntaxList<AttributeInstanceSyntax> attributes, Token operatorToken) :
        ExpressionSyntax(kind), operand(operand), attributes(attributes), operatorToken(operatorToken)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return operand;
            case 1: return &attributes;
            case 2: return operatorToken;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: operatorToken = token; break;
        }
    }
};

struct BinaryExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax* left;
    Token operatorToken;
    SyntaxList<AttributeInstanceSyntax> attributes;
    ExpressionSyntax* right;

    BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax* left, Token operatorToken, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax* right) :
        ExpressionSyntax(kind), left(left), operatorToken(operatorToken), attributes(attributes), right(right)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return left;
            case 1: return operatorToken;
            case 2: return &attributes;
            case 3: return right;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: operatorToken = token; break;
            case 2: ASSERT(false); break;
            case 3: ASSERT(false); break;
        }
    }
};

struct MinTypMaxExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax* min;
    Token colon1;
    ExpressionSyntax* typ;
    Token colon2;
    ExpressionSyntax* max;

    MinTypMaxExpressionSyntax(ExpressionSyntax* min, Token colon1, ExpressionSyntax* typ, Token colon2, ExpressionSyntax* max) :
        ExpressionSyntax(SyntaxKind::MinTypMaxExpression), min(min), colon1(colon1), typ(typ), colon2(colon2), max(max)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return min;
            case 1: return colon1;
            case 2: return typ;
            case 3: return colon2;
            case 4: return max;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: colon1 = token; break;
            case 2: ASSERT(false); break;
            case 3: colon2 = token; break;
            case 4: ASSERT(false); break;
        }
    }
};

struct TaggedUnionExpressionSyntax : public ExpressionSyntax {
    Token tagged;
    Token member;
    ExpressionSyntax* expr;

    TaggedUnionExpressionSyntax(Token tagged, Token member, ExpressionSyntax* expr) :
        ExpressionSyntax(SyntaxKind::TaggedUnionExpression), tagged(tagged), member(member), expr(expr)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return tagged;
            case 1: return member;
            case 2: return expr;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: tagged = token; break;
            case 1: member = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct OpenRangeListSyntax : public SyntaxNode {
    Token openBrace;
    SeparatedSyntaxList<ExpressionSyntax> valueRanges;
    Token closeBrace;

    OpenRangeListSyntax(Token openBrace, SeparatedSyntaxList<ExpressionSyntax> valueRanges, Token closeBrace) :
        SyntaxNode(SyntaxKind::OpenRangeList), openBrace(openBrace), valueRanges(valueRanges), closeBrace(closeBrace)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return &valueRanges;
            case 2: return closeBrace;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openBrace = token; break;
            case 1: ASSERT(false); break;
            case 2: closeBrace = token; break;
        }
    }
};

struct InsideExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax* expr;
    Token inside;
    OpenRangeListSyntax* ranges;

    InsideExpressionSyntax(ExpressionSyntax* expr, Token inside, OpenRangeListSyntax* ranges) :
        ExpressionSyntax(SyntaxKind::InsideExpression), expr(expr), inside(inside), ranges(ranges)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return expr;
            case 1: return inside;
            case 2: return ranges;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: inside = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct ConditionalExpressionSyntax : public ExpressionSyntax {
    ConditionalPredicateSyntax* predicate;
    Token question;
    SyntaxList<AttributeInstanceSyntax> attributes;
    ExpressionSyntax* left;
    Token colon;
    ExpressionSyntax* right;

    ConditionalExpressionSyntax(ConditionalPredicateSyntax* predicate, Token question, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax* left, Token colon, ExpressionSyntax* right) :
        ExpressionSyntax(SyntaxKind::ConditionalExpression), predicate(predicate), question(question), attributes(attributes), left(left), colon(colon), right(right)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return predicate;
            case 1: return question;
            case 2: return &attributes;
            case 3: return left;
            case 4: return colon;
            case 5: return right;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: question = token; break;
            case 2: ASSERT(false); break;
            case 3: ASSERT(false); break;
            case 4: colon = token; break;
            case 5: ASSERT(false); break;
        }
    }
};

struct AssignmentPatternExpressionSyntax : public PrimaryExpressionSyntax {
    DataTypeSyntax* type;
    AssignmentPatternSyntax* pattern;

    AssignmentPatternExpressionSyntax(DataTypeSyntax* type, AssignmentPatternSyntax* pattern) :
        PrimaryExpressionSyntax(SyntaxKind::AssignmentPatternExpression), type(type), pattern(pattern)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return type;
            case 1: return pattern;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
        }
        (void)token;
    }
};

// ----- SELECTORS -----

struct SelectorSyntax : public SyntaxNode {

    SelectorSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct BitSelectSyntax : public SelectorSyntax {
    ExpressionSyntax* expr;

    BitSelectSyntax(ExpressionSyntax* expr) :
        SelectorSyntax(SyntaxKind::BitSelect), expr(expr)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return expr;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
        }
        (void)token;
    }
};

struct RangeSelectSyntax : public SelectorSyntax {
    ExpressionSyntax* left;
    Token range;
    ExpressionSyntax* right;

    RangeSelectSyntax(SyntaxKind kind, ExpressionSyntax* left, Token range, ExpressionSyntax* right) :
        SelectorSyntax(kind), left(left), range(range), right(right)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return left;
            case 1: return range;
            case 2: return right;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: range = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct ElementSelectSyntax : public ExpressionSyntax {
    Token openBracket;
    SelectorSyntax* selector;
    Token closeBracket;

    ElementSelectSyntax(Token openBracket, SelectorSyntax* selector, Token closeBracket) :
        ExpressionSyntax(SyntaxKind::ElementSelect), openBracket(openBracket), selector(selector), closeBracket(closeBracket)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openBracket;
            case 1: return selector;
            case 2: return closeBracket;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openBracket = token; break;
            case 1: ASSERT(false); break;
            case 2: closeBracket = token; break;
        }
    }
};

// ----- NAMES -----

struct NameSyntax : public ExpressionSyntax {

    NameSyntax(SyntaxKind kind) :
        ExpressionSyntax(kind)
    {
    }
};

struct IdentifierNameSyntax : public NameSyntax {
    Token identifier;

    IdentifierNameSyntax(Token identifier) :
        NameSyntax(SyntaxKind::IdentifierName), identifier(identifier)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return identifier;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: identifier = token; break;
        }
    }
};

struct IdentifierSelectNameSyntax : public NameSyntax {
    Token identifier;
    SyntaxList<ElementSelectSyntax> selectors;

    IdentifierSelectNameSyntax(Token identifier, SyntaxList<ElementSelectSyntax> selectors) :
        NameSyntax(SyntaxKind::IdentifierSelectName), identifier(identifier), selectors(selectors)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return identifier;
            case 1: return &selectors;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: identifier = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct EmptyIdentifierNameSyntax : public NameSyntax {

    EmptyIdentifierNameSyntax() :
        NameSyntax(SyntaxKind::EmptyIdentifierName)
    {
        childCount += 0;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
        }
    }
};

struct KeywordNameSyntax : public NameSyntax {
    Token keyword;

    KeywordNameSyntax(SyntaxKind kind, Token keyword) :
        NameSyntax(kind), keyword(keyword)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return keyword;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: keyword = token; break;
        }
    }
};

struct ClassNameSyntax : public NameSyntax {
    Token identifier;
    ParameterValueAssignmentSyntax* parameters;

    ClassNameSyntax(Token identifier, ParameterValueAssignmentSyntax* parameters) :
        NameSyntax(SyntaxKind::ClassName), identifier(identifier), parameters(parameters)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return identifier;
            case 1: return parameters;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: identifier = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct ScopedNameSyntax : public NameSyntax {
    NameSyntax* left;
    Token separator;
    NameSyntax* right;

    ScopedNameSyntax(NameSyntax* left, Token separator, NameSyntax* right) :
        NameSyntax(SyntaxKind::ScopedName), left(left), separator(separator), right(right)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return left;
            case 1: return separator;
            case 2: return right;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: separator = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct ClassScopeSyntax : public SyntaxNode {
    NameSyntax* left;
    Token separator;

    ClassScopeSyntax(NameSyntax* left, Token separator) :
        SyntaxNode(SyntaxKind::ClassScope), left(left), separator(separator)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return left;
            case 1: return separator;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: separator = token; break;
        }
    }
};

// ----- PRIMARY EXPRESSIONS -----

struct LiteralExpressionSyntax : public PrimaryExpressionSyntax {
    Token literal;

    LiteralExpressionSyntax(SyntaxKind kind, Token literal) :
        PrimaryExpressionSyntax(kind), literal(literal)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return literal;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: literal = token; break;
        }
    }
};

struct IntegerVectorExpressionSyntax : public PrimaryExpressionSyntax {
    Token size;
    Token base;
    Token value;

    IntegerVectorExpressionSyntax(Token size, Token base, Token value) :
        PrimaryExpressionSyntax(SyntaxKind::IntegerVectorExpression), size(size), base(base), value(value)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return size;
            case 1: return base;
            case 2: return value;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: size = token; break;
            case 1: base = token; break;
            case 2: value = token; break;
        }
    }
};

struct EmptyQueueExpressionSyntax : public PrimaryExpressionSyntax {
    Token openBrace;
    Token closeBrace;

    EmptyQueueExpressionSyntax(Token openBrace, Token closeBrace) :
        PrimaryExpressionSyntax(SyntaxKind::EmptyQueueExpression), openBrace(openBrace), closeBrace(closeBrace)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return closeBrace;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openBrace = token; break;
            case 1: closeBrace = token; break;
        }
    }
};

struct ConcatenationExpressionSyntax : public PrimaryExpressionSyntax {
    Token openBrace;
    SeparatedSyntaxList<ExpressionSyntax> expressions;
    Token closeBrace;

    ConcatenationExpressionSyntax(Token openBrace, SeparatedSyntaxList<ExpressionSyntax> expressions, Token closeBrace) :
        PrimaryExpressionSyntax(SyntaxKind::ConcatenationExpression), openBrace(openBrace), expressions(expressions), closeBrace(closeBrace)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return &expressions;
            case 2: return closeBrace;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openBrace = token; break;
            case 1: ASSERT(false); break;
            case 2: closeBrace = token; break;
        }
    }
};

struct MultipleConcatenationExpressionSyntax : public PrimaryExpressionSyntax {
    Token openBrace;
    ExpressionSyntax* expression;
    ConcatenationExpressionSyntax* concatenation;
    Token closeBrace;

    MultipleConcatenationExpressionSyntax(Token openBrace, ExpressionSyntax* expression, ConcatenationExpressionSyntax* concatenation, Token closeBrace) :
        PrimaryExpressionSyntax(SyntaxKind::MultipleConcatenationExpression), openBrace(openBrace), expression(expression), concatenation(concatenation), closeBrace(closeBrace)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return expression;
            case 2: return concatenation;
            case 3: return closeBrace;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openBrace = token; break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
            case 3: closeBrace = token; break;
        }
    }
};

struct StreamExpressionWithRange : public SyntaxNode {
    Token withKeyword;
    ElementSelectSyntax* range;

    StreamExpressionWithRange(Token withKeyword, ElementSelectSyntax* range) :
        SyntaxNode(SyntaxKind::StreamExpressionWithRange), withKeyword(withKeyword), range(range)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return withKeyword;
            case 1: return range;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: withKeyword = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct StreamExpressionSyntax : public SyntaxNode {
    ExpressionSyntax* expression;
    StreamExpressionWithRange* withRange;

    StreamExpressionSyntax(ExpressionSyntax* expression, StreamExpressionWithRange* withRange) :
        SyntaxNode(SyntaxKind::StreamExpression), expression(expression), withRange(withRange)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return expression;
            case 1: return withRange;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
        }
        (void)token;
    }
};

struct StreamingConcatenationExpressionSyntax : public PrimaryExpressionSyntax {
    Token openBrace;
    Token operatorToken;
    ExpressionSyntax* sliceSize;
    Token innerOpenBrace;
    SeparatedSyntaxList<StreamExpressionSyntax> expressions;
    Token innerCloseBrace;
    Token closeBrace;

    StreamingConcatenationExpressionSyntax(Token openBrace, Token operatorToken, ExpressionSyntax* sliceSize, Token innerOpenBrace, SeparatedSyntaxList<StreamExpressionSyntax> expressions, Token innerCloseBrace, Token closeBrace) :
        PrimaryExpressionSyntax(SyntaxKind::StreamingConcatenationExpression), openBrace(openBrace), operatorToken(operatorToken), sliceSize(sliceSize), innerOpenBrace(innerOpenBrace), expressions(expressions), innerCloseBrace(innerCloseBrace), closeBrace(closeBrace)
    {
        childCount += 7;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return operatorToken;
            case 2: return sliceSize;
            case 3: return innerOpenBrace;
            case 4: return &expressions;
            case 5: return innerCloseBrace;
            case 6: return closeBrace;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openBrace = token; break;
            case 1: operatorToken = token; break;
            case 2: ASSERT(false); break;
            case 3: innerOpenBrace = token; break;
            case 4: ASSERT(false); break;
            case 5: innerCloseBrace = token; break;
            case 6: closeBrace = token; break;
        }
    }
};

struct ParenthesizedExpressionSyntax : public PrimaryExpressionSyntax {
    Token openParen;
    ExpressionSyntax* expression;
    Token closeParen;

    ParenthesizedExpressionSyntax(Token openParen, ExpressionSyntax* expression, Token closeParen) :
        PrimaryExpressionSyntax(SyntaxKind::ParenthesizedExpression), openParen(openParen), expression(expression), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openParen;
            case 1: return expression;
            case 2: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openParen = token; break;
            case 1: ASSERT(false); break;
            case 2: closeParen = token; break;
        }
    }
};

struct NewClassExpressionSyntax : public ExpressionSyntax {
    ClassScopeSyntax* classScope;
    Token newKeyword;
    ArgumentListSyntax* arguments;

    NewClassExpressionSyntax(ClassScopeSyntax* classScope, Token newKeyword, ArgumentListSyntax* arguments) :
        ExpressionSyntax(SyntaxKind::NewClassExpression), classScope(classScope), newKeyword(newKeyword), arguments(arguments)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return classScope;
            case 1: return newKeyword;
            case 2: return arguments;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: newKeyword = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct NewArrayExpressionSyntax : public ExpressionSyntax {
    Token newKeyword;
    Token openBracket;
    ExpressionSyntax* sizeExpr;
    Token closeBracket;
    ParenthesizedExpressionSyntax* initializer;

    NewArrayExpressionSyntax(Token newKeyword, Token openBracket, ExpressionSyntax* sizeExpr, Token closeBracket, ParenthesizedExpressionSyntax* initializer) :
        ExpressionSyntax(SyntaxKind::NewArrayExpression), newKeyword(newKeyword), openBracket(openBracket), sizeExpr(sizeExpr), closeBracket(closeBracket), initializer(initializer)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return newKeyword;
            case 1: return openBracket;
            case 2: return sizeExpr;
            case 3: return closeBracket;
            case 4: return initializer;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: newKeyword = token; break;
            case 1: openBracket = token; break;
            case 2: ASSERT(false); break;
            case 3: closeBracket = token; break;
            case 4: ASSERT(false); break;
        }
    }
};

// ----- POSTFIX EXPRESSIONS -----

struct ElementSelectExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax* left;
    ElementSelectSyntax* select;

    ElementSelectExpressionSyntax(ExpressionSyntax* left, ElementSelectSyntax* select) :
        ExpressionSyntax(SyntaxKind::ElementSelectExpression), left(left), select(select)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return left;
            case 1: return select;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
        }
        (void)token;
    }
};

struct MemberAccessExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax* left;
    Token dot;
    Token name;

    MemberAccessExpressionSyntax(ExpressionSyntax* left, Token dot, Token name) :
        ExpressionSyntax(SyntaxKind::MemberAccessExpression), left(left), dot(dot), name(name)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return left;
            case 1: return dot;
            case 2: return name;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: dot = token; break;
            case 2: name = token; break;
        }
    }
};

struct InvocationExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax* left;
    SyntaxList<AttributeInstanceSyntax> attributes;
    ArgumentListSyntax* arguments;

    InvocationExpressionSyntax(ExpressionSyntax* left, SyntaxList<AttributeInstanceSyntax> attributes, ArgumentListSyntax* arguments) :
        ExpressionSyntax(SyntaxKind::InvocationExpression), left(left), attributes(attributes), arguments(arguments)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return left;
            case 1: return &attributes;
            case 2: return arguments;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
        }
        (void)token;
    }
};

struct CastExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax* left;
    Token apostrophe;
    ParenthesizedExpressionSyntax* right;

    CastExpressionSyntax(ExpressionSyntax* left, Token apostrophe, ParenthesizedExpressionSyntax* right) :
        ExpressionSyntax(SyntaxKind::CastExpression), left(left), apostrophe(apostrophe), right(right)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return left;
            case 1: return apostrophe;
            case 2: return right;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: apostrophe = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct SignedCastExpressionSyntax : public ExpressionSyntax {
    Token signing;
    Token apostrophe;
    ParenthesizedExpressionSyntax* inner;

    SignedCastExpressionSyntax(Token signing, Token apostrophe, ParenthesizedExpressionSyntax* inner) :
        ExpressionSyntax(SyntaxKind::SignedCastExpression), signing(signing), apostrophe(apostrophe), inner(inner)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return signing;
            case 1: return apostrophe;
            case 2: return inner;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: signing = token; break;
            case 1: apostrophe = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

// ----- TIMING CONTROL -----

struct TimingControlSyntax : public SyntaxNode {

    TimingControlSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct DelaySyntax : public TimingControlSyntax {
    Token hash;
    ExpressionSyntax* delayValue;

    DelaySyntax(SyntaxKind kind, Token hash, ExpressionSyntax* delayValue) :
        TimingControlSyntax(kind), hash(hash), delayValue(delayValue)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return hash;
            case 1: return delayValue;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: hash = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct EventControlSyntax : public TimingControlSyntax {
    Token at;
    NameSyntax* eventName;

    EventControlSyntax(Token at, NameSyntax* eventName) :
        TimingControlSyntax(SyntaxKind::EventControl), at(at), eventName(eventName)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return at;
            case 1: return eventName;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: at = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct EventExpressionSyntax : public SyntaxNode {

    EventExpressionSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct SignalEventExpressionSyntax : public EventExpressionSyntax {
    Token edge;
    ExpressionSyntax* expr;

    SignalEventExpressionSyntax(Token edge, ExpressionSyntax* expr) :
        EventExpressionSyntax(SyntaxKind::SignalEventExpression), edge(edge), expr(expr)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return edge;
            case 1: return expr;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: edge = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct BinaryEventExpressionSyntax : public EventExpressionSyntax {
    EventExpressionSyntax* left;
    Token operatorToken;
    EventExpressionSyntax* right;

    BinaryEventExpressionSyntax(EventExpressionSyntax* left, Token operatorToken, EventExpressionSyntax* right) :
        EventExpressionSyntax(SyntaxKind::BinaryEventExpression), left(left), operatorToken(operatorToken), right(right)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return left;
            case 1: return operatorToken;
            case 2: return right;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: operatorToken = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct ParenthesizedEventExpressionSyntax : public EventExpressionSyntax {
    Token openParen;
    EventExpressionSyntax* expr;
    Token closeParen;

    ParenthesizedEventExpressionSyntax(Token openParen, EventExpressionSyntax* expr, Token closeParen) :
        EventExpressionSyntax(SyntaxKind::ParenthesizedEventExpression), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openParen;
            case 1: return expr;
            case 2: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openParen = token; break;
            case 1: ASSERT(false); break;
            case 2: closeParen = token; break;
        }
    }
};

struct ImplicitEventControlSyntax : public TimingControlSyntax {
    Token atStar;

    ImplicitEventControlSyntax(Token atStar) :
        TimingControlSyntax(SyntaxKind::ImplicitEventControl), atStar(atStar)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return atStar;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: atStar = token; break;
        }
    }
};

struct ParenImplicitEventControlSyntax : public TimingControlSyntax {
    Token at;
    Token openParenStarCloseParen;

    ParenImplicitEventControlSyntax(Token at, Token openParenStarCloseParen) :
        TimingControlSyntax(SyntaxKind::ParenImplicitEventControl), at(at), openParenStarCloseParen(openParenStarCloseParen)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return at;
            case 1: return openParenStarCloseParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: at = token; break;
            case 1: openParenStarCloseParen = token; break;
        }
    }
};

struct EventControlWithExpressionSyntax : public TimingControlSyntax {
    Token at;
    EventExpressionSyntax* expr;

    EventControlWithExpressionSyntax(Token at, EventExpressionSyntax* expr) :
        TimingControlSyntax(SyntaxKind::EventControlWithExpression), at(at), expr(expr)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return at;
            case 1: return expr;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: at = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct RepeatedEventControlSyntax : public TimingControlSyntax {
    Token repeat;
    Token openParen;
    ExpressionSyntax* expr;
    Token closeParen;
    TimingControlSyntax* eventControl;

    RepeatedEventControlSyntax(Token repeat, Token openParen, ExpressionSyntax* expr, Token closeParen, TimingControlSyntax* eventControl) :
        TimingControlSyntax(SyntaxKind::RepeatedEventControl), repeat(repeat), openParen(openParen), expr(expr), closeParen(closeParen), eventControl(eventControl)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return repeat;
            case 1: return openParen;
            case 2: return expr;
            case 3: return closeParen;
            case 4: return eventControl;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: repeat = token; break;
            case 1: openParen = token; break;
            case 2: ASSERT(false); break;
            case 3: closeParen = token; break;
            case 4: ASSERT(false); break;
        }
    }
};

struct TimingControlExpressionSyntax : public ExpressionSyntax {
    TimingControlSyntax* timing;
    ExpressionSyntax* expr;

    TimingControlExpressionSyntax(TimingControlSyntax* timing, ExpressionSyntax* expr) :
        ExpressionSyntax(SyntaxKind::TimingControlExpression), timing(timing), expr(expr)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return timing;
            case 1: return expr;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
        }
        (void)token;
    }
};

struct ShortcutCycleDelayRangeSyntax : public TimingControlSyntax {
    Token doubleHash;
    Token openBracket;
    Token op;
    Token closeBracket;

    ShortcutCycleDelayRangeSyntax(Token doubleHash, Token openBracket, Token op, Token closeBracket) :
        TimingControlSyntax(SyntaxKind::ShortcutCycleDelayRange), doubleHash(doubleHash), openBracket(openBracket), op(op), closeBracket(closeBracket)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return doubleHash;
            case 1: return openBracket;
            case 2: return op;
            case 3: return closeBracket;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: doubleHash = token; break;
            case 1: openBracket = token; break;
            case 2: op = token; break;
            case 3: closeBracket = token; break;
        }
    }
};

// ----- DECLARATIONS -----

struct DimensionSpecifierSyntax : public SyntaxNode {

    DimensionSpecifierSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct RangeDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
    SelectorSyntax* selector;

    RangeDimensionSpecifierSyntax(SelectorSyntax* selector) :
        DimensionSpecifierSyntax(SyntaxKind::RangeDimensionSpecifier), selector(selector)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return selector;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
        }
        (void)token;
    }
};

struct DataTypeDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
    DataTypeSyntax* type;

    DataTypeDimensionSpecifierSyntax(DataTypeSyntax* type) :
        DimensionSpecifierSyntax(SyntaxKind::DataTypeDimensionSpecifier), type(type)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return type;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
        }
        (void)token;
    }
};

struct WildcardDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
    Token star;

    WildcardDimensionSpecifierSyntax(Token star) :
        DimensionSpecifierSyntax(SyntaxKind::WildcardDimensionSpecifier), star(star)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return star;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: star = token; break;
        }
    }
};

struct ColonExpressionClauseSyntax : public SyntaxNode {
    Token colon;
    ExpressionSyntax* expr;

    ColonExpressionClauseSyntax(Token colon, ExpressionSyntax* expr) :
        SyntaxNode(SyntaxKind::ColonExpressionClause), colon(colon), expr(expr)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return colon;
            case 1: return expr;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: colon = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct QueueDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
    Token dollar;
    ColonExpressionClauseSyntax* maxSizeClause;

    QueueDimensionSpecifierSyntax(Token dollar, ColonExpressionClauseSyntax* maxSizeClause) :
        DimensionSpecifierSyntax(SyntaxKind::QueueDimensionSpecifier), dollar(dollar), maxSizeClause(maxSizeClause)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return dollar;
            case 1: return maxSizeClause;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: dollar = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct VariableDimensionSyntax : public SyntaxNode {
    Token openBracket;
    DimensionSpecifierSyntax* specifier;
    Token closeBracket;

    VariableDimensionSyntax(Token openBracket, DimensionSpecifierSyntax* specifier, Token closeBracket) :
        SyntaxNode(SyntaxKind::VariableDimension), openBracket(openBracket), specifier(specifier), closeBracket(closeBracket)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openBracket;
            case 1: return specifier;
            case 2: return closeBracket;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openBracket = token; break;
            case 1: ASSERT(false); break;
            case 2: closeBracket = token; break;
        }
    }
};

struct VariableDeclaratorSyntax : public SyntaxNode {
    Token name;
    SyntaxList<VariableDimensionSyntax> dimensions;
    EqualsValueClauseSyntax* initializer;

    VariableDeclaratorSyntax(Token name, SyntaxList<VariableDimensionSyntax> dimensions, EqualsValueClauseSyntax* initializer) :
        SyntaxNode(SyntaxKind::VariableDeclarator), name(name), dimensions(dimensions), initializer(initializer)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return name;
            case 1: return &dimensions;
            case 2: return initializer;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: name = token; break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
        }
    }
};

struct DataDeclarationSyntax : public MemberSyntax {
    TokenList modifiers;
    DataTypeSyntax* type;
    SeparatedSyntaxList<VariableDeclaratorSyntax> declarators;
    Token semi;

    DataDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList modifiers, DataTypeSyntax* type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token semi) :
        MemberSyntax(SyntaxKind::DataDeclaration, attributes), modifiers(modifiers), type(type), declarators(declarators), semi(semi)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &modifiers;
            case 2: return type;
            case 3: return &declarators;
            case 4: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
            case 3: ASSERT(false); break;
            case 4: semi = token; break;
        }
    }
};

struct TypedefDeclarationSyntax : public MemberSyntax {
    Token typedefKeyword;
    DataTypeSyntax* type;
    Token name;
    SyntaxList<VariableDimensionSyntax> dimensions;
    Token semi;

    TypedefDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token typedefKeyword, DataTypeSyntax* type, Token name, SyntaxList<VariableDimensionSyntax> dimensions, Token semi) :
        MemberSyntax(SyntaxKind::TypedefDeclaration, attributes), typedefKeyword(typedefKeyword), type(type), name(name), dimensions(dimensions), semi(semi)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return typedefKeyword;
            case 2: return type;
            case 3: return name;
            case 4: return &dimensions;
            case 5: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: typedefKeyword = token; break;
            case 2: ASSERT(false); break;
            case 3: name = token; break;
            case 4: ASSERT(false); break;
            case 5: semi = token; break;
        }
    }
};

struct TypedefKeywordDeclarationSyntax : public MemberSyntax {
    Token typedefKeyword;
    Token keyword;
    Token name;
    Token semi;

    TypedefKeywordDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token typedefKeyword, Token keyword, Token name, Token semi) :
        MemberSyntax(SyntaxKind::TypedefKeywordDeclaration, attributes), typedefKeyword(typedefKeyword), keyword(keyword), name(name), semi(semi)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return typedefKeyword;
            case 2: return keyword;
            case 3: return name;
            case 4: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: typedefKeyword = token; break;
            case 2: keyword = token; break;
            case 3: name = token; break;
            case 4: semi = token; break;
        }
    }
};

struct TypedefInterfaceClassDeclarationSyntax : public MemberSyntax {
    Token typedefKeyword;
    Token interfaceKeyword;
    Token classKeyword;
    Token name;
    Token semi;

    TypedefInterfaceClassDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token typedefKeyword, Token interfaceKeyword, Token classKeyword, Token name, Token semi) :
        MemberSyntax(SyntaxKind::TypedefInterfaceClassDeclaration, attributes), typedefKeyword(typedefKeyword), interfaceKeyword(interfaceKeyword), classKeyword(classKeyword), name(name), semi(semi)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return typedefKeyword;
            case 2: return interfaceKeyword;
            case 3: return classKeyword;
            case 4: return name;
            case 5: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: typedefKeyword = token; break;
            case 2: interfaceKeyword = token; break;
            case 3: classKeyword = token; break;
            case 4: name = token; break;
            case 5: semi = token; break;
        }
    }
};

struct NetStrengthSyntax : public SyntaxNode {

    NetStrengthSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct ChargeStrengthSyntax : public NetStrengthSyntax {
    Token openParen;
    Token strength;
    Token closeParen;

    ChargeStrengthSyntax(Token openParen, Token strength, Token closeParen) :
        NetStrengthSyntax(SyntaxKind::ChargeStrength), openParen(openParen), strength(strength), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openParen;
            case 1: return strength;
            case 2: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openParen = token; break;
            case 1: strength = token; break;
            case 2: closeParen = token; break;
        }
    }
};

struct DriveStrengthSyntax : public NetStrengthSyntax {
    Token openParen;
    Token strength0;
    Token comma;
    Token strength1;
    Token closeParen;

    DriveStrengthSyntax(Token openParen, Token strength0, Token comma, Token strength1, Token closeParen) :
        NetStrengthSyntax(SyntaxKind::DriveStrength), openParen(openParen), strength0(strength0), comma(comma), strength1(strength1), closeParen(closeParen)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openParen;
            case 1: return strength0;
            case 2: return comma;
            case 3: return strength1;
            case 4: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openParen = token; break;
            case 1: strength0 = token; break;
            case 2: comma = token; break;
            case 3: strength1 = token; break;
            case 4: closeParen = token; break;
        }
    }
};

struct NetDeclarationSyntax : public MemberSyntax {
    Token netType;
    NetStrengthSyntax* strength;
    Token expansionHint;
    DataTypeSyntax* type;
    SeparatedSyntaxList<VariableDeclaratorSyntax> declarators;
    Token semi;

    NetDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token netType, NetStrengthSyntax* strength, Token expansionHint, DataTypeSyntax* type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token semi) :
        MemberSyntax(SyntaxKind::NetDeclaration, attributes), netType(netType), strength(strength), expansionHint(expansionHint), type(type), declarators(declarators), semi(semi)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return netType;
            case 2: return strength;
            case 3: return expansionHint;
            case 4: return type;
            case 5: return &declarators;
            case 6: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: netType = token; break;
            case 2: ASSERT(false); break;
            case 3: expansionHint = token; break;
            case 4: ASSERT(false); break;
            case 5: ASSERT(false); break;
            case 6: semi = token; break;
        }
    }
};

struct PackageImportItemSyntax : public SyntaxNode {
    Token package;
    Token doubleColon;
    Token item;

    PackageImportItemSyntax(Token package, Token doubleColon, Token item) :
        SyntaxNode(SyntaxKind::PackageImportItem), package(package), doubleColon(doubleColon), item(item)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return package;
            case 1: return doubleColon;
            case 2: return item;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: package = token; break;
            case 1: doubleColon = token; break;
            case 2: item = token; break;
        }
    }
};

struct PackageImportDeclarationSyntax : public MemberSyntax {
    Token keyword;
    SeparatedSyntaxList<PackageImportItemSyntax> items;
    Token semi;

    PackageImportDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, SeparatedSyntaxList<PackageImportItemSyntax> items, Token semi) :
        MemberSyntax(SyntaxKind::PackageImportDeclaration, attributes), keyword(keyword), items(items), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return &items;
            case 3: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: keyword = token; break;
            case 2: ASSERT(false); break;
            case 3: semi = token; break;
        }
    }
};

struct ParameterDeclarationSyntax : public SyntaxNode {
    Token keyword;
    DataTypeSyntax* type;
    SeparatedSyntaxList<VariableDeclaratorSyntax> declarators;

    ParameterDeclarationSyntax(Token keyword, DataTypeSyntax* type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators) :
        SyntaxNode(SyntaxKind::ParameterDeclaration), keyword(keyword), type(type), declarators(declarators)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return keyword;
            case 1: return type;
            case 2: return &declarators;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: keyword = token; break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
        }
    }
};

struct ParameterDeclarationStatementSyntax : public MemberSyntax {
    ParameterDeclarationSyntax* parameter;
    Token semi;

    ParameterDeclarationStatementSyntax(SyntaxList<AttributeInstanceSyntax> attributes, ParameterDeclarationSyntax* parameter, Token semi) :
        MemberSyntax(SyntaxKind::ParameterDeclarationStatement, attributes), parameter(parameter), semi(semi)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return parameter;
            case 2: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: semi = token; break;
        }
    }
};

struct PortHeaderSyntax : public SyntaxNode {

    PortHeaderSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct PortDeclarationSyntax : public MemberSyntax {
    PortHeaderSyntax* header;
    SeparatedSyntaxList<VariableDeclaratorSyntax> declarators;
    Token semi;

    PortDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, PortHeaderSyntax* header, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token semi) :
        MemberSyntax(SyntaxKind::PortDeclaration, attributes), header(header), declarators(declarators), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return header;
            case 2: return &declarators;
            case 3: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
            case 3: semi = token; break;
        }
    }
};

struct GenvarDeclarationSyntax : public MemberSyntax {
    Token keyword;
    SeparatedSyntaxList<IdentifierNameSyntax> identifiers;
    Token semi;

    GenvarDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, SeparatedSyntaxList<IdentifierNameSyntax> identifiers, Token semi) :
        MemberSyntax(SyntaxKind::GenvarDeclaration, attributes), keyword(keyword), identifiers(identifiers), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return &identifiers;
            case 3: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: keyword = token; break;
            case 2: ASSERT(false); break;
            case 3: semi = token; break;
        }
    }
};

// ----- TYPES -----

struct IntegerTypeSyntax : public DataTypeSyntax {
    Token keyword;
    Token signing;
    SyntaxList<VariableDimensionSyntax> dimensions;

    IntegerTypeSyntax(SyntaxKind kind, Token keyword, Token signing, SyntaxList<VariableDimensionSyntax> dimensions) :
        DataTypeSyntax(kind), keyword(keyword), signing(signing), dimensions(dimensions)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return keyword;
            case 1: return signing;
            case 2: return &dimensions;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: keyword = token; break;
            case 1: signing = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct KeywordTypeSyntax : public DataTypeSyntax {
    Token keyword;

    KeywordTypeSyntax(SyntaxKind kind, Token keyword) :
        DataTypeSyntax(kind), keyword(keyword)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return keyword;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: keyword = token; break;
        }
    }
};

struct NamedTypeSyntax : public DataTypeSyntax {
    NameSyntax* name;

    NamedTypeSyntax(NameSyntax* name) :
        DataTypeSyntax(SyntaxKind::NamedType), name(name)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return name;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
        }
        (void)token;
    }
};

struct StructUnionMemberSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;
    Token randomQualifier;
    DataTypeSyntax* type;
    SeparatedSyntaxList<VariableDeclaratorSyntax> declarators;
    Token semi;

    StructUnionMemberSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token randomQualifier, DataTypeSyntax* type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token semi) :
        SyntaxNode(SyntaxKind::StructUnionMember), attributes(attributes), randomQualifier(randomQualifier), type(type), declarators(declarators), semi(semi)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return randomQualifier;
            case 2: return type;
            case 3: return &declarators;
            case 4: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: randomQualifier = token; break;
            case 2: ASSERT(false); break;
            case 3: ASSERT(false); break;
            case 4: semi = token; break;
        }
    }
};

struct StructUnionTypeSyntax : public DataTypeSyntax {
    Token keyword;
    Token tagged;
    Token packed;
    Token signing;
    Token openBrace;
    SyntaxList<StructUnionMemberSyntax> members;
    Token closeBrace;
    SyntaxList<VariableDimensionSyntax> dimensions;

    StructUnionTypeSyntax(SyntaxKind kind, Token keyword, Token tagged, Token packed, Token signing, Token openBrace, SyntaxList<StructUnionMemberSyntax> members, Token closeBrace, SyntaxList<VariableDimensionSyntax> dimensions) :
        DataTypeSyntax(kind), keyword(keyword), tagged(tagged), packed(packed), signing(signing), openBrace(openBrace), members(members), closeBrace(closeBrace), dimensions(dimensions)
    {
        childCount += 8;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return keyword;
            case 1: return tagged;
            case 2: return packed;
            case 3: return signing;
            case 4: return openBrace;
            case 5: return &members;
            case 6: return closeBrace;
            case 7: return &dimensions;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: keyword = token; break;
            case 1: tagged = token; break;
            case 2: packed = token; break;
            case 3: signing = token; break;
            case 4: openBrace = token; break;
            case 5: ASSERT(false); break;
            case 6: closeBrace = token; break;
            case 7: ASSERT(false); break;
        }
    }
};

struct EnumTypeSyntax : public DataTypeSyntax {
    Token keyword;
    DataTypeSyntax* baseType;
    Token openBrace;
    SeparatedSyntaxList<VariableDeclaratorSyntax> members;
    Token closeBrace;
    SyntaxList<VariableDimensionSyntax> dimensions;

    EnumTypeSyntax(Token keyword, DataTypeSyntax* baseType, Token openBrace, SeparatedSyntaxList<VariableDeclaratorSyntax> members, Token closeBrace, SyntaxList<VariableDimensionSyntax> dimensions) :
        DataTypeSyntax(SyntaxKind::EnumType), keyword(keyword), baseType(baseType), openBrace(openBrace), members(members), closeBrace(closeBrace), dimensions(dimensions)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return keyword;
            case 1: return baseType;
            case 2: return openBrace;
            case 3: return &members;
            case 4: return closeBrace;
            case 5: return &dimensions;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: keyword = token; break;
            case 1: ASSERT(false); break;
            case 2: openBrace = token; break;
            case 3: ASSERT(false); break;
            case 4: closeBrace = token; break;
            case 5: ASSERT(false); break;
        }
    }
};

struct TypeReferenceSyntax : public DataTypeSyntax {
    Token typeKeyword;
    Token openParen;
    ExpressionSyntax* expr;
    Token closeParen;

    TypeReferenceSyntax(Token typeKeyword, Token openParen, ExpressionSyntax* expr, Token closeParen) :
        DataTypeSyntax(SyntaxKind::TypeReference), typeKeyword(typeKeyword), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return typeKeyword;
            case 1: return openParen;
            case 2: return expr;
            case 3: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: typeKeyword = token; break;
            case 1: openParen = token; break;
            case 2: ASSERT(false); break;
            case 3: closeParen = token; break;
        }
    }
};

struct DotMemberClauseSyntax : public SyntaxNode {
    Token dot;
    Token member;

    DotMemberClauseSyntax(Token dot, Token member) :
        SyntaxNode(SyntaxKind::DotMemberClause), dot(dot), member(member)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return dot;
            case 1: return member;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: dot = token; break;
            case 1: member = token; break;
        }
    }
};

struct VirtualInterfaceTypeSyntax : public DataTypeSyntax {
    Token virtualKeyword;
    Token interfaceKeyword;
    Token name;
    ParameterValueAssignmentSyntax* parameters;
    DotMemberClauseSyntax* modport;

    VirtualInterfaceTypeSyntax(Token virtualKeyword, Token interfaceKeyword, Token name, ParameterValueAssignmentSyntax* parameters, DotMemberClauseSyntax* modport) :
        DataTypeSyntax(SyntaxKind::VirtualInterfaceType), virtualKeyword(virtualKeyword), interfaceKeyword(interfaceKeyword), name(name), parameters(parameters), modport(modport)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return virtualKeyword;
            case 1: return interfaceKeyword;
            case 2: return name;
            case 3: return parameters;
            case 4: return modport;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: virtualKeyword = token; break;
            case 1: interfaceKeyword = token; break;
            case 2: name = token; break;
            case 3: ASSERT(false); break;
            case 4: ASSERT(false); break;
        }
    }
};

struct ImplicitTypeSyntax : public DataTypeSyntax {
    Token signing;
    SyntaxList<VariableDimensionSyntax> dimensions;

    ImplicitTypeSyntax(Token signing, SyntaxList<VariableDimensionSyntax> dimensions) :
        DataTypeSyntax(SyntaxKind::ImplicitType), signing(signing), dimensions(dimensions)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return signing;
            case 1: return &dimensions;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: signing = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

// ----- ASSERTIONS -----

struct DeferredAssertionSyntax : public SyntaxNode {
    Token hash;
    Token zero;
    Token finalKeyword;

    DeferredAssertionSyntax(Token hash, Token zero, Token finalKeyword) :
        SyntaxNode(SyntaxKind::DeferredAssertion), hash(hash), zero(zero), finalKeyword(finalKeyword)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return hash;
            case 1: return zero;
            case 2: return finalKeyword;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: hash = token; break;
            case 1: zero = token; break;
            case 2: finalKeyword = token; break;
        }
    }
};

struct ElseClauseSyntax : public SyntaxNode {
    Token elseKeyword;
    SyntaxNode* clause;

    ElseClauseSyntax(Token elseKeyword, SyntaxNode* clause) :
        SyntaxNode(SyntaxKind::ElseClause), elseKeyword(elseKeyword), clause(clause)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return elseKeyword;
            case 1: return clause;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: elseKeyword = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct ActionBlockSyntax : public SyntaxNode {
    StatementSyntax* statement;
    ElseClauseSyntax* elseClause;

    ActionBlockSyntax(StatementSyntax* statement, ElseClauseSyntax* elseClause) :
        SyntaxNode(SyntaxKind::ActionBlock), statement(statement), elseClause(elseClause)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return statement;
            case 1: return elseClause;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
        }
        (void)token;
    }
};

struct ImmediateAssertionStatementSyntax : public StatementSyntax {
    Token keyword;
    DeferredAssertionSyntax* delay;
    ParenthesizedExpressionSyntax* expr;
    ActionBlockSyntax* action;

    ImmediateAssertionStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, DeferredAssertionSyntax* delay, ParenthesizedExpressionSyntax* expr, ActionBlockSyntax* action) :
        StatementSyntax(kind, label, attributes), keyword(keyword), delay(delay), expr(expr), action(action)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return keyword;
            case 3: return delay;
            case 4: return expr;
            case 5: return action;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: keyword = token; break;
            case 3: ASSERT(false); break;
            case 4: ASSERT(false); break;
            case 5: ASSERT(false); break;
        }
    }
};

struct DisableIffSyntax : public SyntaxNode {
    Token disable;
    Token iff;
    Token openParen;
    ExpressionSyntax* expr;
    Token closeParen;

    DisableIffSyntax(Token disable, Token iff, Token openParen, ExpressionSyntax* expr, Token closeParen) :
        SyntaxNode(SyntaxKind::DisableIff), disable(disable), iff(iff), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return disable;
            case 1: return iff;
            case 2: return openParen;
            case 3: return expr;
            case 4: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: disable = token; break;
            case 1: iff = token; break;
            case 2: openParen = token; break;
            case 3: ASSERT(false); break;
            case 4: closeParen = token; break;
        }
    }
};

struct PropertySpecSyntax : public SyntaxNode {
    TimingControlSyntax* clocking;
    DisableIffSyntax* disable;
    ExpressionSyntax* expr;

    PropertySpecSyntax(TimingControlSyntax* clocking, DisableIffSyntax* disable, ExpressionSyntax* expr) :
        SyntaxNode(SyntaxKind::PropertySpec), clocking(clocking), disable(disable), expr(expr)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return clocking;
            case 1: return disable;
            case 2: return expr;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
        }
        (void)token;
    }
};

struct ConcurrentAssertionStatementSyntax : public StatementSyntax {
    Token keyword;
    Token propertyOrSequence;
    Token openParen;
    PropertySpecSyntax* propertySpec;
    Token closeParen;
    ActionBlockSyntax* action;

    ConcurrentAssertionStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token propertyOrSequence, Token openParen, PropertySpecSyntax* propertySpec, Token closeParen, ActionBlockSyntax* action) :
        StatementSyntax(kind, label, attributes), keyword(keyword), propertyOrSequence(propertyOrSequence), openParen(openParen), propertySpec(propertySpec), closeParen(closeParen), action(action)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return keyword;
            case 3: return propertyOrSequence;
            case 4: return openParen;
            case 5: return propertySpec;
            case 6: return closeParen;
            case 7: return action;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: keyword = token; break;
            case 3: propertyOrSequence = token; break;
            case 4: openParen = token; break;
            case 5: ASSERT(false); break;
            case 6: closeParen = token; break;
            case 7: ASSERT(false); break;
        }
    }
};

struct ConcurrentAssertionMemberSyntax : public MemberSyntax {
    ConcurrentAssertionStatementSyntax* statement;

    ConcurrentAssertionMemberSyntax(SyntaxList<AttributeInstanceSyntax> attributes, ConcurrentAssertionStatementSyntax* statement) :
        MemberSyntax(SyntaxKind::ConcurrentAssertionMember, attributes), statement(statement)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return statement;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
        }
        (void)token;
    }
};

struct ImmediateAssertionMemberSyntax : public MemberSyntax {
    ImmediateAssertionStatementSyntax* statement;

    ImmediateAssertionMemberSyntax(SyntaxList<AttributeInstanceSyntax> attributes, ImmediateAssertionStatementSyntax* statement) :
        MemberSyntax(SyntaxKind::ImmediateAssertionMember, attributes), statement(statement)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return statement;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
        }
        (void)token;
    }
};

struct AbortPropertyExpressionSyntax : public ExpressionSyntax {
    Token keyword;
    Token openParen;
    ExpressionSyntax* condition;
    Token closeParen;
    ExpressionSyntax* expr;

    AbortPropertyExpressionSyntax(SyntaxKind kind, Token keyword, Token openParen, ExpressionSyntax* condition, Token closeParen, ExpressionSyntax* expr) :
        ExpressionSyntax(kind), keyword(keyword), openParen(openParen), condition(condition), closeParen(closeParen), expr(expr)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return keyword;
            case 1: return openParen;
            case 2: return condition;
            case 3: return closeParen;
            case 4: return expr;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: keyword = token; break;
            case 1: openParen = token; break;
            case 2: ASSERT(false); break;
            case 3: closeParen = token; break;
            case 4: ASSERT(false); break;
        }
    }
};

// ----- STATEMENTS -----

struct EmptyStatementSyntax : public StatementSyntax {
    Token semicolon;

    EmptyStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token semicolon) :
        StatementSyntax(SyntaxKind::EmptyStatement, label, attributes), semicolon(semicolon)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return semicolon;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: semicolon = token; break;
        }
    }
};

struct ConditionalStatementSyntax : public StatementSyntax {
    Token uniqueOrPriority;
    Token ifKeyword;
    Token openParen;
    ConditionalPredicateSyntax* predicate;
    Token closeParen;
    StatementSyntax* statement;
    ElseClauseSyntax* elseClause;

    ConditionalStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token uniqueOrPriority, Token ifKeyword, Token openParen, ConditionalPredicateSyntax* predicate, Token closeParen, StatementSyntax* statement, ElseClauseSyntax* elseClause) :
        StatementSyntax(SyntaxKind::ConditionalStatement, label, attributes), uniqueOrPriority(uniqueOrPriority), ifKeyword(ifKeyword), openParen(openParen), predicate(predicate), closeParen(closeParen), statement(statement), elseClause(elseClause)
    {
        childCount += 7;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return uniqueOrPriority;
            case 3: return ifKeyword;
            case 4: return openParen;
            case 5: return predicate;
            case 6: return closeParen;
            case 7: return statement;
            case 8: return elseClause;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: uniqueOrPriority = token; break;
            case 3: ifKeyword = token; break;
            case 4: openParen = token; break;
            case 5: ASSERT(false); break;
            case 6: closeParen = token; break;
            case 7: ASSERT(false); break;
            case 8: ASSERT(false); break;
        }
    }
};

struct CaseItemSyntax : public SyntaxNode {

    CaseItemSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct DefaultCaseItemSyntax : public CaseItemSyntax {
    Token defaultKeyword;
    Token colon;
    SyntaxNode* clause;

    DefaultCaseItemSyntax(Token defaultKeyword, Token colon, SyntaxNode* clause) :
        CaseItemSyntax(SyntaxKind::DefaultCaseItem), defaultKeyword(defaultKeyword), colon(colon), clause(clause)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return defaultKeyword;
            case 1: return colon;
            case 2: return clause;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: defaultKeyword = token; break;
            case 1: colon = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct PatternCaseItemSyntax : public CaseItemSyntax {
    PatternSyntax* pattern;
    Token tripleAnd;
    ExpressionSyntax* expr;
    Token colon;
    StatementSyntax* statement;

    PatternCaseItemSyntax(PatternSyntax* pattern, Token tripleAnd, ExpressionSyntax* expr, Token colon, StatementSyntax* statement) :
        CaseItemSyntax(SyntaxKind::PatternCaseItem), pattern(pattern), tripleAnd(tripleAnd), expr(expr), colon(colon), statement(statement)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return pattern;
            case 1: return tripleAnd;
            case 2: return expr;
            case 3: return colon;
            case 4: return statement;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: tripleAnd = token; break;
            case 2: ASSERT(false); break;
            case 3: colon = token; break;
            case 4: ASSERT(false); break;
        }
    }
};

struct StandardCaseItemSyntax : public CaseItemSyntax {
    SeparatedSyntaxList<ExpressionSyntax> expressions;
    Token colon;
    SyntaxNode* clause;

    StandardCaseItemSyntax(SeparatedSyntaxList<ExpressionSyntax> expressions, Token colon, SyntaxNode* clause) :
        CaseItemSyntax(SyntaxKind::StandardCaseItem), expressions(expressions), colon(colon), clause(clause)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &expressions;
            case 1: return colon;
            case 2: return clause;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: colon = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct CaseStatementSyntax : public StatementSyntax {
    Token uniqueOrPriority;
    Token caseKeyword;
    Token openParen;
    ExpressionSyntax* expr;
    Token closeParen;
    Token matchesOrInside;
    SyntaxList<CaseItemSyntax> items;
    Token endcase;

    CaseStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token uniqueOrPriority, Token caseKeyword, Token openParen, ExpressionSyntax* expr, Token closeParen, Token matchesOrInside, SyntaxList<CaseItemSyntax> items, Token endcase) :
        StatementSyntax(SyntaxKind::CaseStatement, label, attributes), uniqueOrPriority(uniqueOrPriority), caseKeyword(caseKeyword), openParen(openParen), expr(expr), closeParen(closeParen), matchesOrInside(matchesOrInside), items(items), endcase(endcase)
    {
        childCount += 8;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return uniqueOrPriority;
            case 3: return caseKeyword;
            case 4: return openParen;
            case 5: return expr;
            case 6: return closeParen;
            case 7: return matchesOrInside;
            case 8: return &items;
            case 9: return endcase;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: uniqueOrPriority = token; break;
            case 3: caseKeyword = token; break;
            case 4: openParen = token; break;
            case 5: ASSERT(false); break;
            case 6: closeParen = token; break;
            case 7: matchesOrInside = token; break;
            case 8: ASSERT(false); break;
            case 9: endcase = token; break;
        }
    }
};

struct ForeverStatementSyntax : public StatementSyntax {
    Token foreverKeyword;
    StatementSyntax* statement;

    ForeverStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token foreverKeyword, StatementSyntax* statement) :
        StatementSyntax(SyntaxKind::ForeverStatement, label, attributes), foreverKeyword(foreverKeyword), statement(statement)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return foreverKeyword;
            case 3: return statement;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: foreverKeyword = token; break;
            case 3: ASSERT(false); break;
        }
    }
};

struct LoopStatementSyntax : public StatementSyntax {
    Token repeatOrWhile;
    Token openParen;
    ExpressionSyntax* expr;
    Token closeParen;
    StatementSyntax* statement;

    LoopStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token repeatOrWhile, Token openParen, ExpressionSyntax* expr, Token closeParen, StatementSyntax* statement) :
        StatementSyntax(SyntaxKind::LoopStatement, label, attributes), repeatOrWhile(repeatOrWhile), openParen(openParen), expr(expr), closeParen(closeParen), statement(statement)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return repeatOrWhile;
            case 3: return openParen;
            case 4: return expr;
            case 5: return closeParen;
            case 6: return statement;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: repeatOrWhile = token; break;
            case 3: openParen = token; break;
            case 4: ASSERT(false); break;
            case 5: closeParen = token; break;
            case 6: ASSERT(false); break;
        }
    }
};

struct DoWhileStatementSyntax : public StatementSyntax {
    Token doKeyword;
    StatementSyntax* statement;
    Token whileKeyword;
    Token openParen;
    ExpressionSyntax* expr;
    Token closeParen;
    Token semi;

    DoWhileStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token doKeyword, StatementSyntax* statement, Token whileKeyword, Token openParen, ExpressionSyntax* expr, Token closeParen, Token semi) :
        StatementSyntax(SyntaxKind::DoWhileStatement, label, attributes), doKeyword(doKeyword), statement(statement), whileKeyword(whileKeyword), openParen(openParen), expr(expr), closeParen(closeParen), semi(semi)
    {
        childCount += 7;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return doKeyword;
            case 3: return statement;
            case 4: return whileKeyword;
            case 5: return openParen;
            case 6: return expr;
            case 7: return closeParen;
            case 8: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: doKeyword = token; break;
            case 3: ASSERT(false); break;
            case 4: whileKeyword = token; break;
            case 5: openParen = token; break;
            case 6: ASSERT(false); break;
            case 7: closeParen = token; break;
            case 8: semi = token; break;
        }
    }
};

struct ForVariableDeclarationSyntax : public SyntaxNode {
    Token varKeyword;
    DataTypeSyntax* type;
    VariableDeclaratorSyntax* declarator;

    ForVariableDeclarationSyntax(Token varKeyword, DataTypeSyntax* type, VariableDeclaratorSyntax* declarator) :
        SyntaxNode(SyntaxKind::ForVariableDeclaration), varKeyword(varKeyword), type(type), declarator(declarator)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return varKeyword;
            case 1: return type;
            case 2: return declarator;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: varKeyword = token; break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
        }
    }
};

struct ForLoopStatementSyntax : public StatementSyntax {
    Token forKeyword;
    Token openParen;
    SeparatedSyntaxList<SyntaxNode> initializers;
    Token semi1;
    ExpressionSyntax* stopExpr;
    Token semi2;
    SeparatedSyntaxList<ExpressionSyntax> steps;
    Token closeParen;
    StatementSyntax* statement;

    ForLoopStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token forKeyword, Token openParen, SeparatedSyntaxList<SyntaxNode> initializers, Token semi1, ExpressionSyntax* stopExpr, Token semi2, SeparatedSyntaxList<ExpressionSyntax> steps, Token closeParen, StatementSyntax* statement) :
        StatementSyntax(SyntaxKind::ForLoopStatement, label, attributes), forKeyword(forKeyword), openParen(openParen), initializers(initializers), semi1(semi1), stopExpr(stopExpr), semi2(semi2), steps(steps), closeParen(closeParen), statement(statement)
    {
        childCount += 9;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return forKeyword;
            case 3: return openParen;
            case 4: return &initializers;
            case 5: return semi1;
            case 6: return stopExpr;
            case 7: return semi2;
            case 8: return &steps;
            case 9: return closeParen;
            case 10: return statement;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: forKeyword = token; break;
            case 3: openParen = token; break;
            case 4: ASSERT(false); break;
            case 5: semi1 = token; break;
            case 6: ASSERT(false); break;
            case 7: semi2 = token; break;
            case 8: ASSERT(false); break;
            case 9: closeParen = token; break;
            case 10: ASSERT(false); break;
        }
    }
};

struct ForeachLoopListSyntax : public SyntaxNode {
    Token openParen;
    NameSyntax* arrayName;
    Token openBracket;
    SeparatedSyntaxList<NameSyntax> loopVariables;
    Token closeBracket;
    Token closeParen;

    ForeachLoopListSyntax(Token openParen, NameSyntax* arrayName, Token openBracket, SeparatedSyntaxList<NameSyntax> loopVariables, Token closeBracket, Token closeParen) :
        SyntaxNode(SyntaxKind::ForeachLoopList), openParen(openParen), arrayName(arrayName), openBracket(openBracket), loopVariables(loopVariables), closeBracket(closeBracket), closeParen(closeParen)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openParen;
            case 1: return arrayName;
            case 2: return openBracket;
            case 3: return &loopVariables;
            case 4: return closeBracket;
            case 5: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openParen = token; break;
            case 1: ASSERT(false); break;
            case 2: openBracket = token; break;
            case 3: ASSERT(false); break;
            case 4: closeBracket = token; break;
            case 5: closeParen = token; break;
        }
    }
};

struct ForeachLoopStatementSyntax : public StatementSyntax {
    Token keyword;
    ForeachLoopListSyntax* loopList;
    StatementSyntax* statement;

    ForeachLoopStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, ForeachLoopListSyntax* loopList, StatementSyntax* statement) :
        StatementSyntax(SyntaxKind::ForeachLoopStatement, label, attributes), keyword(keyword), loopList(loopList), statement(statement)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return keyword;
            case 3: return loopList;
            case 4: return statement;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: keyword = token; break;
            case 3: ASSERT(false); break;
            case 4: ASSERT(false); break;
        }
    }
};

struct ReturnStatementSyntax : public StatementSyntax {
    Token returnKeyword;
    ExpressionSyntax* returnValue;
    Token semi;

    ReturnStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token returnKeyword, ExpressionSyntax* returnValue, Token semi) :
        StatementSyntax(SyntaxKind::ReturnStatement, label, attributes), returnKeyword(returnKeyword), returnValue(returnValue), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return returnKeyword;
            case 3: return returnValue;
            case 4: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: returnKeyword = token; break;
            case 3: ASSERT(false); break;
            case 4: semi = token; break;
        }
    }
};

struct JumpStatementSyntax : public StatementSyntax {
    Token breakOrContinue;
    Token semi;

    JumpStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token breakOrContinue, Token semi) :
        StatementSyntax(SyntaxKind::JumpStatement, label, attributes), breakOrContinue(breakOrContinue), semi(semi)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return breakOrContinue;
            case 3: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: breakOrContinue = token; break;
            case 3: semi = token; break;
        }
    }
};

struct TimingControlStatementSyntax : public StatementSyntax {
    TimingControlSyntax* timingControl;
    StatementSyntax* statement;

    TimingControlStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, TimingControlSyntax* timingControl, StatementSyntax* statement) :
        StatementSyntax(SyntaxKind::TimingControlStatement, label, attributes), timingControl(timingControl), statement(statement)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return timingControl;
            case 3: return statement;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
            case 3: ASSERT(false); break;
        }
        (void)token;
    }
};

struct ExpressionStatementSyntax : public StatementSyntax {
    ExpressionSyntax* expr;
    Token semi;

    ExpressionStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax* expr, Token semi) :
        StatementSyntax(SyntaxKind::ExpressionStatement, label, attributes), expr(expr), semi(semi)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return expr;
            case 3: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
            case 3: semi = token; break;
        }
    }
};

struct ProceduralAssignStatementSyntax : public StatementSyntax {
    Token keyword;
    ExpressionSyntax* lvalue;
    Token equals;
    ExpressionSyntax* value;
    Token semi;

    ProceduralAssignStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, ExpressionSyntax* lvalue, Token equals, ExpressionSyntax* value, Token semi) :
        StatementSyntax(kind, label, attributes), keyword(keyword), lvalue(lvalue), equals(equals), value(value), semi(semi)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return keyword;
            case 3: return lvalue;
            case 4: return equals;
            case 5: return value;
            case 6: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: keyword = token; break;
            case 3: ASSERT(false); break;
            case 4: equals = token; break;
            case 5: ASSERT(false); break;
            case 6: semi = token; break;
        }
    }
};

struct ProceduralDeassignStatementSyntax : public StatementSyntax {
    Token keyword;
    ExpressionSyntax* variable;
    Token semi;

    ProceduralDeassignStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, ExpressionSyntax* variable, Token semi) :
        StatementSyntax(kind, label, attributes), keyword(keyword), variable(variable), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return keyword;
            case 3: return variable;
            case 4: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: keyword = token; break;
            case 3: ASSERT(false); break;
            case 4: semi = token; break;
        }
    }
};

struct DisableStatementSyntax : public StatementSyntax {
    Token disable;
    NameSyntax* name;
    Token semi;

    DisableStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token disable, NameSyntax* name, Token semi) :
        StatementSyntax(SyntaxKind::DisableStatement, label, attributes), disable(disable), name(name), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return disable;
            case 3: return name;
            case 4: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: disable = token; break;
            case 3: ASSERT(false); break;
            case 4: semi = token; break;
        }
    }
};

struct DisableForkStatementSyntax : public StatementSyntax {
    Token disable;
    Token fork;
    Token semi;

    DisableForkStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token disable, Token fork, Token semi) :
        StatementSyntax(SyntaxKind::DisableForkStatement, label, attributes), disable(disable), fork(fork), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return disable;
            case 3: return fork;
            case 4: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: disable = token; break;
            case 3: fork = token; break;
            case 4: semi = token; break;
        }
    }
};

struct NamedBlockClauseSyntax : public SyntaxNode {
    Token colon;
    Token name;

    NamedBlockClauseSyntax(Token colon, Token name) :
        SyntaxNode(SyntaxKind::NamedBlockClause), colon(colon), name(name)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return colon;
            case 1: return name;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: colon = token; break;
            case 1: name = token; break;
        }
    }
};

struct BlockStatementSyntax : public StatementSyntax {
    Token begin;
    NamedBlockClauseSyntax* blockName;
    SyntaxList<SyntaxNode> items;
    Token end;
    NamedBlockClauseSyntax* endBlockName;

    BlockStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token begin, NamedBlockClauseSyntax* blockName, SyntaxList<SyntaxNode> items, Token end, NamedBlockClauseSyntax* endBlockName) :
        StatementSyntax(kind, label, attributes), begin(begin), blockName(blockName), items(items), end(end), endBlockName(endBlockName)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return begin;
            case 3: return blockName;
            case 4: return &items;
            case 5: return end;
            case 6: return endBlockName;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: begin = token; break;
            case 3: ASSERT(false); break;
            case 4: ASSERT(false); break;
            case 5: end = token; break;
            case 6: ASSERT(false); break;
        }
    }
};

struct WaitStatementSyntax : public StatementSyntax {
    Token wait;
    Token openParen;
    ExpressionSyntax* expr;
    Token closeParen;
    StatementSyntax* statement;

    WaitStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token wait, Token openParen, ExpressionSyntax* expr, Token closeParen, StatementSyntax* statement) :
        StatementSyntax(SyntaxKind::WaitStatement, label, attributes), wait(wait), openParen(openParen), expr(expr), closeParen(closeParen), statement(statement)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return wait;
            case 3: return openParen;
            case 4: return expr;
            case 5: return closeParen;
            case 6: return statement;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: wait = token; break;
            case 3: openParen = token; break;
            case 4: ASSERT(false); break;
            case 5: closeParen = token; break;
            case 6: ASSERT(false); break;
        }
    }
};

struct WaitForkStatementSyntax : public StatementSyntax {
    Token wait;
    Token fork;
    Token semi;

    WaitForkStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token wait, Token fork, Token semi) :
        StatementSyntax(SyntaxKind::WaitForkStatement, label, attributes), wait(wait), fork(fork), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return wait;
            case 3: return fork;
            case 4: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: wait = token; break;
            case 3: fork = token; break;
            case 4: semi = token; break;
        }
    }
};

struct WaitOrderStatementSyntax : public StatementSyntax {
    Token wait_order;
    Token openParen;
    SeparatedSyntaxList<NameSyntax> names;
    Token closeParen;
    ActionBlockSyntax* action;

    WaitOrderStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token wait_order, Token openParen, SeparatedSyntaxList<NameSyntax> names, Token closeParen, ActionBlockSyntax* action) :
        StatementSyntax(SyntaxKind::WaitOrderStatement, label, attributes), wait_order(wait_order), openParen(openParen), names(names), closeParen(closeParen), action(action)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return wait_order;
            case 3: return openParen;
            case 4: return &names;
            case 5: return closeParen;
            case 6: return action;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: wait_order = token; break;
            case 3: openParen = token; break;
            case 4: ASSERT(false); break;
            case 5: closeParen = token; break;
            case 6: ASSERT(false); break;
        }
    }
};

struct RandCaseItemSyntax : public SyntaxNode {
    ExpressionSyntax* expr;
    Token colon;
    StatementSyntax* statement;

    RandCaseItemSyntax(ExpressionSyntax* expr, Token colon, StatementSyntax* statement) :
        SyntaxNode(SyntaxKind::RandCaseItem), expr(expr), colon(colon), statement(statement)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return expr;
            case 1: return colon;
            case 2: return statement;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: colon = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct RandCaseStatementSyntax : public StatementSyntax {
    Token randCase;
    SyntaxList<RandCaseItemSyntax> items;
    Token endCase;

    RandCaseStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token randCase, SyntaxList<RandCaseItemSyntax> items, Token endCase) :
        StatementSyntax(SyntaxKind::RandCaseStatement, label, attributes), randCase(randCase), items(items), endCase(endCase)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return randCase;
            case 3: return &items;
            case 4: return endCase;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: randCase = token; break;
            case 3: ASSERT(false); break;
            case 4: endCase = token; break;
        }
    }
};

// ----- MODULES -----

struct PortListSyntax : public SyntaxNode {

    PortListSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct NonAnsiPortSyntax : public SyntaxNode {

    NonAnsiPortSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct ImplicitNonAnsiPortSyntax : public NonAnsiPortSyntax {
    ExpressionSyntax* expr;

    ImplicitNonAnsiPortSyntax(ExpressionSyntax* expr) :
        NonAnsiPortSyntax(SyntaxKind::ImplicitNonAnsiPort), expr(expr)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return expr;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
        }
        (void)token;
    }
};

struct ExplicitNonAnsiPortSyntax : public NonAnsiPortSyntax {
    Token dot;
    Token name;
    Token openParen;
    ExpressionSyntax* expr;
    Token closeParen;

    ExplicitNonAnsiPortSyntax(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) :
        NonAnsiPortSyntax(SyntaxKind::ExplicitNonAnsiPort), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return dot;
            case 1: return name;
            case 2: return openParen;
            case 3: return expr;
            case 4: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: dot = token; break;
            case 1: name = token; break;
            case 2: openParen = token; break;
            case 3: ASSERT(false); break;
            case 4: closeParen = token; break;
        }
    }
};

struct NonAnsiPortListSyntax : public PortListSyntax {
    Token openParen;
    SeparatedSyntaxList<NonAnsiPortSyntax> ports;
    Token closeParen;

    NonAnsiPortListSyntax(Token openParen, SeparatedSyntaxList<NonAnsiPortSyntax> ports, Token closeParen) :
        PortListSyntax(SyntaxKind::NonAnsiPortList), openParen(openParen), ports(ports), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &ports;
            case 2: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openParen = token; break;
            case 1: ASSERT(false); break;
            case 2: closeParen = token; break;
        }
    }
};

struct AnsiPortSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;

    AnsiPortSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes) :
        SyntaxNode(kind), attributes(attributes)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override {
        switch (index) {
            case 0: return &attributes;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override {
        switch (index) {
            case 0: ASSERT(false); break;
        }
        (void)token;
    }
};

struct InterfacePortHeaderSyntax : public PortHeaderSyntax {
    Token nameOrKeyword;
    DotMemberClauseSyntax* modport;

    InterfacePortHeaderSyntax(Token nameOrKeyword, DotMemberClauseSyntax* modport) :
        PortHeaderSyntax(SyntaxKind::InterfacePortHeader), nameOrKeyword(nameOrKeyword), modport(modport)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return nameOrKeyword;
            case 1: return modport;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: nameOrKeyword = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct VariablePortHeaderSyntax : public PortHeaderSyntax {
    Token direction;
    Token varKeyword;
    DataTypeSyntax* type;

    VariablePortHeaderSyntax(Token direction, Token varKeyword, DataTypeSyntax* type) :
        PortHeaderSyntax(SyntaxKind::VariablePortHeader), direction(direction), varKeyword(varKeyword), type(type)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return direction;
            case 1: return varKeyword;
            case 2: return type;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: direction = token; break;
            case 1: varKeyword = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct InterconnectPortHeaderSyntax : public PortHeaderSyntax {
    Token direction;
    Token interconnect;
    DataTypeSyntax* type;

    InterconnectPortHeaderSyntax(Token direction, Token interconnect, DataTypeSyntax* type) :
        PortHeaderSyntax(SyntaxKind::InterconnectPortHeader), direction(direction), interconnect(interconnect), type(type)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return direction;
            case 1: return interconnect;
            case 2: return type;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: direction = token; break;
            case 1: interconnect = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct NetPortHeaderSyntax : public PortHeaderSyntax {
    Token direction;
    Token netType;
    DataTypeSyntax* dataType;

    NetPortHeaderSyntax(Token direction, Token netType, DataTypeSyntax* dataType) :
        PortHeaderSyntax(SyntaxKind::NetPortHeader), direction(direction), netType(netType), dataType(dataType)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return direction;
            case 1: return netType;
            case 2: return dataType;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: direction = token; break;
            case 1: netType = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct ImplicitAnsiPortSyntax : public AnsiPortSyntax {
    PortHeaderSyntax* header;
    VariableDeclaratorSyntax* declarator;

    ImplicitAnsiPortSyntax(SyntaxList<AttributeInstanceSyntax> attributes, PortHeaderSyntax* header, VariableDeclaratorSyntax* declarator) :
        AnsiPortSyntax(SyntaxKind::ImplicitAnsiPort, attributes), header(header), declarator(declarator)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return header;
            case 2: return declarator;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
        }
        (void)token;
    }
};

struct ExplicitAnsiPortSyntax : public AnsiPortSyntax {
    Token direction;
    Token dot;
    Token name;
    Token openParen;
    ExpressionSyntax* expr;
    Token closeParen;

    ExplicitAnsiPortSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token direction, Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) :
        AnsiPortSyntax(SyntaxKind::ExplicitAnsiPort, attributes), direction(direction), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return direction;
            case 2: return dot;
            case 3: return name;
            case 4: return openParen;
            case 5: return expr;
            case 6: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: direction = token; break;
            case 2: dot = token; break;
            case 3: name = token; break;
            case 4: openParen = token; break;
            case 5: ASSERT(false); break;
            case 6: closeParen = token; break;
        }
    }
};

struct AnsiPortListSyntax : public PortListSyntax {
    Token openParen;
    SeparatedSyntaxList<MemberSyntax> ports;
    Token closeParen;

    AnsiPortListSyntax(Token openParen, SeparatedSyntaxList<MemberSyntax> ports, Token closeParen) :
        PortListSyntax(SyntaxKind::AnsiPortList), openParen(openParen), ports(ports), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &ports;
            case 2: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openParen = token; break;
            case 1: ASSERT(false); break;
            case 2: closeParen = token; break;
        }
    }
};

struct WildcardPortListSyntax : public PortListSyntax {
    Token openParen;
    Token dotStar;
    Token closeParen;

    WildcardPortListSyntax(Token openParen, Token dotStar, Token closeParen) :
        PortListSyntax(SyntaxKind::WildcardPortList), openParen(openParen), dotStar(dotStar), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openParen;
            case 1: return dotStar;
            case 2: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openParen = token; break;
            case 1: dotStar = token; break;
            case 2: closeParen = token; break;
        }
    }
};

struct ParameterPortListSyntax : public SyntaxNode {
    Token hash;
    Token openParen;
    SeparatedSyntaxList<ParameterDeclarationSyntax> declarations;
    Token closeParen;

    ParameterPortListSyntax(Token hash, Token openParen, SeparatedSyntaxList<ParameterDeclarationSyntax> declarations, Token closeParen) :
        SyntaxNode(SyntaxKind::ParameterPortList), hash(hash), openParen(openParen), declarations(declarations), closeParen(closeParen)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return hash;
            case 1: return openParen;
            case 2: return &declarations;
            case 3: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: hash = token; break;
            case 1: openParen = token; break;
            case 2: ASSERT(false); break;
            case 3: closeParen = token; break;
        }
    }
};

struct ModuleHeaderSyntax : public SyntaxNode {
    Token moduleKeyword;
    Token lifetime;
    Token name;
    SyntaxList<PackageImportDeclarationSyntax> imports;
    ParameterPortListSyntax* parameters;
    PortListSyntax* ports;
    Token semi;

    ModuleHeaderSyntax(SyntaxKind kind, Token moduleKeyword, Token lifetime, Token name, SyntaxList<PackageImportDeclarationSyntax> imports, ParameterPortListSyntax* parameters, PortListSyntax* ports, Token semi) :
        SyntaxNode(kind), moduleKeyword(moduleKeyword), lifetime(lifetime), name(name), imports(imports), parameters(parameters), ports(ports), semi(semi)
    {
        childCount += 7;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return moduleKeyword;
            case 1: return lifetime;
            case 2: return name;
            case 3: return &imports;
            case 4: return parameters;
            case 5: return ports;
            case 6: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: moduleKeyword = token; break;
            case 1: lifetime = token; break;
            case 2: name = token; break;
            case 3: ASSERT(false); break;
            case 4: ASSERT(false); break;
            case 5: ASSERT(false); break;
            case 6: semi = token; break;
        }
    }
};

struct ModuleDeclarationSyntax : public MemberSyntax {
    ModuleHeaderSyntax* header;
    SyntaxList<MemberSyntax> members;
    Token endmodule;
    NamedBlockClauseSyntax* blockName;

    ModuleDeclarationSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes, ModuleHeaderSyntax* header, SyntaxList<MemberSyntax> members, Token endmodule, NamedBlockClauseSyntax* blockName) :
        MemberSyntax(kind, attributes), header(header), members(members), endmodule(endmodule), blockName(blockName)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return header;
            case 2: return &members;
            case 3: return endmodule;
            case 4: return blockName;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
            case 3: endmodule = token; break;
            case 4: ASSERT(false); break;
        }
    }
};

struct ExternModuleSyntax : public SyntaxNode {
    Token externKeyword;
    ModuleHeaderSyntax* header;

    ExternModuleSyntax(Token externKeyword, ModuleHeaderSyntax* header) :
        SyntaxNode(SyntaxKind::ExternModule), externKeyword(externKeyword), header(header)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return externKeyword;
            case 1: return header;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: externKeyword = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

// ----- MEMBERS -----

struct EmptyMemberSyntax : public MemberSyntax {
    TokenList qualifiers;
    Token semi;

    EmptyMemberSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, Token semi) :
        MemberSyntax(SyntaxKind::EmptyMember, attributes), qualifiers(qualifiers), semi(semi)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &qualifiers;
            case 2: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: semi = token; break;
        }
    }
};

struct ProceduralBlockSyntax : public MemberSyntax {
    Token keyword;
    StatementSyntax* statement;

    ProceduralBlockSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, StatementSyntax* statement) :
        MemberSyntax(kind, attributes), keyword(keyword), statement(statement)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return statement;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: keyword = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct GenerateRegionSyntax : public MemberSyntax {
    Token keyword;
    SyntaxList<MemberSyntax> members;
    Token endgenerate;

    GenerateRegionSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, SyntaxList<MemberSyntax> members, Token endgenerate) :
        MemberSyntax(SyntaxKind::GenerateRegion, attributes), keyword(keyword), members(members), endgenerate(endgenerate)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return &members;
            case 3: return endgenerate;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: keyword = token; break;
            case 2: ASSERT(false); break;
            case 3: endgenerate = token; break;
        }
    }
};

struct LoopGenerateSyntax : public MemberSyntax {
    Token keyword;
    Token openParen;
    Token genvar;
    Token identifier;
    Token equals;
    ExpressionSyntax* initialExpr;
    Token semi1;
    ExpressionSyntax* stopExpr;
    Token semi2;
    ExpressionSyntax* iterationExpr;
    Token closeParen;
    MemberSyntax* block;

    LoopGenerateSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token openParen, Token genvar, Token identifier, Token equals, ExpressionSyntax* initialExpr, Token semi1, ExpressionSyntax* stopExpr, Token semi2, ExpressionSyntax* iterationExpr, Token closeParen, MemberSyntax* block) :
        MemberSyntax(SyntaxKind::LoopGenerate, attributes), keyword(keyword), openParen(openParen), genvar(genvar), identifier(identifier), equals(equals), initialExpr(initialExpr), semi1(semi1), stopExpr(stopExpr), semi2(semi2), iterationExpr(iterationExpr), closeParen(closeParen), block(block)
    {
        childCount += 12;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return openParen;
            case 3: return genvar;
            case 4: return identifier;
            case 5: return equals;
            case 6: return initialExpr;
            case 7: return semi1;
            case 8: return stopExpr;
            case 9: return semi2;
            case 10: return iterationExpr;
            case 11: return closeParen;
            case 12: return block;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: keyword = token; break;
            case 2: openParen = token; break;
            case 3: genvar = token; break;
            case 4: identifier = token; break;
            case 5: equals = token; break;
            case 6: ASSERT(false); break;
            case 7: semi1 = token; break;
            case 8: ASSERT(false); break;
            case 9: semi2 = token; break;
            case 10: ASSERT(false); break;
            case 11: closeParen = token; break;
            case 12: ASSERT(false); break;
        }
    }
};

struct IfGenerateSyntax : public MemberSyntax {
    Token keyword;
    Token openParen;
    ExpressionSyntax* condition;
    Token closeParen;
    MemberSyntax* block;
    ElseClauseSyntax* elseClause;

    IfGenerateSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token openParen, ExpressionSyntax* condition, Token closeParen, MemberSyntax* block, ElseClauseSyntax* elseClause) :
        MemberSyntax(SyntaxKind::IfGenerate, attributes), keyword(keyword), openParen(openParen), condition(condition), closeParen(closeParen), block(block), elseClause(elseClause)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return openParen;
            case 3: return condition;
            case 4: return closeParen;
            case 5: return block;
            case 6: return elseClause;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: keyword = token; break;
            case 2: openParen = token; break;
            case 3: ASSERT(false); break;
            case 4: closeParen = token; break;
            case 5: ASSERT(false); break;
            case 6: ASSERT(false); break;
        }
    }
};

struct CaseGenerateSyntax : public MemberSyntax {
    Token keyword;
    Token openParen;
    ExpressionSyntax* condition;
    Token closeParen;
    SyntaxList<CaseItemSyntax> items;
    Token endCase;

    CaseGenerateSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token openParen, ExpressionSyntax* condition, Token closeParen, SyntaxList<CaseItemSyntax> items, Token endCase) :
        MemberSyntax(SyntaxKind::CaseGenerate, attributes), keyword(keyword), openParen(openParen), condition(condition), closeParen(closeParen), items(items), endCase(endCase)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return openParen;
            case 3: return condition;
            case 4: return closeParen;
            case 5: return &items;
            case 6: return endCase;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: keyword = token; break;
            case 2: openParen = token; break;
            case 3: ASSERT(false); break;
            case 4: closeParen = token; break;
            case 5: ASSERT(false); break;
            case 6: endCase = token; break;
        }
    }
};

struct GenerateBlockSyntax : public MemberSyntax {
    NamedLabelSyntax* label;
    Token begin;
    NamedBlockClauseSyntax* beginName;
    SyntaxList<MemberSyntax> members;
    Token end;
    NamedBlockClauseSyntax* endName;

    GenerateBlockSyntax(SyntaxList<AttributeInstanceSyntax> attributes, NamedLabelSyntax* label, Token begin, NamedBlockClauseSyntax* beginName, SyntaxList<MemberSyntax> members, Token end, NamedBlockClauseSyntax* endName) :
        MemberSyntax(SyntaxKind::GenerateBlock, attributes), label(label), begin(begin), beginName(beginName), members(members), end(end), endName(endName)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return label;
            case 2: return begin;
            case 3: return beginName;
            case 4: return &members;
            case 5: return end;
            case 6: return endName;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: begin = token; break;
            case 3: ASSERT(false); break;
            case 4: ASSERT(false); break;
            case 5: end = token; break;
            case 6: ASSERT(false); break;
        }
    }
};

struct DividerClauseSyntax : public SyntaxNode {
    Token divide;
    Token value;

    DividerClauseSyntax(Token divide, Token value) :
        SyntaxNode(SyntaxKind::DividerClause), divide(divide), value(value)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return divide;
            case 1: return value;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: divide = token; break;
            case 1: value = token; break;
        }
    }
};

struct TimeUnitsDeclarationSyntax : public MemberSyntax {
    Token keyword;
    Token time;
    DividerClauseSyntax* divider;
    Token semi;

    TimeUnitsDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token time, DividerClauseSyntax* divider, Token semi) :
        MemberSyntax(SyntaxKind::TimeUnitsDeclaration, attributes), keyword(keyword), time(time), divider(divider), semi(semi)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return time;
            case 3: return divider;
            case 4: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: keyword = token; break;
            case 2: time = token; break;
            case 3: ASSERT(false); break;
            case 4: semi = token; break;
        }
    }
};

struct PortConnectionSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;

    PortConnectionSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes) :
        SyntaxNode(kind), attributes(attributes)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override {
        switch (index) {
            case 0: return &attributes;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override {
        switch (index) {
            case 0: ASSERT(false); break;
        }
        (void)token;
    }
};

struct OrderedPortConnectionSyntax : public PortConnectionSyntax {
    ExpressionSyntax* expr;

    OrderedPortConnectionSyntax(SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax* expr) :
        PortConnectionSyntax(SyntaxKind::OrderedPortConnection, attributes), expr(expr)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return expr;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
        }
        (void)token;
    }
};

struct NamedPortConnectionSyntax : public PortConnectionSyntax {
    Token dot;
    Token name;
    ParenthesizedExpressionSyntax* connection;

    NamedPortConnectionSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token dot, Token name, ParenthesizedExpressionSyntax* connection) :
        PortConnectionSyntax(SyntaxKind::NamedPortConnection, attributes), dot(dot), name(name), connection(connection)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return dot;
            case 2: return name;
            case 3: return connection;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: dot = token; break;
            case 2: name = token; break;
            case 3: ASSERT(false); break;
        }
    }
};

struct WildcardPortConnectionSyntax : public PortConnectionSyntax {
    Token dotStar;

    WildcardPortConnectionSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token dotStar) :
        PortConnectionSyntax(SyntaxKind::WildcardPortConnection, attributes), dotStar(dotStar)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return dotStar;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: dotStar = token; break;
        }
    }
};

struct HierarchicalInstanceSyntax : public SyntaxNode {
    Token name;
    SyntaxList<VariableDimensionSyntax> dimensions;
    Token openParen;
    SeparatedSyntaxList<PortConnectionSyntax> connections;
    Token closeParen;

    HierarchicalInstanceSyntax(Token name, SyntaxList<VariableDimensionSyntax> dimensions, Token openParen, SeparatedSyntaxList<PortConnectionSyntax> connections, Token closeParen) :
        SyntaxNode(SyntaxKind::HierarchicalInstance), name(name), dimensions(dimensions), openParen(openParen), connections(connections), closeParen(closeParen)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return name;
            case 1: return &dimensions;
            case 2: return openParen;
            case 3: return &connections;
            case 4: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: name = token; break;
            case 1: ASSERT(false); break;
            case 2: openParen = token; break;
            case 3: ASSERT(false); break;
            case 4: closeParen = token; break;
        }
    }
};

struct HierarchyInstantiationSyntax : public MemberSyntax {
    Token type;
    ParameterValueAssignmentSyntax* parameters;
    SeparatedSyntaxList<HierarchicalInstanceSyntax> instances;
    Token semi;

    HierarchyInstantiationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token type, ParameterValueAssignmentSyntax* parameters, SeparatedSyntaxList<HierarchicalInstanceSyntax> instances, Token semi) :
        MemberSyntax(SyntaxKind::HierarchyInstantiation, attributes), type(type), parameters(parameters), instances(instances), semi(semi)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return type;
            case 2: return parameters;
            case 3: return &instances;
            case 4: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: type = token; break;
            case 2: ASSERT(false); break;
            case 3: ASSERT(false); break;
            case 4: semi = token; break;
        }
    }
};

struct FunctionPortSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;
    Token constKeyword;
    Token direction;
    Token varKeyword;
    DataTypeSyntax* dataType;
    VariableDeclaratorSyntax* declarator;

    FunctionPortSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token constKeyword, Token direction, Token varKeyword, DataTypeSyntax* dataType, VariableDeclaratorSyntax* declarator) :
        SyntaxNode(SyntaxKind::FunctionPort), attributes(attributes), constKeyword(constKeyword), direction(direction), varKeyword(varKeyword), dataType(dataType), declarator(declarator)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return constKeyword;
            case 2: return direction;
            case 3: return varKeyword;
            case 4: return dataType;
            case 5: return declarator;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: constKeyword = token; break;
            case 2: direction = token; break;
            case 3: varKeyword = token; break;
            case 4: ASSERT(false); break;
            case 5: ASSERT(false); break;
        }
    }
};

struct FunctionPortListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<FunctionPortSyntax> ports;
    Token closeParen;

    FunctionPortListSyntax(Token openParen, SeparatedSyntaxList<FunctionPortSyntax> ports, Token closeParen) :
        SyntaxNode(SyntaxKind::FunctionPortList), openParen(openParen), ports(ports), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &ports;
            case 2: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openParen = token; break;
            case 1: ASSERT(false); break;
            case 2: closeParen = token; break;
        }
    }
};

struct FunctionPrototypeSyntax : public SyntaxNode {
    Token keyword;
    Token lifetime;
    DataTypeSyntax* returnType;
    NameSyntax* name;
    FunctionPortListSyntax* portList;
    Token semi;

    FunctionPrototypeSyntax(Token keyword, Token lifetime, DataTypeSyntax* returnType, NameSyntax* name, FunctionPortListSyntax* portList, Token semi) :
        SyntaxNode(SyntaxKind::FunctionPrototype), keyword(keyword), lifetime(lifetime), returnType(returnType), name(name), portList(portList), semi(semi)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return keyword;
            case 1: return lifetime;
            case 2: return returnType;
            case 3: return name;
            case 4: return portList;
            case 5: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: keyword = token; break;
            case 1: lifetime = token; break;
            case 2: ASSERT(false); break;
            case 3: ASSERT(false); break;
            case 4: ASSERT(false); break;
            case 5: semi = token; break;
        }
    }
};

struct FunctionDeclarationSyntax : public MemberSyntax {
    FunctionPrototypeSyntax* prototype;
    SyntaxList<SyntaxNode> items;
    Token end;
    NamedBlockClauseSyntax* endBlockName;

    FunctionDeclarationSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes, FunctionPrototypeSyntax* prototype, SyntaxList<SyntaxNode> items, Token end, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(kind, attributes), prototype(prototype), items(items), end(end), endBlockName(endBlockName)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return prototype;
            case 2: return &items;
            case 3: return end;
            case 4: return endBlockName;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
            case 3: end = token; break;
            case 4: ASSERT(false); break;
        }
    }
};

struct ExtendsClauseSyntax : public SyntaxNode {
    Token keyword;
    NameSyntax* baseName;
    ArgumentListSyntax* arguments;

    ExtendsClauseSyntax(Token keyword, NameSyntax* baseName, ArgumentListSyntax* arguments) :
        SyntaxNode(SyntaxKind::ExtendsClause), keyword(keyword), baseName(baseName), arguments(arguments)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return keyword;
            case 1: return baseName;
            case 2: return arguments;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: keyword = token; break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
        }
    }
};

struct ImplementsClauseSyntax : public SyntaxNode {
    Token keyword;
    SeparatedSyntaxList<NameSyntax> interfaces;

    ImplementsClauseSyntax(Token keyword, SeparatedSyntaxList<NameSyntax> interfaces) :
        SyntaxNode(SyntaxKind::ImplementsClause), keyword(keyword), interfaces(interfaces)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return keyword;
            case 1: return &interfaces;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: keyword = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct ClassDeclarationSyntax : public MemberSyntax {
    Token virtualOrInterface;
    Token classKeyword;
    Token lifetime;
    Token name;
    ParameterPortListSyntax* parameters;
    ExtendsClauseSyntax* extendsClause;
    ImplementsClauseSyntax* implementsClause;
    Token semi;
    SyntaxList<MemberSyntax> items;
    Token endClass;
    NamedBlockClauseSyntax* endBlockName;

    ClassDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token virtualOrInterface, Token classKeyword, Token lifetime, Token name, ParameterPortListSyntax* parameters, ExtendsClauseSyntax* extendsClause, ImplementsClauseSyntax* implementsClause, Token semi, SyntaxList<MemberSyntax> items, Token endClass, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(SyntaxKind::ClassDeclaration, attributes), virtualOrInterface(virtualOrInterface), classKeyword(classKeyword), lifetime(lifetime), name(name), parameters(parameters), extendsClause(extendsClause), implementsClause(implementsClause), semi(semi), items(items), endClass(endClass), endBlockName(endBlockName)
    {
        childCount += 11;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return virtualOrInterface;
            case 2: return classKeyword;
            case 3: return lifetime;
            case 4: return name;
            case 5: return parameters;
            case 6: return extendsClause;
            case 7: return implementsClause;
            case 8: return semi;
            case 9: return &items;
            case 10: return endClass;
            case 11: return endBlockName;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: virtualOrInterface = token; break;
            case 2: classKeyword = token; break;
            case 3: lifetime = token; break;
            case 4: name = token; break;
            case 5: ASSERT(false); break;
            case 6: ASSERT(false); break;
            case 7: ASSERT(false); break;
            case 8: semi = token; break;
            case 9: ASSERT(false); break;
            case 10: endClass = token; break;
            case 11: ASSERT(false); break;
        }
    }
};

struct ClassPropertyDeclarationSyntax : public MemberSyntax {
    TokenList qualifiers;
    MemberSyntax* declaration;

    ClassPropertyDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, MemberSyntax* declaration) :
        MemberSyntax(SyntaxKind::ClassPropertyDeclaration, attributes), qualifiers(qualifiers), declaration(declaration)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &qualifiers;
            case 2: return declaration;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
        }
        (void)token;
    }
};

struct ClassMethodDeclarationSyntax : public MemberSyntax {
    TokenList qualifiers;
    FunctionDeclarationSyntax* declaration;

    ClassMethodDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, FunctionDeclarationSyntax* declaration) :
        MemberSyntax(SyntaxKind::ClassMethodDeclaration, attributes), qualifiers(qualifiers), declaration(declaration)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &qualifiers;
            case 2: return declaration;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
        }
        (void)token;
    }
};

struct ClassMethodPrototypeSyntax : public MemberSyntax {
    TokenList qualifiers;
    FunctionPrototypeSyntax* prototype;

    ClassMethodPrototypeSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, FunctionPrototypeSyntax* prototype) :
        MemberSyntax(SyntaxKind::ClassMethodPrototype, attributes), qualifiers(qualifiers), prototype(prototype)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &qualifiers;
            case 2: return prototype;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
        }
        (void)token;
    }
};

struct ContinuousAssignSyntax : public MemberSyntax {
    Token assign;
    SeparatedSyntaxList<ExpressionSyntax> assignments;
    Token semi;

    ContinuousAssignSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token assign, SeparatedSyntaxList<ExpressionSyntax> assignments, Token semi) :
        MemberSyntax(SyntaxKind::ContinuousAssign, attributes), assign(assign), assignments(assignments), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return assign;
            case 2: return &assignments;
            case 3: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: assign = token; break;
            case 2: ASSERT(false); break;
            case 3: semi = token; break;
        }
    }
};

struct DefParamAssignmentSyntax : public SyntaxNode {
    NameSyntax* name;
    EqualsValueClauseSyntax* setter;

    DefParamAssignmentSyntax(NameSyntax* name, EqualsValueClauseSyntax* setter) :
        SyntaxNode(SyntaxKind::DefParamAssignment), name(name), setter(setter)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return name;
            case 1: return setter;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
        }
        (void)token;
    }
};

struct DefParamSyntax : public MemberSyntax {
    Token defparam;
    SeparatedSyntaxList<DefParamAssignmentSyntax> assignments;
    Token semi;

    DefParamSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token defparam, SeparatedSyntaxList<DefParamAssignmentSyntax> assignments, Token semi) :
        MemberSyntax(SyntaxKind::DefParam, attributes), defparam(defparam), assignments(assignments), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return defparam;
            case 2: return &assignments;
            case 3: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: defparam = token; break;
            case 2: ASSERT(false); break;
            case 3: semi = token; break;
        }
    }
};

struct ModportItemSyntax : public SyntaxNode {
    Token name;
    AnsiPortListSyntax* ports;

    ModportItemSyntax(Token name, AnsiPortListSyntax* ports) :
        SyntaxNode(SyntaxKind::ModportItem), name(name), ports(ports)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return name;
            case 1: return ports;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: name = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct ModportDeclarationSyntax : public MemberSyntax {
    Token keyword;
    SeparatedSyntaxList<ModportItemSyntax> items;
    Token semi;

    ModportDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, SeparatedSyntaxList<ModportItemSyntax> items, Token semi) :
        MemberSyntax(SyntaxKind::ModportDeclaration, attributes), keyword(keyword), items(items), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return &items;
            case 3: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: keyword = token; break;
            case 2: ASSERT(false); break;
            case 3: semi = token; break;
        }
    }
};

// ----- CONSTRAINTS -----

struct ConstraintItemSyntax : public SyntaxNode {

    ConstraintItemSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct DistWeightSyntax : public SyntaxNode {
    Token op;
    ExpressionSyntax* expr;

    DistWeightSyntax(Token op, ExpressionSyntax* expr) :
        SyntaxNode(SyntaxKind::DistWeight), op(op), expr(expr)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return op;
            case 1: return expr;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: op = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct DistItemSyntax : public SyntaxNode {
    ExpressionSyntax* range;
    DistWeightSyntax* weight;

    DistItemSyntax(ExpressionSyntax* range, DistWeightSyntax* weight) :
        SyntaxNode(SyntaxKind::DistItem), range(range), weight(weight)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return range;
            case 1: return weight;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
        }
        (void)token;
    }
};

struct DistConstraintListSyntax : public SyntaxNode {
    Token dist;
    Token openBrace;
    SeparatedSyntaxList<DistItemSyntax> items;
    Token closeBrace;

    DistConstraintListSyntax(Token dist, Token openBrace, SeparatedSyntaxList<DistItemSyntax> items, Token closeBrace) :
        SyntaxNode(SyntaxKind::DistConstraintList), dist(dist), openBrace(openBrace), items(items), closeBrace(closeBrace)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return dist;
            case 1: return openBrace;
            case 2: return &items;
            case 3: return closeBrace;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: dist = token; break;
            case 1: openBrace = token; break;
            case 2: ASSERT(false); break;
            case 3: closeBrace = token; break;
        }
    }
};

struct ExpressionOrDistSyntax : public ExpressionSyntax {
    ExpressionSyntax* expr;
    DistConstraintListSyntax* distribution;

    ExpressionOrDistSyntax(ExpressionSyntax* expr, DistConstraintListSyntax* distribution) :
        ExpressionSyntax(SyntaxKind::ExpressionOrDist), expr(expr), distribution(distribution)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return expr;
            case 1: return distribution;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
        }
        (void)token;
    }
};

struct ExpressionConstraintSyntax : public ConstraintItemSyntax {
    Token soft;
    ExpressionSyntax* expr;
    Token semi;

    ExpressionConstraintSyntax(Token soft, ExpressionSyntax* expr, Token semi) :
        ConstraintItemSyntax(SyntaxKind::ExpressionConstraint), soft(soft), expr(expr), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return soft;
            case 1: return expr;
            case 2: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: soft = token; break;
            case 1: ASSERT(false); break;
            case 2: semi = token; break;
        }
    }
};

struct UniquenessConstraintSyntax : public ConstraintItemSyntax {
    Token unique;
    OpenRangeListSyntax* ranges;
    Token semi;

    UniquenessConstraintSyntax(Token unique, OpenRangeListSyntax* ranges, Token semi) :
        ConstraintItemSyntax(SyntaxKind::UniquenessConstraint), unique(unique), ranges(ranges), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return unique;
            case 1: return ranges;
            case 2: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: unique = token; break;
            case 1: ASSERT(false); break;
            case 2: semi = token; break;
        }
    }
};

struct ImplicationConstraintSyntax : public ConstraintItemSyntax {
    ExpressionSyntax* left;
    Token arrow;
    ConstraintItemSyntax* constraints;

    ImplicationConstraintSyntax(ExpressionSyntax* left, Token arrow, ConstraintItemSyntax* constraints) :
        ConstraintItemSyntax(SyntaxKind::ImplicationConstraint), left(left), arrow(arrow), constraints(constraints)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return left;
            case 1: return arrow;
            case 2: return constraints;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: arrow = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct ElseConstraintClauseSyntax : public SyntaxNode {
    Token elseKeyword;
    ConstraintItemSyntax* constraints;

    ElseConstraintClauseSyntax(Token elseKeyword, ConstraintItemSyntax* constraints) :
        SyntaxNode(SyntaxKind::ElseConstraintClause), elseKeyword(elseKeyword), constraints(constraints)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return elseKeyword;
            case 1: return constraints;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: elseKeyword = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct ConditionalConstraintSyntax : public ConstraintItemSyntax {
    Token ifKeyword;
    Token openParen;
    ExpressionSyntax* condition;
    Token closeParen;
    ConstraintItemSyntax* constraints;
    ElseConstraintClauseSyntax* elseClause;

    ConditionalConstraintSyntax(Token ifKeyword, Token openParen, ExpressionSyntax* condition, Token closeParen, ConstraintItemSyntax* constraints, ElseConstraintClauseSyntax* elseClause) :
        ConstraintItemSyntax(SyntaxKind::ConditionalConstraint), ifKeyword(ifKeyword), openParen(openParen), condition(condition), closeParen(closeParen), constraints(constraints), elseClause(elseClause)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return ifKeyword;
            case 1: return openParen;
            case 2: return condition;
            case 3: return closeParen;
            case 4: return constraints;
            case 5: return elseClause;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ifKeyword = token; break;
            case 1: openParen = token; break;
            case 2: ASSERT(false); break;
            case 3: closeParen = token; break;
            case 4: ASSERT(false); break;
            case 5: ASSERT(false); break;
        }
    }
};

struct LoopConstraintSyntax : public ConstraintItemSyntax {
    Token foreachKeyword;
    ForeachLoopListSyntax* loopList;
    ConstraintItemSyntax* constraints;

    LoopConstraintSyntax(Token foreachKeyword, ForeachLoopListSyntax* loopList, ConstraintItemSyntax* constraints) :
        ConstraintItemSyntax(SyntaxKind::LoopConstraint), foreachKeyword(foreachKeyword), loopList(loopList), constraints(constraints)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return foreachKeyword;
            case 1: return loopList;
            case 2: return constraints;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: foreachKeyword = token; break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
        }
    }
};

struct DisableConstraintSyntax : public ConstraintItemSyntax {
    Token disable;
    Token soft;
    NameSyntax* name;
    Token semi;

    DisableConstraintSyntax(Token disable, Token soft, NameSyntax* name, Token semi) :
        ConstraintItemSyntax(SyntaxKind::DisableConstraint), disable(disable), soft(soft), name(name), semi(semi)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return disable;
            case 1: return soft;
            case 2: return name;
            case 3: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: disable = token; break;
            case 1: soft = token; break;
            case 2: ASSERT(false); break;
            case 3: semi = token; break;
        }
    }
};

struct ConstraintBlockSyntax : public ConstraintItemSyntax {
    Token openBrace;
    SyntaxList<ConstraintItemSyntax> items;
    Token closeBrace;

    ConstraintBlockSyntax(Token openBrace, SyntaxList<ConstraintItemSyntax> items, Token closeBrace) :
        ConstraintItemSyntax(SyntaxKind::ConstraintBlock), openBrace(openBrace), items(items), closeBrace(closeBrace)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return &items;
            case 2: return closeBrace;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openBrace = token; break;
            case 1: ASSERT(false); break;
            case 2: closeBrace = token; break;
        }
    }
};

struct ConstraintPrototypeSyntax : public MemberSyntax {
    TokenList qualifiers;
    Token keyword;
    Token name;
    Token semi;

    ConstraintPrototypeSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, Token keyword, Token name, Token semi) :
        MemberSyntax(SyntaxKind::ConstraintPrototype, attributes), qualifiers(qualifiers), keyword(keyword), name(name), semi(semi)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &qualifiers;
            case 2: return keyword;
            case 3: return name;
            case 4: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: keyword = token; break;
            case 3: name = token; break;
            case 4: semi = token; break;
        }
    }
};

struct ConstraintDeclarationSyntax : public MemberSyntax {
    TokenList qualifiers;
    Token keyword;
    Token name;
    ConstraintBlockSyntax* block;

    ConstraintDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, Token keyword, Token name, ConstraintBlockSyntax* block) :
        MemberSyntax(SyntaxKind::ConstraintDeclaration, attributes), qualifiers(qualifiers), keyword(keyword), name(name), block(block)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &qualifiers;
            case 2: return keyword;
            case 3: return name;
            case 4: return block;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: keyword = token; break;
            case 3: name = token; break;
            case 4: ASSERT(false); break;
        }
    }
};

struct WithClauseSyntax : public ExpressionSyntax {
    Token with;
    Token openParen;
    ExpressionSyntax* expr;
    Token closeParen;

    WithClauseSyntax(Token with, Token openParen, ExpressionSyntax* expr, Token closeParen) :
        ExpressionSyntax(SyntaxKind::WithClause), with(with), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return with;
            case 1: return openParen;
            case 2: return expr;
            case 3: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: with = token; break;
            case 1: openParen = token; break;
            case 2: ASSERT(false); break;
            case 3: closeParen = token; break;
        }
    }
};

struct IdentifierListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<IdentifierNameSyntax> identifiers;
    Token closeParen;

    IdentifierListSyntax(Token openParen, SeparatedSyntaxList<IdentifierNameSyntax> identifiers, Token closeParen) :
        SyntaxNode(SyntaxKind::IdentifierList), openParen(openParen), identifiers(identifiers), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &identifiers;
            case 2: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openParen = token; break;
            case 1: ASSERT(false); break;
            case 2: closeParen = token; break;
        }
    }
};

struct RandomizeMethodWithClauseSyntax : public ExpressionSyntax {
    Token with;
    IdentifierListSyntax* names;
    ConstraintBlockSyntax* constraints;

    RandomizeMethodWithClauseSyntax(Token with, IdentifierListSyntax* names, ConstraintBlockSyntax* constraints) :
        ExpressionSyntax(SyntaxKind::RandomizeMethodWithClause), with(with), names(names), constraints(constraints)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return with;
            case 1: return names;
            case 2: return constraints;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: with = token; break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
        }
    }
};

// ----- COVER GROUPS -----

struct WithFunctionSampleSyntax : public SyntaxNode {
    Token with;
    Token function;
    Token sample;
    AnsiPortListSyntax* portList;

    WithFunctionSampleSyntax(Token with, Token function, Token sample, AnsiPortListSyntax* portList) :
        SyntaxNode(SyntaxKind::WithFunctionSample), with(with), function(function), sample(sample), portList(portList)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return with;
            case 1: return function;
            case 2: return sample;
            case 3: return portList;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: with = token; break;
            case 1: function = token; break;
            case 2: sample = token; break;
            case 3: ASSERT(false); break;
        }
    }
};

struct BlockEventExpressionSyntax : public SyntaxNode {

    BlockEventExpressionSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct BinaryBlockEventExpressionSyntax : public BlockEventExpressionSyntax {
    BlockEventExpressionSyntax* left;
    Token orKeyword;
    BlockEventExpressionSyntax* right;

    BinaryBlockEventExpressionSyntax(BlockEventExpressionSyntax* left, Token orKeyword, BlockEventExpressionSyntax* right) :
        BlockEventExpressionSyntax(SyntaxKind::BinaryBlockEventExpression), left(left), orKeyword(orKeyword), right(right)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return left;
            case 1: return orKeyword;
            case 2: return right;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: orKeyword = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct PrimaryBlockEventExpressionSyntax : public BlockEventExpressionSyntax {
    Token keyword;
    NameSyntax* name;

    PrimaryBlockEventExpressionSyntax(Token keyword, NameSyntax* name) :
        BlockEventExpressionSyntax(SyntaxKind::PrimaryBlockEventExpression), keyword(keyword), name(name)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return keyword;
            case 1: return name;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: keyword = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct BlockCoverageEventSyntax : public SyntaxNode {
    Token atat;
    Token openParen;
    BlockEventExpressionSyntax* expr;
    Token closeParen;

    BlockCoverageEventSyntax(Token atat, Token openParen, BlockEventExpressionSyntax* expr, Token closeParen) :
        SyntaxNode(SyntaxKind::BlockCoverageEvent), atat(atat), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return atat;
            case 1: return openParen;
            case 2: return expr;
            case 3: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: atat = token; break;
            case 1: openParen = token; break;
            case 2: ASSERT(false); break;
            case 3: closeParen = token; break;
        }
    }
};

struct CovergroupDeclarationSyntax : public MemberSyntax {
    Token covergroup;
    Token name;
    AnsiPortListSyntax* portList;
    SyntaxNode* event;
    Token semi;
    SyntaxList<MemberSyntax> members;
    Token endgroup;
    NamedBlockClauseSyntax* endBlockName;

    CovergroupDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token covergroup, Token name, AnsiPortListSyntax* portList, SyntaxNode* event, Token semi, SyntaxList<MemberSyntax> members, Token endgroup, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(SyntaxKind::CovergroupDeclaration, attributes), covergroup(covergroup), name(name), portList(portList), event(event), semi(semi), members(members), endgroup(endgroup), endBlockName(endBlockName)
    {
        childCount += 8;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return covergroup;
            case 2: return name;
            case 3: return portList;
            case 4: return event;
            case 5: return semi;
            case 6: return &members;
            case 7: return endgroup;
            case 8: return endBlockName;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: covergroup = token; break;
            case 2: name = token; break;
            case 3: ASSERT(false); break;
            case 4: ASSERT(false); break;
            case 5: semi = token; break;
            case 6: ASSERT(false); break;
            case 7: endgroup = token; break;
            case 8: ASSERT(false); break;
        }
    }
};

struct CoverageOptionSyntax : public MemberSyntax {
    Token option;
    Token dot;
    Token name;
    Token equals;
    ExpressionSyntax* expr;
    Token semi;

    CoverageOptionSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token option, Token dot, Token name, Token equals, ExpressionSyntax* expr, Token semi) :
        MemberSyntax(SyntaxKind::CoverageOption, attributes), option(option), dot(dot), name(name), equals(equals), expr(expr), semi(semi)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return option;
            case 2: return dot;
            case 3: return name;
            case 4: return equals;
            case 5: return expr;
            case 6: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: option = token; break;
            case 2: dot = token; break;
            case 3: name = token; break;
            case 4: equals = token; break;
            case 5: ASSERT(false); break;
            case 6: semi = token; break;
        }
    }
};

struct CoverpointSyntax : public MemberSyntax {
    DataTypeSyntax* type;
    NamedLabelSyntax* label;
    Token coverpoint;
    ExpressionSyntax* expr;
    Token openBrace;
    SyntaxList<MemberSyntax> members;
    Token closeBrace;
    Token emptySemi;

    CoverpointSyntax(SyntaxList<AttributeInstanceSyntax> attributes, DataTypeSyntax* type, NamedLabelSyntax* label, Token coverpoint, ExpressionSyntax* expr, Token openBrace, SyntaxList<MemberSyntax> members, Token closeBrace, Token emptySemi) :
        MemberSyntax(SyntaxKind::Coverpoint, attributes), type(type), label(label), coverpoint(coverpoint), expr(expr), openBrace(openBrace), members(members), closeBrace(closeBrace), emptySemi(emptySemi)
    {
        childCount += 8;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return type;
            case 2: return label;
            case 3: return coverpoint;
            case 4: return expr;
            case 5: return openBrace;
            case 6: return &members;
            case 7: return closeBrace;
            case 8: return emptySemi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
            case 2: ASSERT(false); break;
            case 3: coverpoint = token; break;
            case 4: ASSERT(false); break;
            case 5: openBrace = token; break;
            case 6: ASSERT(false); break;
            case 7: closeBrace = token; break;
            case 8: emptySemi = token; break;
        }
    }
};

struct CoverageBinInitializerSyntax : public SyntaxNode {

    CoverageBinInitializerSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct DefaultCoverageBinInitializerSyntax : public CoverageBinInitializerSyntax {
    Token defaultKeyword;
    Token sequenceKeyword;

    DefaultCoverageBinInitializerSyntax(Token defaultKeyword, Token sequenceKeyword) :
        CoverageBinInitializerSyntax(SyntaxKind::DefaultCoverageBinInitializer), defaultKeyword(defaultKeyword), sequenceKeyword(sequenceKeyword)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return defaultKeyword;
            case 1: return sequenceKeyword;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: defaultKeyword = token; break;
            case 1: sequenceKeyword = token; break;
        }
    }
};

struct ExpressionCoverageBinInitializerSyntax : public CoverageBinInitializerSyntax {
    ExpressionSyntax* expr;
    WithClauseSyntax* withClause;

    ExpressionCoverageBinInitializerSyntax(ExpressionSyntax* expr, WithClauseSyntax* withClause) :
        CoverageBinInitializerSyntax(SyntaxKind::ExpressionCoverageBinInitializer), expr(expr), withClause(withClause)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return expr;
            case 1: return withClause;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
        }
        (void)token;
    }
};

struct RangeCoverageBinInitializerSyntax : public CoverageBinInitializerSyntax {
    OpenRangeListSyntax* ranges;
    WithClauseSyntax* withClause;

    RangeCoverageBinInitializerSyntax(OpenRangeListSyntax* ranges, WithClauseSyntax* withClause) :
        CoverageBinInitializerSyntax(SyntaxKind::RangeCoverageBinInitializer), ranges(ranges), withClause(withClause)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return ranges;
            case 1: return withClause;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: ASSERT(false); break;
        }
        (void)token;
    }
};

struct IffClauseSyntax : public SyntaxNode {
    Token iff;
    Token openParen;
    ExpressionSyntax* expr;
    Token closeParen;

    IffClauseSyntax(Token iff, Token openParen, ExpressionSyntax* expr, Token closeParen) :
        SyntaxNode(SyntaxKind::IffClause), iff(iff), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return iff;
            case 1: return openParen;
            case 2: return expr;
            case 3: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: iff = token; break;
            case 1: openParen = token; break;
            case 2: ASSERT(false); break;
            case 3: closeParen = token; break;
        }
    }
};

struct CoverageBinsSyntax : public MemberSyntax {
    Token wildcard;
    Token keyword;
    Token name;
    ElementSelectSyntax* selector;
    Token equals;
    CoverageBinInitializerSyntax* initializer;
    IffClauseSyntax* iff;
    Token semi;

    CoverageBinsSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token wildcard, Token keyword, Token name, ElementSelectSyntax* selector, Token equals, CoverageBinInitializerSyntax* initializer, IffClauseSyntax* iff, Token semi) :
        MemberSyntax(SyntaxKind::CoverageBins, attributes), wildcard(wildcard), keyword(keyword), name(name), selector(selector), equals(equals), initializer(initializer), iff(iff), semi(semi)
    {
        childCount += 8;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return wildcard;
            case 2: return keyword;
            case 3: return name;
            case 4: return selector;
            case 5: return equals;
            case 6: return initializer;
            case 7: return iff;
            case 8: return semi;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: wildcard = token; break;
            case 2: keyword = token; break;
            case 3: name = token; break;
            case 4: ASSERT(false); break;
            case 5: equals = token; break;
            case 6: ASSERT(false); break;
            case 7: ASSERT(false); break;
            case 8: semi = token; break;
        }
    }
};

// ----- TOP LEVEL -----

struct CompilationUnitSyntax : public SyntaxNode {
    SyntaxList<MemberSyntax> members;
    Token endOfFile;

    CompilationUnitSyntax(SyntaxList<MemberSyntax> members, Token endOfFile) :
        SyntaxNode(SyntaxKind::CompilationUnit), members(members), endOfFile(endOfFile)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &members;
            case 1: return endOfFile;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
            case 1: endOfFile = token; break;
        }
    }
};

// ----- DIRECTIVES -----

struct DirectiveSyntax : public SyntaxNode {
    Token directive;

    DirectiveSyntax(SyntaxKind kind, Token directive) :
        SyntaxNode(kind), directive(directive)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override {
        switch (index) {
            case 0: return directive;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override {
        switch (index) {
            case 0: directive = token; break;
        }
    }
};

struct SimpleDirectiveSyntax : public DirectiveSyntax {
    Token endOfDirective;

    SimpleDirectiveSyntax(SyntaxKind kind, Token directive, Token endOfDirective) :
        DirectiveSyntax(kind, directive), endOfDirective(endOfDirective)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return directive;
            case 1: return endOfDirective;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: directive = token; break;
            case 1: endOfDirective = token; break;
        }
    }
};

struct IncludeDirectiveSyntax : public DirectiveSyntax {
    Token fileName;
    Token endOfDirective;

    IncludeDirectiveSyntax(Token directive, Token fileName, Token endOfDirective) :
        DirectiveSyntax(SyntaxKind::IncludeDirective, directive), fileName(fileName), endOfDirective(endOfDirective)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return directive;
            case 1: return fileName;
            case 2: return endOfDirective;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: directive = token; break;
            case 1: fileName = token; break;
            case 2: endOfDirective = token; break;
        }
    }
};

struct ConditionalBranchDirectiveSyntax : public DirectiveSyntax {
    Token name;
    Token endOfDirective;
    TokenList disabledTokens;

    ConditionalBranchDirectiveSyntax(SyntaxKind kind, Token directive, Token name, Token endOfDirective, TokenList disabledTokens) :
        DirectiveSyntax(kind, directive), name(name), endOfDirective(endOfDirective), disabledTokens(disabledTokens)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return directive;
            case 1: return name;
            case 2: return endOfDirective;
            case 3: return &disabledTokens;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: directive = token; break;
            case 1: name = token; break;
            case 2: endOfDirective = token; break;
            case 3: ASSERT(false); break;
        }
    }
};

struct UnconditionalBranchDirectiveSyntax : public DirectiveSyntax {
    Token endOfDirective;
    TokenList disabledTokens;

    UnconditionalBranchDirectiveSyntax(SyntaxKind kind, Token directive, Token endOfDirective, TokenList disabledTokens) :
        DirectiveSyntax(kind, directive), endOfDirective(endOfDirective), disabledTokens(disabledTokens)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return directive;
            case 1: return endOfDirective;
            case 2: return &disabledTokens;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: directive = token; break;
            case 1: endOfDirective = token; break;
            case 2: ASSERT(false); break;
        }
    }
};

struct MacroArgumentDefaultSyntax : public SyntaxNode {
    Token equals;
    TokenList tokens;

    MacroArgumentDefaultSyntax(Token equals, TokenList tokens) :
        SyntaxNode(SyntaxKind::MacroArgumentDefault), equals(equals), tokens(tokens)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return equals;
            case 1: return &tokens;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: equals = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct MacroFormalArgumentSyntax : public SyntaxNode {
    Token name;
    MacroArgumentDefaultSyntax* defaultValue;

    MacroFormalArgumentSyntax(Token name, MacroArgumentDefaultSyntax* defaultValue) :
        SyntaxNode(SyntaxKind::MacroFormalArgument), name(name), defaultValue(defaultValue)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return name;
            case 1: return defaultValue;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: name = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct MacroFormalArgumentListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<MacroFormalArgumentSyntax> args;
    Token closeParen;

    MacroFormalArgumentListSyntax(Token openParen, SeparatedSyntaxList<MacroFormalArgumentSyntax> args, Token closeParen) :
        SyntaxNode(SyntaxKind::MacroFormalArgumentList), openParen(openParen), args(args), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &args;
            case 2: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openParen = token; break;
            case 1: ASSERT(false); break;
            case 2: closeParen = token; break;
        }
    }
};

struct DefineDirectiveSyntax : public DirectiveSyntax {
    Token name;
    MacroFormalArgumentListSyntax* formalArguments;
    TokenList body;
    Token endOfDirective;

    DefineDirectiveSyntax(Token directive, Token name, MacroFormalArgumentListSyntax* formalArguments, TokenList body, Token endOfDirective) :
        DirectiveSyntax(SyntaxKind::DefineDirective, directive), name(name), formalArguments(formalArguments), body(body), endOfDirective(endOfDirective)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return directive;
            case 1: return name;
            case 2: return formalArguments;
            case 3: return &body;
            case 4: return endOfDirective;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: directive = token; break;
            case 1: name = token; break;
            case 2: ASSERT(false); break;
            case 3: ASSERT(false); break;
            case 4: endOfDirective = token; break;
        }
    }
};

struct MacroActualArgumentSyntax : public SyntaxNode {
    TokenList tokens;

    MacroActualArgumentSyntax(TokenList tokens) :
        SyntaxNode(SyntaxKind::MacroActualArgument), tokens(tokens)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return &tokens;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: ASSERT(false); break;
        }
        (void)token;
    }
};

struct MacroActualArgumentListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<MacroActualArgumentSyntax> args;
    Token closeParen;

    MacroActualArgumentListSyntax(Token openParen, SeparatedSyntaxList<MacroActualArgumentSyntax> args, Token closeParen) :
        SyntaxNode(SyntaxKind::MacroActualArgumentList), openParen(openParen), args(args), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &args;
            case 2: return closeParen;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: openParen = token; break;
            case 1: ASSERT(false); break;
            case 2: closeParen = token; break;
        }
    }
};

struct MacroUsageSyntax : public DirectiveSyntax {
    MacroActualArgumentListSyntax* args;

    MacroUsageSyntax(Token directive, MacroActualArgumentListSyntax* args) :
        DirectiveSyntax(SyntaxKind::MacroUsage, directive), args(args)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return directive;
            case 1: return args;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: directive = token; break;
            case 1: ASSERT(false); break;
        }
    }
};

struct TimescaleDirectiveSyntax : public DirectiveSyntax {
    Token timeUnit;
    Token timeUnitUnit;
    Token slash;
    Token timePrecision;
    Token timePrecisionUnit;
    Token endOfDirective;

    TimescaleDirectiveSyntax(Token directive, Token timeUnit, Token timeUnitUnit, Token slash, Token timePrecision, Token timePrecisionUnit, Token endOfDirective) :
        DirectiveSyntax(SyntaxKind::TimescaleDirective, directive), timeUnit(timeUnit), timeUnitUnit(timeUnitUnit), slash(slash), timePrecision(timePrecision), timePrecisionUnit(timePrecisionUnit), endOfDirective(endOfDirective)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return directive;
            case 1: return timeUnit;
            case 2: return timeUnitUnit;
            case 3: return slash;
            case 4: return timePrecision;
            case 5: return timePrecisionUnit;
            case 6: return endOfDirective;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: directive = token; break;
            case 1: timeUnit = token; break;
            case 2: timeUnitUnit = token; break;
            case 3: slash = token; break;
            case 4: timePrecision = token; break;
            case 5: timePrecisionUnit = token; break;
            case 6: endOfDirective = token; break;
        }
    }
};

struct DefaultNetTypeDirectiveSyntax : public DirectiveSyntax {
    Token netType;
    Token endOfDirective;

    DefaultNetTypeDirectiveSyntax(Token directive, Token netType, Token endOfDirective) :
        DirectiveSyntax(SyntaxKind::DefaultNetTypeDirective, directive), netType(netType), endOfDirective(endOfDirective)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return directive;
            case 1: return netType;
            case 2: return endOfDirective;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: directive = token; break;
            case 1: netType = token; break;
            case 2: endOfDirective = token; break;
        }
    }
};

struct LineDirectiveSyntax : public DirectiveSyntax {
    Token lineNumber;
    Token fileName;
    Token level;
    Token endOfDirective;

    LineDirectiveSyntax(Token directive, Token lineNumber, Token fileName, Token level, Token endOfDirective) :
        DirectiveSyntax(SyntaxKind::LineDirective, directive), lineNumber(lineNumber), fileName(fileName), level(level), endOfDirective(endOfDirective)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return directive;
            case 1: return lineNumber;
            case 2: return fileName;
            case 3: return level;
            case 4: return endOfDirective;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: directive = token; break;
            case 1: lineNumber = token; break;
            case 2: fileName = token; break;
            case 3: level = token; break;
            case 4: endOfDirective = token; break;
        }
    }
};

struct UndefDirectiveSyntax : public DirectiveSyntax {
    Token name;
    Token endOfDirective;

    UndefDirectiveSyntax(Token directive, Token name, Token endOfDirective) :
        DirectiveSyntax(SyntaxKind::UndefDirective, directive), name(name), endOfDirective(endOfDirective)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return directive;
            case 1: return name;
            case 2: return endOfDirective;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: directive = token; break;
            case 1: name = token; break;
            case 2: endOfDirective = token; break;
        }
    }
};

struct BeginKeywordsDirectiveSyntax : public DirectiveSyntax {
    Token versionSpecifier;
    Token endOfDirective;

    BeginKeywordsDirectiveSyntax(Token directive, Token versionSpecifier, Token endOfDirective) :
        DirectiveSyntax(SyntaxKind::BeginKeywordsDirective, directive), versionSpecifier(versionSpecifier), endOfDirective(endOfDirective)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch (index) {
            case 0: return directive;
            case 1: return versionSpecifier;
            case 2: return endOfDirective;
            default: return nullptr;
        }
    }

    void replaceChild(uint32_t index, Token token) override final {
        switch (index) {
            case 0: directive = token; break;
            case 1: versionSpecifier = token; break;
            case 2: endOfDirective = token; break;
        }
    }
};

}
