//------------------------------------------------------------------------------
// SourceManager.h
// Source file management.
//
// File is under the MIT license; see LICENSE for details.
//------------------------------------------------------------------------------
#pragma once

#include <deque>
#include <memory>
#include <set>
#include <string>
#include <unordered_map>
#include <variant.hpp>
#include <vector>

#include "Buffer.h"
#include "BumpAllocator.h"
#include "Path.h"
#include "SourceLocation.h"
#include "StringRef.h"

namespace slang {

/// Represents a source buffer; that is, the actual text of the source
/// code along with an identifier for the buffer which potentially
/// encodes its include stack.
struct SourceBuffer {
    StringRef data;
    BufferID id;

    explicit operator bool() const { return id.valid(); }
};

/// SourceManager - Handles loading and tracking source files.
///
/// The source manager abstracts away the differences between
/// locations in files and locations generated by macro expansion.
/// See SourceLocation for more details.
///
/// TODO: The methods in this class should be thread safe.
class SourceManager {
public:
    SourceManager();

    /// Convert the given relative path into an absolute path.
    std::string makeAbsolutePath(StringRef path) const;

    /// Adds a system include directory.
    void addSystemDirectory(StringRef path);

    /// Adds a user include directory.
    void addUserDirectory(StringRef path);

    /// Gets the source line number for a given source location.
    /// @a location must be a file location.
    uint32_t getLineNumber(SourceLocation location);

    /// Gets the column line number for a given source location.
    /// @a location must be a file location.
    uint32_t getColumnNumber(SourceLocation location);

    /// Gets the file name of the given buffer.
    /// If @a buffer does not represent a file, the result will be an empty string.
    StringRef getBufferName(BufferID buffer);

    /// Gets a location that indicates from where the given buffer was included.
    /// @a location must be a file location.
    SourceLocation getIncludedFrom(BufferID buffer);

    /// Determines whether the given location exists in a source file.
    bool isFileLoc(SourceLocation location);

    /// Determines whether the given location points to a macro expansion.
    bool isMacroLoc(SourceLocation location);

    /// Gets the expansion location of a given macro location.
    SourceLocation getExpansionLoc(SourceLocation location);

    /// Gets the original source location of a given macro location.
    SourceLocation getOriginalLoc(SourceLocation location);

    /// Gets the actual source text for a given file buffer.
    StringRef getSourceText(BufferID buffer);

    /// Creates a macro expansion location; used by the preprocessor.
    SourceLocation createExpansionLoc(SourceLocation originalLoc, SourceLocation expansionStart, SourceLocation expansionEnd);

    /// Instead of loading source from a file, copy it from text already in memory.
    SourceBuffer assignText(StringRef text);

    /// Instead of loading source from a file, copy it from text already in memory.
    /// Pretend it came from a file located at @a path.
    SourceBuffer assignText(StringRef path, StringRef text);

    /// Instead of loading source from a file, move it from text already in memory.
    /// Pretend it came from a file located at @a path.
    SourceBuffer assignBuffer(StringRef path, Buffer<char>&& buffer);

    /// Read in a source file from disk.
    SourceBuffer readSource(StringRef path);

    /// Read in a header file from disk.
    SourceBuffer readHeader(StringRef path, SourceLocation includedFrom, bool isSystemPath);

private:
    BumpAllocator alloc;
    uint32_t unnamedBufferCount = 0;

    // Stores actual file contents and metadata; only one per loaded file
    struct FileData {
        Buffer<char> mem;                   // file contents
        std::string name;                   // name of the file
        std::vector<uint32_t> lineOffsets;  // char offset for each line
        const Path* directory;              // directory that the file exists in

        FileData(const Path* directory, const std::string& name, Buffer<char>&& data) :
            directory(directory),
            name(name),
            mem(std::move(data))
        {
        }
    };

    // Stores a pointer to file data along with information about where we included it.
    // There can potentially be many of these for a given file.
    struct FileInfo {
        FileData* data;
        SourceLocation includedFrom;

        FileInfo() {}
        FileInfo(FileData* data, SourceLocation includedFrom) :
            data(data), includedFrom(includedFrom)
        {
        }
    };

    // Instead of a file, this lets a BufferID point to a macro expansion location.
    // This is actually used two different ways; if this is a normal token from a
    // macro expansion, originalLocation will point to the token inside the macro
    // definition, and expansionLocation will point to the range of the macro usage
    // the expansion site. Alternatively, if this token came from an argument,
    // originalLocation will point to the argument at the expansion site and
    // expansionLocation will point to the parameter inside the macro body.
    struct ExpansionInfo {
        SourceLocation originalLoc;
        SourceLocation expansionStart;
        SourceLocation expansionEnd;

        ExpansionInfo() {}
        ExpansionInfo(SourceLocation originalLoc, SourceLocation expansionStart, SourceLocation expansionEnd) :
            originalLoc(originalLoc), expansionStart(expansionStart), expansionEnd(expansionEnd)
        {
        }
    };

    // index from BufferID to buffer metadata
    std::deque<variant<FileInfo, ExpansionInfo>> bufferEntries;

    // cache for file lookups; this holds on to the actual file data
    std::unordered_map<std::string, std::unique_ptr<FileData>> lookupCache;

    // directories for system and user includes
    std::vector<Path> systemDirectories;
    std::vector<Path> userDirectories;

    // uniquified backing memory for directories
    std::set<Path> directories;

    FileData* getFileData(BufferID buffer);
    SourceBuffer createBufferEntry(FileData* fd, SourceLocation includedFrom);

    SourceBuffer openCached(const Path& fullPath, SourceLocation includedFrom);
    SourceBuffer cacheBuffer(std::string&& canonicalPath, const Path& path, SourceLocation includedFrom, Buffer<char>&& buffer);

    static void computeLineOffsets(const Buffer<char>& buffer, std::vector<uint32_t>& offsets);
    static bool readFile(const Path& path, Buffer<char>& buffer);
};

}
